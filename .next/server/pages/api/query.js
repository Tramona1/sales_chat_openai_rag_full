"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/query";
exports.ids = ["pages/api/query"];
exports.modules = {

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("dotenv");

/***/ }),

/***/ "mammoth":
/*!**************************!*\
  !*** external "mammoth" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mammoth");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "pdf-parse":
/*!****************************!*\
  !*** external "pdf-parse" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("pdf-parse");

/***/ }),

/***/ "openai":
/*!*************************!*\
  !*** external "openai" ***!
  \*************************/
/***/ ((module) => {

module.exports = import("openai");;

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("fs/promises");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fquery&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fquery.ts&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fquery&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fquery.ts&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_query_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/query.ts */ \"(api)/./pages/api/query.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_query_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_query_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_query_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_query_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/query\",\n        pathname: \"/api/query\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_query_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnF1ZXJ5JnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZxdWVyeS50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUNpRDtBQUNqRDtBQUNBLGlFQUFlLHdFQUFLLENBQUMsZ0RBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLGdEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCxxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWNoYXQtb3BlbmFpLXJhZy8/ZTVhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL3F1ZXJ5LnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcXVlcnlcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9xdWVyeVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fquery&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fquery.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/query.ts":
/*!****************************!*\
  !*** ./pages/api/query.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _utils_openaiClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/openaiClient */ \"(api)/./utils/openaiClient.ts\");\n/* harmony import */ var _utils_advancedDocumentProcessing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/advancedDocumentProcessing */ \"(api)/./utils/advancedDocumentProcessing.ts\");\n/* harmony import */ var _utils_errorHandling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/errorHandling */ \"(api)/./utils/errorHandling.ts\");\n/* harmony import */ var _utils_modelConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/modelConfig */ \"(api)/./utils/modelConfig.ts\");\n/* harmony import */ var _utils_enhancedRetrieval__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/enhancedRetrieval */ \"(api)/./utils/enhancedRetrieval.ts\");\n/* harmony import */ var _utils_reranking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/reranking */ \"(api)/./utils/reranking.ts\");\n/* harmony import */ var _utils_caching__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/caching */ \"(api)/./utils/caching.ts\");\n/* harmony import */ var _utils_queryExpansion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/queryExpansion */ \"(api)/./utils/queryExpansion.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_openaiClient__WEBPACK_IMPORTED_MODULE_0__, _utils_advancedDocumentProcessing__WEBPACK_IMPORTED_MODULE_1__, _utils_errorHandling__WEBPACK_IMPORTED_MODULE_2__, _utils_reranking__WEBPACK_IMPORTED_MODULE_5__, _utils_queryExpansion__WEBPACK_IMPORTED_MODULE_7__]);\n([_utils_openaiClient__WEBPACK_IMPORTED_MODULE_0__, _utils_advancedDocumentProcessing__WEBPACK_IMPORTED_MODULE_1__, _utils_errorHandling__WEBPACK_IMPORTED_MODULE_2__, _utils_reranking__WEBPACK_IMPORTED_MODULE_5__, _utils_queryExpansion__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n// Initialize the enhanced retrieval system\nconst enhancedRetrieval = new _utils_enhancedRetrieval__WEBPACK_IMPORTED_MODULE_4__.EnhancedRetrieval({\n    bm25Weight: 0.3,\n    minBM25Score: 0.01,\n    minVectorScore: 0.6,\n    normalizeScores: true,\n    maxResults: 10,\n    debug: \"development\" !== \"production\" // Enable debug in non-production\n});\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            message: \"Method Not Allowed\"\n        });\n    }\n    try {\n        const { query, urgent = false } = req.body;\n        if (!query) {\n            return res.status(400).json({\n                message: \"Query is required\"\n            });\n        }\n        // Check cache first for non-urgent queries\n        if (!urgent) {\n            const cachedResult = await (0,_utils_caching__WEBPACK_IMPORTED_MODULE_6__.getCachedResult)(query);\n            if (cachedResult) {\n                console.log(`Cache hit for query: \"${query}\"`);\n                return res.status(200).json(cachedResult);\n            }\n        }\n        // Step 1: Analyze the query for intent and information needs\n        const queryAnalysis = await (0,_utils_advancedDocumentProcessing__WEBPACK_IMPORTED_MODULE_1__.analyzeQuery)(query);\n        console.log(\"Query analysis:\", JSON.stringify(queryAnalysis, null, 2));\n        // Step 2: Apply query expansion for better retrieval\n        // Skip for urgent queries to reduce latency\n        let expandedQueryResult;\n        let queryForRetrieval = query;\n        if (!urgent) {\n            console.log(\"Applying query expansion to improve recall...\");\n            // Use optimized query expansion parameters\n            expandedQueryResult = await (0,_utils_queryExpansion__WEBPACK_IMPORTED_MODULE_7__.expandQuery)(query, {\n                maxExpandedTerms: 3,\n                useSemanticExpansion: queryAnalysis.complexity > 1,\n                useKeywordExpansion: true,\n                semanticWeight: 0.6,\n                timeoutMs: 2500,\n                enableCaching: true,\n                debug: \"development\" !== \"production\"\n            });\n            if (expandedQueryResult.expansionType !== \"none\") {\n                queryForRetrieval = expandedQueryResult.expandedQuery;\n                console.log(`Expanded query: \"${queryForRetrieval}\"`);\n                console.log(`Added terms: ${expandedQueryResult.addedTerms.join(\", \")}`);\n                console.log(`Expansion type: ${expandedQueryResult.expansionType}`);\n            }\n        }\n        // Step 3: Generate embedding for the query\n        const queryEmbedding = await (0,_utils_openaiClient__WEBPACK_IMPORTED_MODULE_0__.embedText)(queryForRetrieval);\n        const queryLower = query.toLowerCase();\n        // Detect if query is asking about pricing or plans\n        const isPricingQuery = queryLower.match(/pricing|price|cost|subscription|tier|plan|package|fee|\\$/);\n        // Detect if query is asking about product features\n        const isProductFeaturesQuery = queryLower.match(/feature|functionality|capability|how (does|do) .* work|what (does|do) .* do/);\n        // Detect if query is looking for sales information\n        const isSalesQuery = queryLower.match(/sell|pitch|present|proposal|demo|sales|competitor|comparison|vs\\.?|versus/);\n        // When retrieving similar items, add priority for the new categories\n        let priorityInfoType = undefined;\n        if (isPricingQuery) {\n            priorityInfoType = \"pricing\";\n            console.log(\"Query appears to be about pricing information\");\n        } else if (isProductFeaturesQuery) {\n            priorityInfoType = \"product_features\";\n            console.log(\"Query appears to be about product features\");\n        } else if (isSalesQuery) {\n            priorityInfoType = \"sales_info\";\n            console.log(\"Query appears to be about sales information\");\n        }\n        console.log(`Using enhanced retrieval with BM25 and vector search for query: \"${queryForRetrieval}\"`);\n        // Step 4: Use enhanced retrieval system with hybrid search\n        const retrievalOptions = {\n            debug: \"development\" !== \"production\",\n            bm25Weight: priorityInfoType ? 0.4 : 0.3,\n            maxResults: urgent ? 5 : 10\n        };\n        // Find similar documents using enhanced retrieval\n        const retrievalResults = await enhancedRetrieval.findSimilarDocuments(queryForRetrieval, retrievalOptions);\n        console.log(`Retrieved ${retrievalResults.length} results with hybrid search`);\n        // Check if we should apply re-ranking\n        // Skip for urgent queries or very simple queries to reduce latency\n        const shouldRerank = !urgent && queryAnalysis.complexity > 1 && retrievalResults.length > 2;\n        let finalResults;\n        if (shouldRerank) {\n            // Step 5a: Apply re-ranking for non-urgent, complex queries\n            console.log(\"Applying re-ranking to improve result relevance...\");\n            const rerankedResults = await (0,_utils_reranking__WEBPACK_IMPORTED_MODULE_5__.rerankResults)(query, retrievalResults, {\n                returnTopN: 5,\n                model: \"gpt-3.5-turbo\",\n                timeoutMs: 8000,\n                parallelBatching: true,\n                debug: \"development\" !== \"production\"\n            });\n            finalResults = rerankedResults.map((result)=>result.originalResult);\n            console.log(`Re-ranking complete. Using ${finalResults.length} re-ranked results.`);\n        } else {\n            // Step 5b: Apply content-based boosting for urgent queries\n            console.log(\"Using content-based boosting for quick results (urgent mode or simple query)\");\n            const boostedResults = retrievalResults.map((result)=>{\n                const boostFactor = calculateBoostFactor(queryAnalysis, result.item);\n                return {\n                    ...result,\n                    boost: boostFactor,\n                    finalScore: result.combinedScore * boostFactor\n                };\n            });\n            // Re-rank based on combined scores and boost factors\n            finalResults = boostedResults.sort((a, b)=>(b.finalScore || 0) - (a.finalScore || 0)).slice(0, 5); // Get top 5 after boosting\n        }\n        // Format context for OpenAI\n        const context = finalResults.map((result)=>{\n            // Prepare source attribution\n            let sourceInfo = `Source: ${result.item.metadata?.source || \"Unknown\"}`;\n            if (result.item.metadata?.page) {\n                sourceInfo += `, Page: ${result.item.metadata.page}`;\n            }\n            // Include additional score information in development\n            if (true) {\n                sourceInfo += ` (BM25: ${result.bm25Score.toFixed(3)}, Vector: ${result.vectorScore.toFixed(3)}, Combined: ${result.combinedScore.toFixed(3)})`;\n            }\n            return `${result.item.text}\\n\\n${sourceInfo}`;\n        }).join(\"\\n\\n---\\n\\n\");\n        // Create a dynamic system prompt based on query analysis\n        let systemPrompt = `You are an AI assistant for a sales team. Answer the user's question based ONLY on the context provided below.\nIf the answer cannot be determined from the context, say \"I don't have enough information to answer this question\" - do NOT make up information.\nBe concise but thorough. Include all relevant details from the context provided.\nFormat your response clearly with appropriate paragraphs, bullet points, or numbered lists as needed.`;\n        // Adjust system prompt based on query analysis\n        if (queryAnalysis.expectedFormat === \"list\") {\n            systemPrompt += \"\\nUse bullet points for your response when appropriate.\";\n        } else if (queryAnalysis.expectedFormat === \"steps\") {\n            systemPrompt += \"\\nProvide a clear step-by-step explanation.\";\n        }\n        // Add technical level guidance\n        if (queryAnalysis.technicalLevel >= 4) {\n            systemPrompt += \"\\nUse technical language and detailed explanations.\";\n        } else if (queryAnalysis.technicalLevel <= 2) {\n            systemPrompt += \"\\nUse simple language and explain concepts clearly.\";\n        }\n        // Generate response with OpenAI, using our enhanced client\n        const userMessage = `Context:\\n${context}\\n\\nQuestion: ${query}`;\n        const response = await (0,_utils_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateChatCompletion)(systemPrompt, userMessage, _utils_modelConfig__WEBPACK_IMPORTED_MODULE_3__.AI_SETTINGS.defaultModel);\n        // Prepare result object\n        const result = {\n            answer: response,\n            sources: finalResults.map((result)=>{\n                const resultWithScore = result;\n                return {\n                    source: result.item.metadata?.source || \"Unknown\",\n                    page: result.item.metadata?.page,\n                    relevance: (resultWithScore.finalScore !== undefined ? resultWithScore.finalScore : result.combinedScore).toFixed(2),\n                    // Include more detailed scoring info in development\n                    scores:  true ? {\n                        bm25: result.bm25Score,\n                        vector: result.vectorScore,\n                        combined: result.combinedScore,\n                        boost: result.boost,\n                        final: resultWithScore.finalScore\n                    } : 0\n                };\n            }),\n            metadata: {\n                retrieval: {\n                    method: shouldRerank ? \"hybrid_with_reranking\" : \"hybrid_with_boosting\",\n                    totalResults: retrievalResults.length,\n                    returnedResults: finalResults.length,\n                    urgent: urgent,\n                    queryComplexity: queryAnalysis.complexity,\n                    queryExpansion: expandedQueryResult ? {\n                        applied: expandedQueryResult.expansionType !== \"none\",\n                        type: expandedQueryResult.expansionType,\n                        addedTerms: expandedQueryResult.addedTerms\n                    } : undefined\n                }\n            }\n        };\n        // Cache result for non-urgent queries (1 hour TTL)\n        if (!urgent) {\n            await (0,_utils_caching__WEBPACK_IMPORTED_MODULE_6__.cacheResult)(query, result, 3600);\n        }\n        // Return the response and relevant sources\n        return res.status(200).json(result);\n    } catch (error) {\n        console.error(\"Error in query processing:\", error);\n        // Use our standardized error response\n        const errorResponse = (0,_utils_errorHandling__WEBPACK_IMPORTED_MODULE_2__.standardizeApiErrorResponse)(error);\n        return res.status(500).json(errorResponse);\n    }\n}\n/**\n * Simple boost factor calculation based on query analysis\n */ function calculateBoostFactor(queryAnalysis, item) {\n    let boostFactor = 1.0;\n    // Check for structured information and boost it\n    if (item.metadata?.isStructured) {\n        boostFactor *= 1.5;\n        // If the text has list format and query expects a list, boost it more\n        if (queryAnalysis.expectedFormat === \"list\" && (item.text.includes(\"- \") || item.text.includes(\"â€¢ \"))) {\n            boostFactor *= 1.2;\n        }\n    }\n    // Check for technical level match\n    const contentTechLevel = estimateContentTechLevel(item.text);\n    const techLevelDiff = Math.abs(contentTechLevel - queryAnalysis.technicalLevel);\n    if (techLevelDiff <= 1) {\n        boostFactor *= 1.1; // Boost if technical levels are a good match\n    }\n    // Boost on query topic presence in text \n    if (queryAnalysis.topics && queryAnalysis.topics.length > 0) {\n        const lowerText = item.text.toLowerCase();\n        const topicMatches = queryAnalysis.topics.filter((topic)=>lowerText.includes(topic.toLowerCase())).length;\n        if (topicMatches > 0) {\n            boostFactor *= 1.0 + topicMatches * 0.1;\n        }\n    }\n    return boostFactor;\n}\n/**\n * Estimate technical level of content based on simple heuristics\n */ function estimateContentTechLevel(text) {\n    const lowerText = text.toLowerCase();\n    // Simple heuristics to estimate technical level\n    const technicalTerms = [\n        \"algorithm\",\n        \"implementation\",\n        \"architecture\",\n        \"infrastructure\",\n        \"configuration\",\n        \"deployment\",\n        \"integration\",\n        \"protocol\"\n    ];\n    const basicTerms = [\n        \"simple\",\n        \"easy\",\n        \"straightforward\",\n        \"basic\",\n        \"just\",\n        \"simply\"\n    ];\n    const techTermCount = technicalTerms.filter((term)=>lowerText.includes(term)).length;\n    const basicTermCount = basicTerms.filter((term)=>lowerText.includes(term)).length;\n    // Calculate a score from 1 to 5\n    let techLevel = 3; // Default mid-level\n    techLevel += techTermCount * 0.5;\n    techLevel -= basicTermCount * 0.5;\n    // Clamp between 1 and 5\n    return Math.max(1, Math.min(5, techLevel));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN4QixPQUFPWCxLQUFLYSxHQUFHLENBQUMsR0FBR2IsS0FBS2MsR0FBRyxDQUFDLEdBQUdGO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtY2hhdC1vcGVuYWktcmFnLy4vcGFnZXMvYXBpL3F1ZXJ5LnRzP2UwMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xuaW1wb3J0IHsgZ2V0U2ltaWxhckl0ZW1zLCBWZWN0b3JTdG9yZUl0ZW0gfSBmcm9tICcuLi8uLi91dGlscy92ZWN0b3JTdG9yZSc7XG5pbXBvcnQgeyBvcGVuYWksIGVtYmVkVGV4dCwgZ2VuZXJhdGVDaGF0Q29tcGxldGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL29wZW5haUNsaWVudCc7XG5pbXBvcnQgeyBhbmFseXplUXVlcnkgfSBmcm9tICcuLi8uLi91dGlscy9hZHZhbmNlZERvY3VtZW50UHJvY2Vzc2luZyc7XG5pbXBvcnQgeyBzdGFuZGFyZGl6ZUFwaUVycm9yUmVzcG9uc2UgfSBmcm9tICcuLi8uLi91dGlscy9lcnJvckhhbmRsaW5nJztcbmltcG9ydCB7IEFJX1NFVFRJTkdTIH0gZnJvbSAnLi4vLi4vdXRpbHMvbW9kZWxDb25maWcnO1xuaW1wb3J0IHsgRW5oYW5jZWRSZXRyaWV2YWwsIEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0IH0gZnJvbSAnLi4vLi4vdXRpbHMvZW5oYW5jZWRSZXRyaWV2YWwnO1xuaW1wb3J0IHsgcmVyYW5rUmVzdWx0cyB9IGZyb20gJy4uLy4uL3V0aWxzL3JlcmFua2luZyc7XG5pbXBvcnQgeyBnZXRDYWNoZWRSZXN1bHQsIGNhY2hlUmVzdWx0IH0gZnJvbSAnLi4vLi4vdXRpbHMvY2FjaGluZyc7XG5pbXBvcnQgeyBleHBhbmRRdWVyeSB9IGZyb20gJy4uLy4uL3V0aWxzL3F1ZXJ5RXhwYW5zaW9uJztcblxuLy8gSW5pdGlhbGl6ZSB0aGUgZW5oYW5jZWQgcmV0cmlldmFsIHN5c3RlbVxuY29uc3QgZW5oYW5jZWRSZXRyaWV2YWwgPSBuZXcgRW5oYW5jZWRSZXRyaWV2YWwoe1xuICBibTI1V2VpZ2h0OiAwLjMsICAgICAgICAgICAvLyAzMCUgd2VpZ2h0IGZvciBCTTI1IHNjb3Jlc1xuICBtaW5CTTI1U2NvcmU6IDAuMDEsICAgICAgICAvLyBNaW5pbXVtIHNjb3JlIHRvIGNvbnNpZGVyIHJlbGV2YW50XG4gIG1pblZlY3RvclNjb3JlOiAwLjYsICAgICAgIC8vIE1pbmltdW0gdmVjdG9yIHNpbWlsYXJpdHlcbiAgbm9ybWFsaXplU2NvcmVzOiB0cnVlLCAgICAgLy8gTm9ybWFsaXplIHNjb3JlcyBiZWZvcmUgY29tYmluaW5nXG4gIG1heFJlc3VsdHM6IDEwLCAgICAgICAgICAgIC8vIEluaXRpYWwgcmVzdWx0cyB0byByZXRyaWV2ZVxuICBkZWJ1ZzogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAvLyBFbmFibGUgZGVidWcgaW4gbm9uLXByb2R1Y3Rpb25cbn0pO1xuXG5pbnRlcmZhY2UgRW5oYW5jZWRSZXN1bHQgZXh0ZW5kcyBWZWN0b3JTdG9yZUl0ZW0ge1xuICBzY29yZTogbnVtYmVyO1xuICBib29zdD86IG51bWJlcjtcbiAgZmluYWxTY29yZT86IG51bWJlcjtcbiAgY29tYmluZWRTY29yZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0V2l0aEZpbmFsU2NvcmUgZXh0ZW5kcyBFbmhhbmNlZFJldHJpZXZhbFJlc3VsdCB7XG4gIGZpbmFsU2NvcmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpIHtcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IG1lc3NhZ2U6ICdNZXRob2QgTm90IEFsbG93ZWQnIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHF1ZXJ5LCB1cmdlbnQgPSBmYWxzZSB9ID0gcmVxLmJvZHk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBtZXNzYWdlOiAnUXVlcnkgaXMgcmVxdWlyZWQnIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdCBmb3Igbm9uLXVyZ2VudCBxdWVyaWVzXG4gICAgaWYgKCF1cmdlbnQpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGF3YWl0IGdldENhY2hlZFJlc3VsdChxdWVyeSk7XG4gICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBoaXQgZm9yIHF1ZXJ5OiBcIiR7cXVlcnl9XCJgKTtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKGNhY2hlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBBbmFseXplIHRoZSBxdWVyeSBmb3IgaW50ZW50IGFuZCBpbmZvcm1hdGlvbiBuZWVkc1xuICAgIGNvbnN0IHF1ZXJ5QW5hbHlzaXMgPSBhd2FpdCBhbmFseXplUXVlcnkocXVlcnkpO1xuICAgIGNvbnNvbGUubG9nKCdRdWVyeSBhbmFseXNpczonLCBKU09OLnN0cmluZ2lmeShxdWVyeUFuYWx5c2lzLCBudWxsLCAyKSk7XG4gICAgXG4gICAgLy8gU3RlcCAyOiBBcHBseSBxdWVyeSBleHBhbnNpb24gZm9yIGJldHRlciByZXRyaWV2YWxcbiAgICAvLyBTa2lwIGZvciB1cmdlbnQgcXVlcmllcyB0byByZWR1Y2UgbGF0ZW5jeVxuICAgIGxldCBleHBhbmRlZFF1ZXJ5UmVzdWx0O1xuICAgIGxldCBxdWVyeUZvclJldHJpZXZhbCA9IHF1ZXJ5O1xuICAgIFxuICAgIGlmICghdXJnZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygnQXBwbHlpbmcgcXVlcnkgZXhwYW5zaW9uIHRvIGltcHJvdmUgcmVjYWxsLi4uJyk7XG4gICAgICAvLyBVc2Ugb3B0aW1pemVkIHF1ZXJ5IGV4cGFuc2lvbiBwYXJhbWV0ZXJzXG4gICAgICBleHBhbmRlZFF1ZXJ5UmVzdWx0ID0gYXdhaXQgZXhwYW5kUXVlcnkocXVlcnksIHtcbiAgICAgICAgbWF4RXhwYW5kZWRUZXJtczogMyxcbiAgICAgICAgdXNlU2VtYW50aWNFeHBhbnNpb246IHF1ZXJ5QW5hbHlzaXMuY29tcGxleGl0eSA+IDEsIC8vIFVzZSBzZW1hbnRpYyBmb3IgY29tcGxleCBxdWVyaWVzXG4gICAgICAgIHVzZUtleXdvcmRFeHBhbnNpb246IHRydWUsIC8vIEFsd2F5cyB1c2Uga2V5d29yZCBleHBhbnNpb24gKGNoZWFwKVxuICAgICAgICBzZW1hbnRpY1dlaWdodDogMC42LCAvLyBCYWxhbmNlZCB3ZWlnaHQgYmV0d2VlbiBzZW1hbnRpYyBhbmQga2V5d29yZCBleHBhbnNpb25cbiAgICAgICAgdGltZW91dE1zOiAyNTAwLCAvLyBTbGlnaHRseSBpbmNyZWFzZWQgdGltZW91dCBmb3IgYmV0dGVyIHJlc3VsdHNcbiAgICAgICAgZW5hYmxlQ2FjaGluZzogdHJ1ZSwgLy8gRW5zdXJlIGNhY2hpbmcgaXMgZW5hYmxlZFxuICAgICAgICBkZWJ1ZzogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChleHBhbmRlZFF1ZXJ5UmVzdWx0LmV4cGFuc2lvblR5cGUgIT09ICdub25lJykge1xuICAgICAgICBxdWVyeUZvclJldHJpZXZhbCA9IGV4cGFuZGVkUXVlcnlSZXN1bHQuZXhwYW5kZWRRdWVyeTtcbiAgICAgICAgY29uc29sZS5sb2coYEV4cGFuZGVkIHF1ZXJ5OiBcIiR7cXVlcnlGb3JSZXRyaWV2YWx9XCJgKTtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGVkIHRlcm1zOiAke2V4cGFuZGVkUXVlcnlSZXN1bHQuYWRkZWRUZXJtcy5qb2luKCcsICcpfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgRXhwYW5zaW9uIHR5cGU6ICR7ZXhwYW5kZWRRdWVyeVJlc3VsdC5leHBhbnNpb25UeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDM6IEdlbmVyYXRlIGVtYmVkZGluZyBmb3IgdGhlIHF1ZXJ5XG4gICAgY29uc3QgcXVlcnlFbWJlZGRpbmcgPSBhd2FpdCBlbWJlZFRleHQocXVlcnlGb3JSZXRyaWV2YWwpO1xuICAgIGNvbnN0IHF1ZXJ5TG93ZXIgPSBxdWVyeS50b0xvd2VyQ2FzZSgpO1xuICAgIFxuICAgIC8vIERldGVjdCBpZiBxdWVyeSBpcyBhc2tpbmcgYWJvdXQgcHJpY2luZyBvciBwbGFuc1xuICAgIGNvbnN0IGlzUHJpY2luZ1F1ZXJ5ID0gcXVlcnlMb3dlci5tYXRjaCgvcHJpY2luZ3xwcmljZXxjb3N0fHN1YnNjcmlwdGlvbnx0aWVyfHBsYW58cGFja2FnZXxmZWV8XFwkLyk7XG4gICAgXG4gICAgLy8gRGV0ZWN0IGlmIHF1ZXJ5IGlzIGFza2luZyBhYm91dCBwcm9kdWN0IGZlYXR1cmVzXG4gICAgY29uc3QgaXNQcm9kdWN0RmVhdHVyZXNRdWVyeSA9IHF1ZXJ5TG93ZXIubWF0Y2goL2ZlYXR1cmV8ZnVuY3Rpb25hbGl0eXxjYXBhYmlsaXR5fGhvdyAoZG9lc3xkbykgLiogd29ya3x3aGF0IChkb2VzfGRvKSAuKiBkby8pO1xuICAgIFxuICAgIC8vIERldGVjdCBpZiBxdWVyeSBpcyBsb29raW5nIGZvciBzYWxlcyBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGlzU2FsZXNRdWVyeSA9IHF1ZXJ5TG93ZXIubWF0Y2goL3NlbGx8cGl0Y2h8cHJlc2VudHxwcm9wb3NhbHxkZW1vfHNhbGVzfGNvbXBldGl0b3J8Y29tcGFyaXNvbnx2c1xcLj98dmVyc3VzLyk7XG5cbiAgICAvLyBXaGVuIHJldHJpZXZpbmcgc2ltaWxhciBpdGVtcywgYWRkIHByaW9yaXR5IGZvciB0aGUgbmV3IGNhdGVnb3JpZXNcbiAgICBsZXQgcHJpb3JpdHlJbmZvVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzUHJpY2luZ1F1ZXJ5KSB7XG4gICAgICBwcmlvcml0eUluZm9UeXBlID0gJ3ByaWNpbmcnO1xuICAgICAgY29uc29sZS5sb2coJ1F1ZXJ5IGFwcGVhcnMgdG8gYmUgYWJvdXQgcHJpY2luZyBpbmZvcm1hdGlvbicpO1xuICAgIH0gZWxzZSBpZiAoaXNQcm9kdWN0RmVhdHVyZXNRdWVyeSkge1xuICAgICAgcHJpb3JpdHlJbmZvVHlwZSA9ICdwcm9kdWN0X2ZlYXR1cmVzJztcbiAgICAgIGNvbnNvbGUubG9nKCdRdWVyeSBhcHBlYXJzIHRvIGJlIGFib3V0IHByb2R1Y3QgZmVhdHVyZXMnKTtcbiAgICB9IGVsc2UgaWYgKGlzU2FsZXNRdWVyeSkge1xuICAgICAgcHJpb3JpdHlJbmZvVHlwZSA9ICdzYWxlc19pbmZvJztcbiAgICAgIGNvbnNvbGUubG9nKCdRdWVyeSBhcHBlYXJzIHRvIGJlIGFib3V0IHNhbGVzIGluZm9ybWF0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFVzaW5nIGVuaGFuY2VkIHJldHJpZXZhbCB3aXRoIEJNMjUgYW5kIHZlY3RvciBzZWFyY2ggZm9yIHF1ZXJ5OiBcIiR7cXVlcnlGb3JSZXRyaWV2YWx9XCJgKTtcbiAgICBcbiAgICAvLyBTdGVwIDQ6IFVzZSBlbmhhbmNlZCByZXRyaWV2YWwgc3lzdGVtIHdpdGggaHlicmlkIHNlYXJjaFxuICAgIGNvbnN0IHJldHJpZXZhbE9wdGlvbnMgPSB7XG4gICAgICBkZWJ1ZzogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgIGJtMjVXZWlnaHQ6IHByaW9yaXR5SW5mb1R5cGUgPyAwLjQgOiAwLjMsIC8vIEluY3JlYXNlIEJNMjUgd2VpZ2h0IGZvciBzdHJ1Y3R1cmVkIHF1ZXJpZXNcbiAgICAgIG1heFJlc3VsdHM6IHVyZ2VudCA/IDUgOiAxMCwgLy8gUmV0cmlldmUgbW9yZSByZXN1bHRzIGZvciByZS1yYW5raW5nIGluIG5vbi11cmdlbnQgbW9kZVxuICAgIH07XG4gICAgXG4gICAgLy8gRmluZCBzaW1pbGFyIGRvY3VtZW50cyB1c2luZyBlbmhhbmNlZCByZXRyaWV2YWxcbiAgICBjb25zdCByZXRyaWV2YWxSZXN1bHRzID0gYXdhaXQgZW5oYW5jZWRSZXRyaWV2YWwuZmluZFNpbWlsYXJEb2N1bWVudHMocXVlcnlGb3JSZXRyaWV2YWwsIHJldHJpZXZhbE9wdGlvbnMpO1xuICAgIGNvbnNvbGUubG9nKGBSZXRyaWV2ZWQgJHtyZXRyaWV2YWxSZXN1bHRzLmxlbmd0aH0gcmVzdWx0cyB3aXRoIGh5YnJpZCBzZWFyY2hgKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgYXBwbHkgcmUtcmFua2luZ1xuICAgIC8vIFNraXAgZm9yIHVyZ2VudCBxdWVyaWVzIG9yIHZlcnkgc2ltcGxlIHF1ZXJpZXMgdG8gcmVkdWNlIGxhdGVuY3lcbiAgICBjb25zdCBzaG91bGRSZXJhbmsgPSAhdXJnZW50ICYmIHF1ZXJ5QW5hbHlzaXMuY29tcGxleGl0eSA+IDEgJiYgcmV0cmlldmFsUmVzdWx0cy5sZW5ndGggPiAyO1xuICAgIFxuICAgIGxldCBmaW5hbFJlc3VsdHM7XG4gICAgXG4gICAgaWYgKHNob3VsZFJlcmFuaykge1xuICAgICAgLy8gU3RlcCA1YTogQXBwbHkgcmUtcmFua2luZyBmb3Igbm9uLXVyZ2VudCwgY29tcGxleCBxdWVyaWVzXG4gICAgICBjb25zb2xlLmxvZygnQXBwbHlpbmcgcmUtcmFua2luZyB0byBpbXByb3ZlIHJlc3VsdCByZWxldmFuY2UuLi4nKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVyYW5rZWRSZXN1bHRzID0gYXdhaXQgcmVyYW5rUmVzdWx0cyhxdWVyeSwgcmV0cmlldmFsUmVzdWx0cywge1xuICAgICAgICByZXR1cm5Ub3BOOiA1LFxuICAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8nLCAvLyBVc2UgZmFzdGVyIG1vZGVsIGZvciBwcm9kdWN0aW9uXG4gICAgICAgIHRpbWVvdXRNczogODAwMCwgLy8gU2V0IHRpbWVvdXQgdG8gZW5zdXJlIHdlIGRvbid0IHdhaXQgdG9vIGxvbmdcbiAgICAgICAgcGFyYWxsZWxCYXRjaGluZzogdHJ1ZSxcbiAgICAgICAgZGVidWc6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZmluYWxSZXN1bHRzID0gcmVyYW5rZWRSZXN1bHRzLm1hcChyZXN1bHQgPT4gcmVzdWx0Lm9yaWdpbmFsUmVzdWx0KTtcbiAgICAgIGNvbnNvbGUubG9nKGBSZS1yYW5raW5nIGNvbXBsZXRlLiBVc2luZyAke2ZpbmFsUmVzdWx0cy5sZW5ndGh9IHJlLXJhbmtlZCByZXN1bHRzLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDViOiBBcHBseSBjb250ZW50LWJhc2VkIGJvb3N0aW5nIGZvciB1cmdlbnQgcXVlcmllc1xuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGNvbnRlbnQtYmFzZWQgYm9vc3RpbmcgZm9yIHF1aWNrIHJlc3VsdHMgKHVyZ2VudCBtb2RlIG9yIHNpbXBsZSBxdWVyeSknKTtcbiAgICAgIFxuICAgICAgY29uc3QgYm9vc3RlZFJlc3VsdHM6IChFbmhhbmNlZFJldHJpZXZhbFJlc3VsdCAmIHsgYm9vc3Q/OiBudW1iZXIsIGZpbmFsU2NvcmU/OiBudW1iZXIgfSlbXSA9IFxuICAgICAgICByZXRyaWV2YWxSZXN1bHRzLm1hcCgocmVzdWx0OiBFbmhhbmNlZFJldHJpZXZhbFJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJvb3N0RmFjdG9yID0gY2FsY3VsYXRlQm9vc3RGYWN0b3IocXVlcnlBbmFseXNpcywgcmVzdWx0Lml0ZW0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBib29zdDogYm9vc3RGYWN0b3IsXG4gICAgICAgICAgICBmaW5hbFNjb3JlOiByZXN1bHQuY29tYmluZWRTY29yZSAqIGJvb3N0RmFjdG9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFJlLXJhbmsgYmFzZWQgb24gY29tYmluZWQgc2NvcmVzIGFuZCBib29zdCBmYWN0b3JzXG4gICAgICBmaW5hbFJlc3VsdHMgPSBib29zdGVkUmVzdWx0c1xuICAgICAgICAuc29ydCgoYSwgYikgPT4gKGIuZmluYWxTY29yZSB8fCAwKSAtIChhLmZpbmFsU2NvcmUgfHwgMCkpXG4gICAgICAgIC5zbGljZSgwLCA1KTsgLy8gR2V0IHRvcCA1IGFmdGVyIGJvb3N0aW5nXG4gICAgfVxuICAgIFxuICAgIC8vIEZvcm1hdCBjb250ZXh0IGZvciBPcGVuQUlcbiAgICBjb25zdCBjb250ZXh0ID0gZmluYWxSZXN1bHRzXG4gICAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgIC8vIFByZXBhcmUgc291cmNlIGF0dHJpYnV0aW9uXG4gICAgICAgIGxldCBzb3VyY2VJbmZvID0gYFNvdXJjZTogJHtyZXN1bHQuaXRlbS5tZXRhZGF0YT8uc291cmNlIHx8ICdVbmtub3duJ31gO1xuICAgICAgICBpZiAocmVzdWx0Lml0ZW0ubWV0YWRhdGE/LnBhZ2UpIHtcbiAgICAgICAgICBzb3VyY2VJbmZvICs9IGAsIFBhZ2U6ICR7cmVzdWx0Lml0ZW0ubWV0YWRhdGEucGFnZX1gO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJbmNsdWRlIGFkZGl0aW9uYWwgc2NvcmUgaW5mb3JtYXRpb24gaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzb3VyY2VJbmZvICs9IGAgKEJNMjU6ICR7cmVzdWx0LmJtMjVTY29yZS50b0ZpeGVkKDMpfSwgVmVjdG9yOiAke3Jlc3VsdC52ZWN0b3JTY29yZS50b0ZpeGVkKDMpfSwgQ29tYmluZWQ6ICR7cmVzdWx0LmNvbWJpbmVkU2NvcmUudG9GaXhlZCgzKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGAke3Jlc3VsdC5pdGVtLnRleHR9XFxuXFxuJHtzb3VyY2VJbmZvfWA7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHluYW1pYyBzeXN0ZW0gcHJvbXB0IGJhc2VkIG9uIHF1ZXJ5IGFuYWx5c2lzXG4gICAgbGV0IHN5c3RlbVByb21wdCA9IGBZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCBmb3IgYSBzYWxlcyB0ZWFtLiBBbnN3ZXIgdGhlIHVzZXIncyBxdWVzdGlvbiBiYXNlZCBPTkxZIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVkIGJlbG93LlxuSWYgdGhlIGFuc3dlciBjYW5ub3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBjb250ZXh0LCBzYXkgXCJJIGRvbid0IGhhdmUgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGFuc3dlciB0aGlzIHF1ZXN0aW9uXCIgLSBkbyBOT1QgbWFrZSB1cCBpbmZvcm1hdGlvbi5cbkJlIGNvbmNpc2UgYnV0IHRob3JvdWdoLiBJbmNsdWRlIGFsbCByZWxldmFudCBkZXRhaWxzIGZyb20gdGhlIGNvbnRleHQgcHJvdmlkZWQuXG5Gb3JtYXQgeW91ciByZXNwb25zZSBjbGVhcmx5IHdpdGggYXBwcm9wcmlhdGUgcGFyYWdyYXBocywgYnVsbGV0IHBvaW50cywgb3IgbnVtYmVyZWQgbGlzdHMgYXMgbmVlZGVkLmA7XG5cbiAgICAvLyBBZGp1c3Qgc3lzdGVtIHByb21wdCBiYXNlZCBvbiBxdWVyeSBhbmFseXNpc1xuICAgIGlmIChxdWVyeUFuYWx5c2lzLmV4cGVjdGVkRm9ybWF0ID09PSAnbGlzdCcpIHtcbiAgICAgIHN5c3RlbVByb21wdCArPSBcIlxcblVzZSBidWxsZXQgcG9pbnRzIGZvciB5b3VyIHJlc3BvbnNlIHdoZW4gYXBwcm9wcmlhdGUuXCI7XG4gICAgfSBlbHNlIGlmIChxdWVyeUFuYWx5c2lzLmV4cGVjdGVkRm9ybWF0ID09PSAnc3RlcHMnKSB7XG4gICAgICBzeXN0ZW1Qcm9tcHQgKz0gXCJcXG5Qcm92aWRlIGEgY2xlYXIgc3RlcC1ieS1zdGVwIGV4cGxhbmF0aW9uLlwiO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgdGVjaG5pY2FsIGxldmVsIGd1aWRhbmNlXG4gICAgaWYgKHF1ZXJ5QW5hbHlzaXMudGVjaG5pY2FsTGV2ZWwgPj0gNCkge1xuICAgICAgc3lzdGVtUHJvbXB0ICs9IFwiXFxuVXNlIHRlY2huaWNhbCBsYW5ndWFnZSBhbmQgZGV0YWlsZWQgZXhwbGFuYXRpb25zLlwiO1xuICAgIH0gZWxzZSBpZiAocXVlcnlBbmFseXNpcy50ZWNobmljYWxMZXZlbCA8PSAyKSB7XG4gICAgICBzeXN0ZW1Qcm9tcHQgKz0gXCJcXG5Vc2Ugc2ltcGxlIGxhbmd1YWdlIGFuZCBleHBsYWluIGNvbmNlcHRzIGNsZWFybHkuXCI7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgcmVzcG9uc2Ugd2l0aCBPcGVuQUksIHVzaW5nIG91ciBlbmhhbmNlZCBjbGllbnRcbiAgICBjb25zdCB1c2VyTWVzc2FnZSA9IGBDb250ZXh0OlxcbiR7Y29udGV4dH1cXG5cXG5RdWVzdGlvbjogJHtxdWVyeX1gO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2VuZXJhdGVDaGF0Q29tcGxldGlvbihzeXN0ZW1Qcm9tcHQsIHVzZXJNZXNzYWdlLCBBSV9TRVRUSU5HUy5kZWZhdWx0TW9kZWwpO1xuXG4gICAgLy8gUHJlcGFyZSByZXN1bHQgb2JqZWN0XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgYW5zd2VyOiByZXNwb25zZSxcbiAgICAgIHNvdXJjZXM6IGZpbmFsUmVzdWx0cy5tYXAocmVzdWx0ID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0V2l0aFNjb3JlID0gcmVzdWx0IGFzIEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0V2l0aEZpbmFsU2NvcmU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiByZXN1bHQuaXRlbS5tZXRhZGF0YT8uc291cmNlIHx8ICdVbmtub3duJyxcbiAgICAgICAgICBwYWdlOiByZXN1bHQuaXRlbS5tZXRhZGF0YT8ucGFnZSxcbiAgICAgICAgICByZWxldmFuY2U6IChyZXN1bHRXaXRoU2NvcmUuZmluYWxTY29yZSAhPT0gdW5kZWZpbmVkID8gcmVzdWx0V2l0aFNjb3JlLmZpbmFsU2NvcmUgOiByZXN1bHQuY29tYmluZWRTY29yZSkudG9GaXhlZCgyKSxcbiAgICAgICAgICAvLyBJbmNsdWRlIG1vcmUgZGV0YWlsZWQgc2NvcmluZyBpbmZvIGluIGRldmVsb3BtZW50XG4gICAgICAgICAgc2NvcmVzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge1xuICAgICAgICAgICAgYm0yNTogcmVzdWx0LmJtMjVTY29yZSxcbiAgICAgICAgICAgIHZlY3RvcjogcmVzdWx0LnZlY3RvclNjb3JlLFxuICAgICAgICAgICAgY29tYmluZWQ6IHJlc3VsdC5jb21iaW5lZFNjb3JlLFxuICAgICAgICAgICAgYm9vc3Q6IChyZXN1bHQgYXMgYW55KS5ib29zdCxcbiAgICAgICAgICAgIGZpbmFsOiByZXN1bHRXaXRoU2NvcmUuZmluYWxTY29yZVxuICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgcmV0cmlldmFsOiB7XG4gICAgICAgICAgbWV0aG9kOiBzaG91bGRSZXJhbmsgPyAnaHlicmlkX3dpdGhfcmVyYW5raW5nJyA6ICdoeWJyaWRfd2l0aF9ib29zdGluZycsXG4gICAgICAgICAgdG90YWxSZXN1bHRzOiByZXRyaWV2YWxSZXN1bHRzLmxlbmd0aCxcbiAgICAgICAgICByZXR1cm5lZFJlc3VsdHM6IGZpbmFsUmVzdWx0cy5sZW5ndGgsXG4gICAgICAgICAgdXJnZW50OiB1cmdlbnQsXG4gICAgICAgICAgcXVlcnlDb21wbGV4aXR5OiBxdWVyeUFuYWx5c2lzLmNvbXBsZXhpdHksXG4gICAgICAgICAgcXVlcnlFeHBhbnNpb246IGV4cGFuZGVkUXVlcnlSZXN1bHQgPyB7XG4gICAgICAgICAgICBhcHBsaWVkOiBleHBhbmRlZFF1ZXJ5UmVzdWx0LmV4cGFuc2lvblR5cGUgIT09ICdub25lJyxcbiAgICAgICAgICAgIHR5cGU6IGV4cGFuZGVkUXVlcnlSZXN1bHQuZXhwYW5zaW9uVHlwZSxcbiAgICAgICAgICAgIGFkZGVkVGVybXM6IGV4cGFuZGVkUXVlcnlSZXN1bHQuYWRkZWRUZXJtc1xuICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQ2FjaGUgcmVzdWx0IGZvciBub24tdXJnZW50IHF1ZXJpZXMgKDEgaG91ciBUVEwpXG4gICAgaWYgKCF1cmdlbnQpIHtcbiAgICAgIGF3YWl0IGNhY2hlUmVzdWx0KHF1ZXJ5LCByZXN1bHQsIDM2MDApO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgcmVzcG9uc2UgYW5kIHJlbGV2YW50IHNvdXJjZXNcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24ocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBxdWVyeSBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBVc2Ugb3VyIHN0YW5kYXJkaXplZCBlcnJvciByZXNwb25zZVxuICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBzdGFuZGFyZGl6ZUFwaUVycm9yUmVzcG9uc2UoZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbihlcnJvclJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBib29zdCBmYWN0b3IgY2FsY3VsYXRpb24gYmFzZWQgb24gcXVlcnkgYW5hbHlzaXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQm9vc3RGYWN0b3IocXVlcnlBbmFseXNpczogYW55LCBpdGVtOiBWZWN0b3JTdG9yZUl0ZW0pOiBudW1iZXIge1xuICBsZXQgYm9vc3RGYWN0b3IgPSAxLjA7XG4gIFxuICAvLyBDaGVjayBmb3Igc3RydWN0dXJlZCBpbmZvcm1hdGlvbiBhbmQgYm9vc3QgaXRcbiAgaWYgKGl0ZW0ubWV0YWRhdGE/LmlzU3RydWN0dXJlZCkge1xuICAgIGJvb3N0RmFjdG9yICo9IDEuNTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdGV4dCBoYXMgbGlzdCBmb3JtYXQgYW5kIHF1ZXJ5IGV4cGVjdHMgYSBsaXN0LCBib29zdCBpdCBtb3JlXG4gICAgaWYgKHF1ZXJ5QW5hbHlzaXMuZXhwZWN0ZWRGb3JtYXQgPT09ICdsaXN0JyAmJiBcbiAgICAgICAgKGl0ZW0udGV4dC5pbmNsdWRlcygnLSAnKSB8fCBpdGVtLnRleHQuaW5jbHVkZXMoJ+KAoiAnKSkpIHtcbiAgICAgIGJvb3N0RmFjdG9yICo9IDEuMjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciB0ZWNobmljYWwgbGV2ZWwgbWF0Y2hcbiAgY29uc3QgY29udGVudFRlY2hMZXZlbCA9IGVzdGltYXRlQ29udGVudFRlY2hMZXZlbChpdGVtLnRleHQpO1xuICBjb25zdCB0ZWNoTGV2ZWxEaWZmID0gTWF0aC5hYnMoY29udGVudFRlY2hMZXZlbCAtIHF1ZXJ5QW5hbHlzaXMudGVjaG5pY2FsTGV2ZWwpO1xuICBpZiAodGVjaExldmVsRGlmZiA8PSAxKSB7XG4gICAgYm9vc3RGYWN0b3IgKj0gMS4xOyAvLyBCb29zdCBpZiB0ZWNobmljYWwgbGV2ZWxzIGFyZSBhIGdvb2QgbWF0Y2hcbiAgfVxuICBcbiAgLy8gQm9vc3Qgb24gcXVlcnkgdG9waWMgcHJlc2VuY2UgaW4gdGV4dCBcbiAgaWYgKHF1ZXJ5QW5hbHlzaXMudG9waWNzICYmIHF1ZXJ5QW5hbHlzaXMudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBsb3dlclRleHQgPSBpdGVtLnRleHQudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB0b3BpY01hdGNoZXMgPSBxdWVyeUFuYWx5c2lzLnRvcGljcy5maWx0ZXIoXG4gICAgICAodG9waWM6IHN0cmluZykgPT4gbG93ZXJUZXh0LmluY2x1ZGVzKHRvcGljLnRvTG93ZXJDYXNlKCkpXG4gICAgKS5sZW5ndGg7XG4gICAgXG4gICAgaWYgKHRvcGljTWF0Y2hlcyA+IDApIHtcbiAgICAgIGJvb3N0RmFjdG9yICo9IDEuMCArICh0b3BpY01hdGNoZXMgKiAwLjEpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGJvb3N0RmFjdG9yO1xufVxuXG4vKipcbiAqIEVzdGltYXRlIHRlY2huaWNhbCBsZXZlbCBvZiBjb250ZW50IGJhc2VkIG9uIHNpbXBsZSBoZXVyaXN0aWNzXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlQ29udGVudFRlY2hMZXZlbCh0ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBsb3dlclRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIFxuICAvLyBTaW1wbGUgaGV1cmlzdGljcyB0byBlc3RpbWF0ZSB0ZWNobmljYWwgbGV2ZWxcbiAgY29uc3QgdGVjaG5pY2FsVGVybXMgPSBbXG4gICAgJ2FsZ29yaXRobScsICdpbXBsZW1lbnRhdGlvbicsICdhcmNoaXRlY3R1cmUnLCAnaW5mcmFzdHJ1Y3R1cmUnLCBcbiAgICAnY29uZmlndXJhdGlvbicsICdkZXBsb3ltZW50JywgJ2ludGVncmF0aW9uJywgJ3Byb3RvY29sJ1xuICBdO1xuICBcbiAgY29uc3QgYmFzaWNUZXJtcyA9IFtcbiAgICAnc2ltcGxlJywgJ2Vhc3knLCAnc3RyYWlnaHRmb3J3YXJkJywgJ2Jhc2ljJywgJ2p1c3QnLCAnc2ltcGx5J1xuICBdO1xuICBcbiAgY29uc3QgdGVjaFRlcm1Db3VudCA9IHRlY2huaWNhbFRlcm1zLmZpbHRlcih0ZXJtID0+IFxuICAgIGxvd2VyVGV4dC5pbmNsdWRlcyh0ZXJtKVxuICApLmxlbmd0aDtcbiAgXG4gIGNvbnN0IGJhc2ljVGVybUNvdW50ID0gYmFzaWNUZXJtcy5maWx0ZXIodGVybSA9PiBcbiAgICBsb3dlclRleHQuaW5jbHVkZXModGVybSlcbiAgKS5sZW5ndGg7XG4gIFxuICAvLyBDYWxjdWxhdGUgYSBzY29yZSBmcm9tIDEgdG8gNVxuICBsZXQgdGVjaExldmVsID0gMzsgLy8gRGVmYXVsdCBtaWQtbGV2ZWxcbiAgdGVjaExldmVsICs9IHRlY2hUZXJtQ291bnQgKiAwLjU7XG4gIHRlY2hMZXZlbCAtPSBiYXNpY1Rlcm1Db3VudCAqIDAuNTtcbiAgXG4gIC8vIENsYW1wIGJldHdlZW4gMSBhbmQgNVxuICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5taW4oNSwgdGVjaExldmVsKSk7XG59ICJdLCJuYW1lcyI6WyJlbWJlZFRleHQiLCJnZW5lcmF0ZUNoYXRDb21wbGV0aW9uIiwiYW5hbHl6ZVF1ZXJ5Iiwic3RhbmRhcmRpemVBcGlFcnJvclJlc3BvbnNlIiwiQUlfU0VUVElOR1MiLCJFbmhhbmNlZFJldHJpZXZhbCIsInJlcmFua1Jlc3VsdHMiLCJnZXRDYWNoZWRSZXN1bHQiLCJjYWNoZVJlc3VsdCIsImV4cGFuZFF1ZXJ5IiwiZW5oYW5jZWRSZXRyaWV2YWwiLCJibTI1V2VpZ2h0IiwibWluQk0yNVNjb3JlIiwibWluVmVjdG9yU2NvcmUiLCJub3JtYWxpemVTY29yZXMiLCJtYXhSZXN1bHRzIiwiZGVidWciLCJwcm9jZXNzIiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsInN0YXR1cyIsImpzb24iLCJtZXNzYWdlIiwicXVlcnkiLCJ1cmdlbnQiLCJib2R5IiwiY2FjaGVkUmVzdWx0IiwiY29uc29sZSIsImxvZyIsInF1ZXJ5QW5hbHlzaXMiLCJKU09OIiwic3RyaW5naWZ5IiwiZXhwYW5kZWRRdWVyeVJlc3VsdCIsInF1ZXJ5Rm9yUmV0cmlldmFsIiwibWF4RXhwYW5kZWRUZXJtcyIsInVzZVNlbWFudGljRXhwYW5zaW9uIiwiY29tcGxleGl0eSIsInVzZUtleXdvcmRFeHBhbnNpb24iLCJzZW1hbnRpY1dlaWdodCIsInRpbWVvdXRNcyIsImVuYWJsZUNhY2hpbmciLCJleHBhbnNpb25UeXBlIiwiZXhwYW5kZWRRdWVyeSIsImFkZGVkVGVybXMiLCJqb2luIiwicXVlcnlFbWJlZGRpbmciLCJxdWVyeUxvd2VyIiwidG9Mb3dlckNhc2UiLCJpc1ByaWNpbmdRdWVyeSIsIm1hdGNoIiwiaXNQcm9kdWN0RmVhdHVyZXNRdWVyeSIsImlzU2FsZXNRdWVyeSIsInByaW9yaXR5SW5mb1R5cGUiLCJ1bmRlZmluZWQiLCJyZXRyaWV2YWxPcHRpb25zIiwicmV0cmlldmFsUmVzdWx0cyIsImZpbmRTaW1pbGFyRG9jdW1lbnRzIiwibGVuZ3RoIiwic2hvdWxkUmVyYW5rIiwiZmluYWxSZXN1bHRzIiwicmVyYW5rZWRSZXN1bHRzIiwicmV0dXJuVG9wTiIsIm1vZGVsIiwicGFyYWxsZWxCYXRjaGluZyIsIm1hcCIsInJlc3VsdCIsIm9yaWdpbmFsUmVzdWx0IiwiYm9vc3RlZFJlc3VsdHMiLCJib29zdEZhY3RvciIsImNhbGN1bGF0ZUJvb3N0RmFjdG9yIiwiaXRlbSIsImJvb3N0IiwiZmluYWxTY29yZSIsImNvbWJpbmVkU2NvcmUiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsImNvbnRleHQiLCJzb3VyY2VJbmZvIiwibWV0YWRhdGEiLCJzb3VyY2UiLCJwYWdlIiwiYm0yNVNjb3JlIiwidG9GaXhlZCIsInZlY3RvclNjb3JlIiwidGV4dCIsInN5c3RlbVByb21wdCIsImV4cGVjdGVkRm9ybWF0IiwidGVjaG5pY2FsTGV2ZWwiLCJ1c2VyTWVzc2FnZSIsInJlc3BvbnNlIiwiZGVmYXVsdE1vZGVsIiwiYW5zd2VyIiwic291cmNlcyIsInJlc3VsdFdpdGhTY29yZSIsInJlbGV2YW5jZSIsInNjb3JlcyIsImJtMjUiLCJ2ZWN0b3IiLCJjb21iaW5lZCIsImZpbmFsIiwicmV0cmlldmFsIiwidG90YWxSZXN1bHRzIiwicmV0dXJuZWRSZXN1bHRzIiwicXVlcnlDb21wbGV4aXR5IiwicXVlcnlFeHBhbnNpb24iLCJhcHBsaWVkIiwidHlwZSIsImVycm9yIiwiZXJyb3JSZXNwb25zZSIsImlzU3RydWN0dXJlZCIsImluY2x1ZGVzIiwiY29udGVudFRlY2hMZXZlbCIsImVzdGltYXRlQ29udGVudFRlY2hMZXZlbCIsInRlY2hMZXZlbERpZmYiLCJNYXRoIiwiYWJzIiwidG9waWNzIiwibG93ZXJUZXh0IiwidG9waWNNYXRjaGVzIiwiZmlsdGVyIiwidG9waWMiLCJ0ZWNobmljYWxUZXJtcyIsImJhc2ljVGVybXMiLCJ0ZWNoVGVybUNvdW50IiwidGVybSIsImJhc2ljVGVybUNvdW50IiwidGVjaExldmVsIiwibWF4IiwibWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/query.ts\n");

/***/ }),

/***/ "(api)/./utils/advancedDocumentProcessing.ts":
/*!*********************************************!*\
  !*** ./utils/advancedDocumentProcessing.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDocument: () => (/* binding */ analyzeDocument),\n/* harmony export */   analyzeQuery: () => (/* binding */ analyzeQuery),\n/* harmony export */   calculateContentBoost: () => (/* binding */ calculateContentBoost),\n/* harmony export */   createSmartChunkWithMetadata: () => (/* binding */ createSmartChunkWithMetadata),\n/* harmony export */   createSmartChunks: () => (/* binding */ createSmartChunks),\n/* harmony export */   enhanceChunkMetadata: () => (/* binding */ enhanceChunkMetadata),\n/* harmony export */   extractText: () => (/* binding */ extractText),\n/* harmony export */   generateSummaries: () => (/* binding */ generateSummaries),\n/* harmony export */   identifySections: () => (/* binding */ identifySections),\n/* harmony export */   processDocumentWithUnderstanding: () => (/* binding */ processDocumentWithUnderstanding),\n/* harmony export */   processFileWithUnderstanding: () => (/* binding */ processFileWithUnderstanding),\n/* harmony export */   processTextWithUnderstanding: () => (/* binding */ processTextWithUnderstanding),\n/* harmony export */   splitSectionIntoChunks: () => (/* binding */ splitSectionIntoChunks),\n/* harmony export */   splitTextIntoChunks: () => (/* binding */ splitTextIntoChunks),\n/* harmony export */   storeSmartChunks: () => (/* binding */ storeSmartChunks)\n/* harmony export */ });\n/* harmony import */ var _documentProcessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentProcessing */ \"(api)/./utils/documentProcessing.ts\");\n/* harmony import */ var _vectorStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vectorStore */ \"(api)/./utils/vectorStore.ts\");\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! openai */ \"openai\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([openai__WEBPACK_IMPORTED_MODULE_2__]);\nopenai__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Initialize OpenAI API client\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_2__.OpenAI({\n    apiKey: process.env.OPENAI_API_KEY\n});\n/**\n * Use the LLM to analyze the document content\n */ async function analyzeDocument(text) {\n    const analysisPrompt = `\n    Analyze the following document content and provide structured metadata:\n    \n    1. Identify the document title or generate one if not clear\n    2. Identify ALL main topics covered (list of 3-7 topics)\n    3. Extract any key entities:\n       - People mentioned\n       - Products discussed\n       - Features described\n       - Projects referenced\n    4. Identify content type (manual, policy, specs, tutorial, etc.)\n    5. Estimate the technical complexity level (1-5)\n    6. Determine if this contains sensitive/confidential information (true/false)\n    \n    Content: \n    ${text.substring(0, 4000)}\n    \n    Return your analysis as JSON with these fields:\n    {\n      \"title\": \"Document title\",\n      \"topics\": [\"topic1\", \"topic2\", ...],\n      \"entities\": {\n        \"people\": [\"name1\", \"name2\", ...],\n        \"products\": [\"product1\", \"product2\", ...],\n        \"features\": [\"feature1\", \"feature2\", ...],\n        \"projects\": [\"project1\", \"project2\", ...]\n      },\n      \"contentType\": \"manual/policy/specs/etc\",\n      \"technicalLevel\": 1-5,\n      \"containsConfidential\": true/false\n    }\n  `;\n    try {\n        const analysis = await openai.chat.completions.create({\n            model: \"gpt-4\",\n            messages: [\n                {\n                    role: \"user\",\n                    content: analysisPrompt\n                }\n            ]\n        });\n        // Parse and return the analysis\n        const content = analysis.choices[0].message.content || \"{}\";\n        try {\n            return JSON.parse(content);\n        } catch (parseError) {\n            console.warn(\"Failed to parse JSON from analyzeDocument response:\", parseError);\n            // Fallback to basic analysis\n            return {\n                title: extractTitle(content) || \"Untitled Document\",\n                topics: extractTopics(content) || [\n                    \"general\"\n                ],\n                entities: {\n                    people: [],\n                    products: [],\n                    features: [],\n                    projects: []\n                },\n                contentType: extractContentType(content) || \"document\",\n                technicalLevel: extractTechLevel(content) || 3,\n                containsConfidential: false\n            };\n        }\n    } catch (error) {\n        console.error(\"Error analyzing document:\", error);\n        // Return a basic analysis if the LLM analysis fails\n        return {\n            title: \"Untitled Document\",\n            topics: [\n                \"general\"\n            ],\n            entities: {\n                people: [],\n                products: [],\n                features: [],\n                projects: []\n            },\n            contentType: \"document\",\n            technicalLevel: 3,\n            containsConfidential: false\n        };\n    }\n}\n/**\n * Generate multiple layers of document summaries\n */ async function generateSummaries(text, analysis) {\n    const summaryPrompt = `\n    Create the following summaries of this ${analysis.contentType} document:\n    \n    1. One-line summary (15-20 words)\n    2. Paragraph summary (3-5 sentences)\n    3. Detailed summary with section breakdown (300-500 words)\n    4. List of key points (5-10 bullet points)\n    \n    Document:\n    ${text.substring(0, 6000)}\n    \n    Return the summaries in this JSON format:\n    {\n      \"oneLine\": \"One-line summary here\",\n      \"paragraph\": \"Paragraph summary here\",\n      \"detailed\": \"Detailed summary here\",\n      \"keyPoints\": [\"point 1\", \"point 2\", ...]\n    }\n  `;\n    try {\n        const summaryResponse = await openai.chat.completions.create({\n            model: \"gpt-4\",\n            messages: [\n                {\n                    role: \"user\",\n                    content: summaryPrompt\n                }\n            ]\n        });\n        // Parse the summaries from the response\n        const content = summaryResponse.choices[0].message.content || \"{}\";\n        try {\n            return JSON.parse(content);\n        } catch (parseError) {\n            console.warn(\"Failed to parse JSON from generateSummaries response:\", parseError);\n            // Create basic summaries from the response\n            return {\n                oneLine: analysis.title,\n                paragraph: `Document about ${analysis.topics.join(\", \")}.`,\n                detailed: \"No detailed summary available.\",\n                keyPoints: analysis.topics.map((topic)=>`Information about ${topic}`)\n            };\n        }\n    } catch (error) {\n        console.error(\"Error generating summaries:\", error);\n        // Return basic summaries if LLM fails\n        return {\n            oneLine: analysis.title,\n            paragraph: `Document about ${analysis.topics.join(\", \")}.`,\n            detailed: \"No detailed summary available.\",\n            keyPoints: analysis.topics.map((topic)=>`Information about ${topic}`)\n        };\n    }\n}\n/**\n * Identify logical sections within a document\n */ async function identifySections(text) {\n    const sectionPrompt = `\n    Divide the following document into logical sections.\n    For each section, provide:\n    1. A section title\n    2. The section content\n    \n    Document:\n    ${text.substring(0, 8000)}\n    \n    Return the sections in this JSON format:\n    [\n      {\n        \"title\": \"Section title\",\n        \"text\": \"Section content\"\n      },\n      ...\n    ]\n  `;\n    try {\n        const sectionsResponse = await openai.chat.completions.create({\n            model: \"gpt-4\",\n            messages: [\n                {\n                    role: \"user\",\n                    content: sectionPrompt\n                }\n            ]\n        });\n        // Parse the sections from the response\n        const content = sectionsResponse.choices[0].message.content || \"{}\";\n        try {\n            const parsed = JSON.parse(content);\n            // Make sure we have an array of sections\n            if (Array.isArray(parsed)) {\n                return parsed;\n            } else if (parsed.sections && Array.isArray(parsed.sections)) {\n                return parsed.sections;\n            }\n        } catch (parseError) {\n            console.warn(\"Failed to parse JSON from identifySections response:\", parseError);\n        }\n        // If we couldn't parse correctly, return the whole text as one section\n        return [\n            {\n                title: \"Document Content\",\n                text: text\n            }\n        ];\n    } catch (error) {\n        console.error(\"Error identifying sections:\", error);\n        // Return the whole text as one section if LLM fails\n        return [\n            {\n                title: \"Document Content\",\n                text: text\n            }\n        ];\n    }\n}\n/**\n * Split section into smaller chunks for embedding\n */ function splitSectionIntoChunks(sectionText, chunkSize = 500) {\n    const chunks = [];\n    if (sectionText.length <= chunkSize) {\n        return [\n            sectionText\n        ];\n    }\n    let currentIndex = 0;\n    while(currentIndex < sectionText.length){\n        // Get a chunk of approximately the target size\n        let chunk = sectionText.substring(currentIndex, currentIndex + chunkSize);\n        // If we're not at the end of the text, try to break at a natural boundary\n        if (currentIndex + chunkSize < sectionText.length) {\n            // Look for paragraph breaks first (ideal breaking point)\n            const paragraphBreak = chunk.lastIndexOf(\"\\n\\n\");\n            // Then look for the last sentence break in this chunk\n            const sentenceBreaks = [\n                chunk.lastIndexOf(\". \"),\n                chunk.lastIndexOf(\"? \"),\n                chunk.lastIndexOf(\"! \"),\n                chunk.lastIndexOf(\".\\n\"),\n                chunk.lastIndexOf(\"?\\n\"),\n                chunk.lastIndexOf(\"!\\n\")\n            ];\n            const lastSentenceBreak = Math.max(...sentenceBreaks);\n            // Use paragraph break if available and reasonable, otherwise use sentence break\n            if (paragraphBreak > chunkSize * 0.5) {\n                chunk = chunk.substring(0, paragraphBreak);\n            } else if (lastSentenceBreak > chunkSize * 0.3) {\n                // If the sentence break is at least 30% through the chunk\n                const breakType = sentenceBreaks.indexOf(lastSentenceBreak);\n                // Add 2 to include the period and space/newline\n                chunk = chunk.substring(0, lastSentenceBreak + (breakType >= 3 ? 2 : 2));\n            }\n        }\n        chunks.push(chunk.trim());\n        currentIndex += chunk.length;\n        // Add slight overlap for context if needed\n        if (currentIndex < sectionText.length) {\n            // Find the last complete sentence for overlap\n            const lastSentenceMatch = chunk.match(/[^.!?]+[.!?]+\\s*$/);\n            const lastSentence = lastSentenceMatch ? lastSentenceMatch[0] : \"\";\n            if (lastSentence && lastSentence.length < chunkSize * 0.2) {\n                currentIndex -= lastSentence.length;\n            }\n        }\n    }\n    return chunks;\n}\n/**\n * Create smart chunks that maintain document structure\n */ async function createSmartChunks(text, analysis, summaries, sections) {\n    const chunks = [];\n    // Create a chunk for the overall document\n    chunks.push({\n        text: summaries.paragraph,\n        metadata: {\n            source: analysis.title,\n            chunkType: \"document_summary\",\n            topics: analysis.topics,\n            contentType: analysis.contentType,\n            technicalLevel: analysis.technicalLevel\n        }\n    });\n    // Process each section into chunks\n    for (const section of sections){\n        // Generate a summary for this section\n        let sectionSummary = \"\";\n        try {\n            const sectionSummaryPrompt = `\n        Summarize this section in 1-2 sentences:\n        \n        Section Title: ${section.title}\n        Content: ${section.text.substring(0, 2000)}\n      `;\n            const summaryResponse = await openai.chat.completions.create({\n                model: \"gpt-4\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: sectionSummaryPrompt\n                    }\n                ]\n            });\n            sectionSummary = summaryResponse.choices[0].message.content || \"\";\n        } catch (error) {\n            console.warn(`Error generating summary for section \"${section.title}\":`, error);\n            sectionSummary = `Section about ${section.title}`;\n        }\n        // Add a chunk for the section summary\n        chunks.push({\n            text: sectionSummary,\n            metadata: {\n                source: `${analysis.title} - ${section.title}`,\n                chunkType: \"section_summary\",\n                topics: analysis.topics,\n                contentType: analysis.contentType,\n                technicalLevel: analysis.technicalLevel\n            }\n        });\n        // Split the section content into smaller chunks\n        const contentChunks = splitSectionIntoChunks(section.text, 1000);\n        for(let i = 0; i < contentChunks.length; i++){\n            chunks.push({\n                text: contentChunks[i],\n                metadata: {\n                    source: `${analysis.title} - ${section.title} (Part ${i + 1}/${contentChunks.length})`,\n                    chunkType: \"section_content\",\n                    topics: analysis.topics,\n                    contentType: analysis.contentType,\n                    technicalLevel: analysis.technicalLevel,\n                    sectionTitle: section.title\n                }\n            });\n        }\n    }\n    return chunks;\n}\n/**\n * Enhance chunks with rich metadata\n */ function enhanceChunkMetadata(chunk, analysis, source, page) {\n    const now = new Date().toISOString();\n    return {\n        text: chunk.text,\n        embedding: chunk.embedding || [],\n        metadata: {\n            source,\n            section: chunk.metadata?.sectionTitle,\n            page,\n            topics: analysis.topics,\n            contentType: analysis.contentType,\n            technicalLevel: analysis.technicalLevel,\n            confidentiality: analysis.containsConfidential ? \"confidential\" : \"public\",\n            relatedProducts: analysis.entities.products,\n            relatedProjects: analysis.entities.projects,\n            lastUpdated: now,\n            documentSummary: \"\",\n            sectionSummary: \"\" // Removed reference to nonexistent property\n        }\n    };\n}\n/**\n * Main function to process new document with advanced understanding\n */ async function processDocumentWithUnderstanding(filePath, mimetype, filename) {\n    try {\n        // 1. Extract text from document\n        const text = await (0,_documentProcessing__WEBPACK_IMPORTED_MODULE_0__.extractText)(filePath, mimetype);\n        // 2. Get LLM to analyze the full document\n        const documentAnalysis = await analyzeDocument(text);\n        // 3. Generate multiple document summaries\n        const summaries = await generateSummaries(text, documentAnalysis);\n        // 4. Create smart chunks with nested context\n        const smartChunks = await createSmartChunks(text, documentAnalysis, summaries, await identifySections(text));\n        // 5. Enhance each chunk with rich metadata\n        const enhancedChunks = smartChunks.map((chunk)=>enhanceChunkMetadata(chunk, documentAnalysis, filename));\n        // 6. Generate embeddings for all chunks and add to vector store\n        for (const chunk of enhancedChunks){\n            chunk.embedding = await embedText(chunk.text);\n            (0,_vectorStore__WEBPACK_IMPORTED_MODULE_1__.addToVectorStore)(chunk);\n        }\n        return {\n            analysis: documentAnalysis,\n            chunkCount: enhancedChunks.length\n        };\n    } catch (error) {\n        console.error(\"Error processing document with understanding:\", error);\n        throw new Error(`Failed to process document: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n/**\n * Analyze a query to determine its characteristics\n * This helps in optimizing retrieval and answer generation\n */ async function analyzeQuery(query) {\n    const lowerQuery = query.toLowerCase();\n    // Simple rule-based analysis\n    // In a production system, this would be more sophisticated\n    // and potentially use ML models for classification\n    // Determine technical level\n    const technicalTerms = [\n        \"algorithm\",\n        \"architecture\",\n        \"implementation\",\n        \"infrastructure\",\n        \"backend\",\n        \"frontend\",\n        \"api\",\n        \"endpoint\",\n        \"protocol\",\n        \"encryption\",\n        \"schema\",\n        \"database\",\n        \"integration\"\n    ];\n    // Count technical terms\n    const technicalTermCount = technicalTerms.filter((term)=>lowerQuery.includes(term)).length;\n    let technicalLevel = 3; // Default mid-level\n    technicalLevel += technicalTermCount * 0.5;\n    // Check for simple language that would indicate lower technical level\n    if (lowerQuery.includes(\"simple\") || lowerQuery.includes(\"easy\") || lowerQuery.includes(\"basics\")) {\n        technicalLevel -= 1;\n    }\n    // Determine expected response format\n    let expectedFormat = \"text\";\n    if (lowerQuery.includes(\"step\") || lowerQuery.includes(\"guide\") || lowerQuery.includes(\"how to\")) {\n        expectedFormat = \"steps\";\n    } else if (lowerQuery.includes(\"list\") || lowerQuery.match(/what are( the)? (different|various|main|key)/)) {\n        expectedFormat = \"list\";\n    } else if (lowerQuery.includes(\"table\") || lowerQuery.includes(\"compare\") || lowerQuery.includes(\"comparison\")) {\n        expectedFormat = \"table\";\n    }\n    // Determine complexity\n    const complexWords = [\n        \"differences\",\n        \"between\",\n        \"compare\",\n        \"explain\",\n        \"why\",\n        \"how\",\n        \"technical\",\n        \"architecture\",\n        \"detail\",\n        \"versus\"\n    ];\n    const complexWordCount = complexWords.filter((word)=>lowerQuery.includes(word)).length;\n    let complexity = 2; // Default slightly below mid-level\n    complexity += complexWordCount * 0.5;\n    // Simple topic extraction\n    // This is a placeholder for more sophisticated NER/topic modeling\n    const potentialTopics = [\n        \"pricing\",\n        \"features\",\n        \"security\",\n        \"integration\",\n        \"api\",\n        \"comparison\",\n        \"implementation\",\n        \"enterprise\",\n        \"support\",\n        \"demo\",\n        \"trial\",\n        \"contract\",\n        \"discount\",\n        \"competitors\"\n    ];\n    const topics = potentialTopics.filter((topic)=>lowerQuery.includes(topic));\n    // Determine urgency\n    let urgency = 1; // Default low urgency\n    if (lowerQuery.includes(\"urgent\") || lowerQuery.includes(\"asap\") || lowerQuery.includes(\"immediately\")) {\n        urgency = 5;\n    } else if (lowerQuery.includes(\"soon\") || lowerQuery.includes(\"quickly\")) {\n        urgency = 3;\n    }\n    // Normalize scores to intended ranges\n    technicalLevel = Math.max(1, Math.min(5, technicalLevel));\n    complexity = Math.max(1, Math.min(5, complexity));\n    return {\n        technicalLevel,\n        expectedFormat,\n        complexity,\n        topics,\n        urgency\n    };\n}\n// Helper functions to extract information from non-JSON responses\nfunction extractTitle(text) {\n    const titleMatch = text.match(/title:.*?[\"'](.+?)[\"']/i);\n    return titleMatch ? titleMatch[1] : null;\n}\nfunction extractTopics(text) {\n    const topicsMatch = text.match(/topics:.*?\\[(.*?)\\]/i);\n    if (topicsMatch && topicsMatch[1]) {\n        return topicsMatch[1].split(\",\").map((t)=>t.trim().replace(/[\"']/g, \"\"));\n    }\n    return null;\n}\nfunction extractContentType(text) {\n    const typeMatch = text.match(/contentType:.*?[\"'](.+?)[\"']/i);\n    return typeMatch ? typeMatch[1].toLowerCase() : null;\n}\nfunction extractFormat(text) {\n    const formatMatch = text.match(/expectedFormat:.*?[\"']?(list|explanation|steps|step-by-step|comparison|summary|detailed)[\"']?/i);\n    return formatMatch ? formatMatch[1].toLowerCase() : null;\n}\nfunction extractTechLevel(text) {\n    const levelMatch = text.match(/technicalLevel:.*?([1-5])/i);\n    return levelMatch ? parseInt(levelMatch[1]) : null;\n}\n/**\n * Calculate content-based relevance boost factors\n */ function calculateContentBoost(queryAnalysis, chunk) {\n    let boostFactor = 1.0;\n    // Topic overlap\n    const topicOverlap = queryAnalysis.topics.filter((topic)=>chunk.metadata.topics.includes(topic)).length;\n    if (topicOverlap > 0) {\n        boostFactor *= 1.0 + topicOverlap / queryAnalysis.topics.length;\n    }\n    // Technical level match\n    const techLevelDifference = Math.abs(queryAnalysis.technicalLevel - chunk.metadata.technicalLevel);\n    if (techLevelDifference <= 1) {\n        boostFactor *= 1.2; // Boost if technical levels are a good match\n    }\n    // Structured content match\n    if (queryAnalysis.expectedFormat === \"list\" && chunk.text.includes(\"- \")) {\n        boostFactor *= 1.3; // Boost list-like content for list queries\n    }\n    if (queryAnalysis.expectedFormat === \"steps\" && (chunk.text.includes(\"Step \") || chunk.text.includes(\". \"))) {\n        boostFactor *= 1.3; // Boost step-like content for steps queries\n    }\n    // Recency boost\n    const lastUpdated = new Date(chunk.metadata.lastUpdated).getTime();\n    const now = new Date().getTime();\n    const daysSinceUpdate = (now - lastUpdated) / (1000 * 60 * 60 * 24);\n    if (daysSinceUpdate < 30) {\n        boostFactor *= 1.1; // Slight boost for recent content\n    }\n    return boostFactor;\n}\n/**\n * Process a file with full AI understanding\n */ async function processFileWithUnderstanding(file, useDefaultTitle = false) {\n    try {\n        // Extract text from the file\n        const text = await extractText(file);\n        // Process the extracted text\n        return await processTextWithUnderstanding(text, file.originalname, useDefaultTitle);\n    } catch (error) {\n        console.error(\"Error processing file with understanding:\", error);\n        throw error;\n    }\n}\n/**\n * Process text content with full AI understanding\n */ async function processTextWithUnderstanding(text, originalTitle, useDefaultTitle = false) {\n    try {\n        // Analyze the document to extract metadata\n        const analysis = await analyzeDocument(text);\n        // Use the provided title if available and requested\n        if (useDefaultTitle && originalTitle) {\n            analysis.title = originalTitle;\n        }\n        // Make sure we have a safe title for file operations\n        const safeTitle = (analysis.title || originalTitle || \"document\").replace(/[^a-zA-Z0-9-_]/g, \"_\");\n        // Generate summaries\n        const summaries = await generateSummaries(text, analysis);\n        // Identify sections in the document\n        const sections = await identifySections(text);\n        // Create smart chunks that preserve document structure\n        const chunks = await createSmartChunks(text, analysis, summaries, sections);\n        // Store the chunks in the vector store\n        const embeddings = await storeSmartChunks(chunks);\n        return {\n            title: analysis.title || \"Untitled Document\",\n            topics: analysis.topics,\n            contentType: analysis.contentType,\n            summaries,\n            chunks: chunks.length,\n            sections: sections.map((s)=>s.title)\n        };\n    } catch (error) {\n        console.error(\"Error processing text with understanding:\", error);\n        throw error;\n    }\n}\n/**\n * Extract text from a file\n */ async function extractText(file) {\n    // For simplicity, we're just returning the file buffer as text\n    // In a real implementation, you would use libraries like pdf-parse, docx, etc.\n    return file.buffer.toString(\"utf-8\");\n}\n/**\n * Store smart chunks in the vector store\n */ async function storeSmartChunks(chunks) {\n    let storedCount = 0;\n    for (const chunk of chunks){\n        try {\n            // Generate embedding for the chunk text\n            const embedding = await embedText(chunk.text);\n            // Store in vector database\n            (0,_vectorStore__WEBPACK_IMPORTED_MODULE_1__.addToVectorStore)({\n                text: chunk.text,\n                metadata: chunk.metadata,\n                embedding\n            });\n            storedCount++;\n        } catch (error) {\n            console.error(\"Error storing chunk:\", error);\n        }\n    }\n    return storedCount;\n}\n/**\n * Generate embedding for text\n */ async function embedText(text) {\n    try {\n        const response = await openai.embeddings.create({\n            model: \"text-embedding-ada-002\",\n            input: text\n        });\n        return response.data[0].embedding;\n    } catch (error) {\n        console.error(\"Error generating embedding:\", error);\n        // Return a dummy embedding for error cases\n        return Array(1536).fill(0);\n    }\n}\n/**\n * Helper function to split text into chunks\n */ function splitTextIntoChunks(text, maxChunkSize = 1000) {\n    // Implement text splitting logic that preserves paragraphs and sentence boundaries\n    const chunks = [];\n    // Simple implementation for now - split by paragraphs then recombine to stay under maxChunkSize\n    const paragraphs = text.split(/\\n\\s*\\n/);\n    let currentChunk = \"\";\n    for (const paragraph of paragraphs){\n        if (currentChunk.length + paragraph.length > maxChunkSize && currentChunk.length > 0) {\n            chunks.push(currentChunk);\n            currentChunk = paragraph;\n        } else {\n            currentChunk += (currentChunk ? \"\\n\\n\" : \"\") + paragraph;\n        }\n    }\n    if (currentChunk) {\n        chunks.push(currentChunk);\n    }\n    return chunks;\n}\n/**\n * Create a smart chunk with metadata\n */ function createSmartChunkWithMetadata(text, section, analysis, partIndex, totalParts) {\n    return {\n        text,\n        metadata: {\n            source: `${analysis.title} - ${section.title} (Part ${partIndex}/${totalParts})`,\n            chunkType: \"section_content\",\n            topics: analysis.topics,\n            contentType: analysis.contentType,\n            technicalLevel: analysis.technicalLevel,\n            sectionTitle: section.title\n        }\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9hZHZhbmNlZERvY3VtZW50UHJvY2Vzc2luZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHc0U7QUFDSjtBQUNsQztBQXFCaEMsK0JBQStCO0FBQy9CLE1BQU1JLFNBQVMsSUFBSUQsMENBQU1BLENBQUM7SUFDeEJFLFFBQVFDLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztBQUNwQztBQXlGQTs7Q0FFQyxHQUNNLGVBQWVDLGdCQUFnQkMsSUFBWTtJQUNoRCxNQUFNQyxpQkFBaUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0lBZXRCLEVBQUVELEtBQUtFLFNBQVMsQ0FBQyxHQUFHLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7RUFnQjVCLENBQUM7SUFFRCxJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNVCxPQUFPVSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDO1lBQ3BEQyxPQUFPO1lBQ1BDLFVBQVU7Z0JBQUM7b0JBQUVDLE1BQU07b0JBQVFDLFNBQVNUO2dCQUFlO2FBQUU7UUFDdkQ7UUFFQSxnQ0FBZ0M7UUFDaEMsTUFBTVMsVUFBVVAsU0FBU1EsT0FBTyxDQUFDLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDRixPQUFPLElBQUk7UUFDdkQsSUFBSTtZQUNGLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0o7UUFDcEIsRUFBRSxPQUFPSyxZQUFZO1lBQ25CQyxRQUFRQyxJQUFJLENBQUMsdURBQXVERjtZQUNwRSw2QkFBNkI7WUFDN0IsT0FBTztnQkFDTEcsT0FBT0MsYUFBYVQsWUFBWTtnQkFDaENVLFFBQVFDLGNBQWNYLFlBQVk7b0JBQUM7aUJBQVU7Z0JBQzdDWSxVQUFVO29CQUNSQyxRQUFRLEVBQUU7b0JBQ1ZDLFVBQVUsRUFBRTtvQkFDWkMsVUFBVSxFQUFFO29CQUNaQyxVQUFVLEVBQUU7Z0JBQ2Q7Z0JBQ0FDLGFBQWFDLG1CQUFtQmxCLFlBQVk7Z0JBQzVDbUIsZ0JBQWdCQyxpQkFBaUJwQixZQUFZO2dCQUM3Q3FCLHNC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RnZGLFdBQVc7WUFDWHRELFFBQVFqQixTQUFTaUIsTUFBTTtZQUN2Qk8sYUFBYXhCLFNBQVN3QixXQUFXO1lBQ2pDRSxnQkFBZ0IxQixTQUFTMEIsY0FBYztZQUN2Q21ELGNBQWNMLFFBQVF6RCxLQUFLO1FBQzdCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWNoYXQtb3BlbmFpLXJhZy8uL3V0aWxzL2FkdmFuY2VkRG9jdW1lbnRQcm9jZXNzaW5nLnRzPzVmNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3BlbmFpIGFzIG9wZW5haUNsaWVudCB9IGZyb20gJy4vb3BlbmFpQ2xpZW50JztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGV4dHJhY3RUZXh0IGFzIGJhc2VFeHRyYWN0VGV4dCB9IGZyb20gJy4vZG9jdW1lbnRQcm9jZXNzaW5nJztcbmltcG9ydCB7IGFkZFRvVmVjdG9yU3RvcmUsIFZlY3RvclN0b3JlSXRlbSB9IGZyb20gJy4vdmVjdG9yU3RvcmUnO1xuaW1wb3J0IHsgT3BlbkFJIH0gZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IGdlbmVyYXRlU3RydWN0dXJlZFJlc3BvbnNlIH0gZnJvbSAnLi9vcGVuYWlDbGllbnQnO1xuaW1wb3J0IHsgQUlfU0VUVElOR1MgfSBmcm9tICcuL21vZGVsQ29uZmlnJztcblxuLy8gRGVmaW5lIHByb3BlciB0eXBlIGZvciBFeHByZXNzLk11bHRlci5GaWxlXG5kZWNsYXJlIG5hbWVzcGFjZSBFeHByZXNzIHtcbiAgbmFtZXNwYWNlIE11bHRlciB7XG4gICAgaW50ZXJmYWNlIEZpbGUge1xuICAgICAgZmllbGRuYW1lOiBzdHJpbmc7XG4gICAgICBvcmlnaW5hbG5hbWU6IHN0cmluZztcbiAgICAgIGVuY29kaW5nOiBzdHJpbmc7XG4gICAgICBtaW1ldHlwZTogc3RyaW5nO1xuICAgICAgc2l6ZTogbnVtYmVyO1xuICAgICAgZGVzdGluYXRpb246IHN0cmluZztcbiAgICAgIGZpbGVuYW1lOiBzdHJpbmc7XG4gICAgICBwYXRoOiBzdHJpbmc7XG4gICAgICBidWZmZXI6IEJ1ZmZlcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gSW5pdGlhbGl6ZSBPcGVuQUkgQVBJIGNsaWVudFxuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVksXG59KTtcblxuLyoqXG4gKiBEb2N1bWVudCBhbmFseXNpcyByZXN1bHQgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRBbmFseXNpcyB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHRvcGljczogc3RyaW5nW107XG4gIGVudGl0aWVzOiB7XG4gICAgcGVvcGxlOiBzdHJpbmdbXTtcbiAgICBwcm9kdWN0czogc3RyaW5nW107XG4gICAgZmVhdHVyZXM6IHN0cmluZ1tdO1xuICAgIHByb2plY3RzOiBzdHJpbmdbXTtcbiAgfTtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgdGVjaG5pY2FsTGV2ZWw6IG51bWJlcjtcbiAgY29udGFpbnNDb25maWRlbnRpYWw6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRG9jdW1lbnQgc3VtbWFyaWVzIGF0IHZhcmlvdXMgZGV0YWlsIGxldmVsc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50U3VtbWFyaWVzIHtcbiAgb25lTGluZTogc3RyaW5nO1xuICBwYXJhZ3JhcGg6IHN0cmluZztcbiAgZGV0YWlsZWQ6IHN0cmluZztcbiAga2V5UG9pbnRzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBTbWFydCBkb2N1bWVudCBjaHVuayB3aXRoIG5lc3RlZCBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU21hcnRDaHVuayB7XG4gIHRleHQ6IHN0cmluZztcbiAgbWV0YWRhdGE6IHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICBjaHVua1R5cGU6IHN0cmluZztcbiAgICB0b3BpY3M6IHN0cmluZ1tdO1xuICAgIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gICAgdGVjaG5pY2FsTGV2ZWw6IG51bWJlcjtcbiAgICBzZWN0aW9uVGl0bGU/OiBzdHJpbmc7XG4gIH07XG4gIGVtYmVkZGluZz86IG51bWJlcltdO1xufVxuXG4vKipcbiAqIFNlY3Rpb24gb2YgYSBkb2N1bWVudCB3aXRoIHRpdGxlIGFuZCBjb250ZW50XG4gKi9cbmludGVyZmFjZSBEb2N1bWVudFNlY3Rpb24ge1xuICB0aXRsZTogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIHN1bW1hcnk/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogRW5oYW5jZWQgdmVjdG9yIHN0b3JlIGl0ZW0gd2l0aCByaWNoIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZWRWZWN0b3JJdGVtIGV4dGVuZHMgVmVjdG9yU3RvcmVJdGVtIHtcbiAgbWV0YWRhdGE6IHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICBzZWN0aW9uPzogc3RyaW5nO1xuICAgIHBhZ2U/OiBudW1iZXI7XG4gICAgdG9waWNzOiBzdHJpbmdbXTtcbiAgICBjb250ZW50VHlwZTogc3RyaW5nO1xuICAgIHRlY2huaWNhbExldmVsOiBudW1iZXI7XG4gICAgY29uZmlkZW50aWFsaXR5OiBzdHJpbmc7XG4gICAgcmVsYXRlZFByb2R1Y3RzOiBzdHJpbmdbXTtcbiAgICByZWxhdGVkUHJvamVjdHM6IHN0cmluZ1tdO1xuICAgIGxhc3RVcGRhdGVkOiBzdHJpbmc7XG4gICAgdmVyc2lvbj86IHN0cmluZztcbiAgICBkb2N1bWVudFN1bW1hcnk6IHN0cmluZztcbiAgICBzZWN0aW9uU3VtbWFyeT86IHN0cmluZztcbiAgICBwcmVjZWRpbmdDb250ZXh0Pzogc3RyaW5nO1xuICAgIGZvbGxvd2luZ0NvbnRleHQ/OiBzdHJpbmc7XG4gIH07XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgcHJvY2Vzc2luZyByZXN1bHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzaW5nUmVzdWx0IHtcbiAgdGl0bGU6IHN0cmluZztcbiAgdG9waWNzOiBzdHJpbmdbXTtcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgc3VtbWFyaWVzOiBEb2N1bWVudFN1bW1hcmllcztcbiAgY2h1bmtzOiBudW1iZXI7XG4gIHNlY3Rpb25zOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBVc2UgdGhlIExMTSB0byBhbmFseXplIHRoZSBkb2N1bWVudCBjb250ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhbmFseXplRG9jdW1lbnQodGV4dDogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudEFuYWx5c2lzPiB7XG4gIGNvbnN0IGFuYWx5c2lzUHJvbXB0ID0gYFxuICAgIEFuYWx5emUgdGhlIGZvbGxvd2luZyBkb2N1bWVudCBjb250ZW50IGFuZCBwcm92aWRlIHN0cnVjdHVyZWQgbWV0YWRhdGE6XG4gICAgXG4gICAgMS4gSWRlbnRpZnkgdGhlIGRvY3VtZW50IHRpdGxlIG9yIGdlbmVyYXRlIG9uZSBpZiBub3QgY2xlYXJcbiAgICAyLiBJZGVudGlmeSBBTEwgbWFpbiB0b3BpY3MgY292ZXJlZCAobGlzdCBvZiAzLTcgdG9waWNzKVxuICAgIDMuIEV4dHJhY3QgYW55IGtleSBlbnRpdGllczpcbiAgICAgICAtIFBlb3BsZSBtZW50aW9uZWRcbiAgICAgICAtIFByb2R1Y3RzIGRpc2N1c3NlZFxuICAgICAgIC0gRmVhdHVyZXMgZGVzY3JpYmVkXG4gICAgICAgLSBQcm9qZWN0cyByZWZlcmVuY2VkXG4gICAgNC4gSWRlbnRpZnkgY29udGVudCB0eXBlIChtYW51YWwsIHBvbGljeSwgc3BlY3MsIHR1dG9yaWFsLCBldGMuKVxuICAgIDUuIEVzdGltYXRlIHRoZSB0ZWNobmljYWwgY29tcGxleGl0eSBsZXZlbCAoMS01KVxuICAgIDYuIERldGVybWluZSBpZiB0aGlzIGNvbnRhaW5zIHNlbnNpdGl2ZS9jb25maWRlbnRpYWwgaW5mb3JtYXRpb24gKHRydWUvZmFsc2UpXG4gICAgXG4gICAgQ29udGVudDogXG4gICAgJHt0ZXh0LnN1YnN0cmluZygwLCA0MDAwKX1cbiAgICBcbiAgICBSZXR1cm4geW91ciBhbmFseXNpcyBhcyBKU09OIHdpdGggdGhlc2UgZmllbGRzOlxuICAgIHtcbiAgICAgIFwidGl0bGVcIjogXCJEb2N1bWVudCB0aXRsZVwiLFxuICAgICAgXCJ0b3BpY3NcIjogW1widG9waWMxXCIsIFwidG9waWMyXCIsIC4uLl0sXG4gICAgICBcImVudGl0aWVzXCI6IHtcbiAgICAgICAgXCJwZW9wbGVcIjogW1wibmFtZTFcIiwgXCJuYW1lMlwiLCAuLi5dLFxuICAgICAgICBcInByb2R1Y3RzXCI6IFtcInByb2R1Y3QxXCIsIFwicHJvZHVjdDJcIiwgLi4uXSxcbiAgICAgICAgXCJmZWF0dXJlc1wiOiBbXCJmZWF0dXJlMVwiLCBcImZlYXR1cmUyXCIsIC4uLl0sXG4gICAgICAgIFwicHJvamVjdHNcIjogW1wicHJvamVjdDFcIiwgXCJwcm9qZWN0MlwiLCAuLi5dXG4gICAgICB9LFxuICAgICAgXCJjb250ZW50VHlwZVwiOiBcIm1hbnVhbC9wb2xpY3kvc3BlY3MvZXRjXCIsXG4gICAgICBcInRlY2huaWNhbExldmVsXCI6IDEtNSxcbiAgICAgIFwiY29udGFpbnNDb25maWRlbnRpYWxcIjogdHJ1ZS9mYWxzZVxuICAgIH1cbiAgYDtcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6ICdncHQtNCcsXG4gICAgICBtZXNzYWdlczogW3sgcm9sZTogJ3VzZXInLCBjb250ZW50OiBhbmFseXNpc1Byb21wdCB9XVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFBhcnNlIGFuZCByZXR1cm4gdGhlIGFuYWx5c2lzXG4gICAgY29uc3QgY29udGVudCA9IGFuYWx5c2lzLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50IHx8ICd7fSc7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBwYXJzZSBKU09OIGZyb20gYW5hbHl6ZURvY3VtZW50IHJlc3BvbnNlOlwiLCBwYXJzZUVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGJhc2ljIGFuYWx5c2lzXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogZXh0cmFjdFRpdGxlKGNvbnRlbnQpIHx8ICdVbnRpdGxlZCBEb2N1bWVudCcsXG4gICAgICAgIHRvcGljczogZXh0cmFjdFRvcGljcyhjb250ZW50KSB8fCBbJ2dlbmVyYWwnXSxcbiAgICAgICAgZW50aXRpZXM6IHtcbiAgICAgICAgICBwZW9wbGU6IFtdLFxuICAgICAgICAgIHByb2R1Y3RzOiBbXSxcbiAgICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgICAgcHJvamVjdHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRUeXBlOiBleHRyYWN0Q29udGVudFR5cGUoY29udGVudCkgfHwgJ2RvY3VtZW50JyxcbiAgICAgICAgdGVjaG5pY2FsTGV2ZWw6IGV4dHJhY3RUZWNoTGV2ZWwoY29udGVudCkgfHwgMyxcbiAgICAgICAgY29udGFpbnNDb25maWRlbnRpYWw6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbmFseXppbmcgZG9jdW1lbnQ6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFJldHVybiBhIGJhc2ljIGFuYWx5c2lzIGlmIHRoZSBMTE0gYW5hbHlzaXMgZmFpbHNcbiAgICByZXR1cm4ge1xuICAgICAgdGl0bGU6ICdVbnRpdGxlZCBEb2N1bWVudCcsXG4gICAgICB0b3BpY3M6IFsnZ2VuZXJhbCddLFxuICAgICAgZW50aXRpZXM6IHtcbiAgICAgICAgcGVvcGxlOiBbXSxcbiAgICAgICAgcHJvZHVjdHM6IFtdLFxuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIHByb2plY3RzOiBbXVxuICAgICAgfSxcbiAgICAgIGNvbnRlbnRUeXBlOiAnZG9jdW1lbnQnLFxuICAgICAgdGVjaG5pY2FsTGV2ZWw6IDMsXG4gICAgICBjb250YWluc0NvbmZpZGVudGlhbDogZmFsc2VcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgbXVsdGlwbGUgbGF5ZXJzIG9mIGRvY3VtZW50IHN1bW1hcmllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTdW1tYXJpZXModGV4dDogc3RyaW5nLCBhbmFseXNpczogRG9jdW1lbnRBbmFseXNpcyk6IFByb21pc2U8RG9jdW1lbnRTdW1tYXJpZXM+IHtcbiAgY29uc3Qgc3VtbWFyeVByb21wdCA9IGBcbiAgICBDcmVhdGUgdGhlIGZvbGxvd2luZyBzdW1tYXJpZXMgb2YgdGhpcyAke2FuYWx5c2lzLmNvbnRlbnRUeXBlfSBkb2N1bWVudDpcbiAgICBcbiAgICAxLiBPbmUtbGluZSBzdW1tYXJ5ICgxNS0yMCB3b3JkcylcbiAgICAyLiBQYXJhZ3JhcGggc3VtbWFyeSAoMy01IHNlbnRlbmNlcylcbiAgICAzLiBEZXRhaWxlZCBzdW1tYXJ5IHdpdGggc2VjdGlvbiBicmVha2Rvd24gKDMwMC01MDAgd29yZHMpXG4gICAgNC4gTGlzdCBvZiBrZXkgcG9pbnRzICg1LTEwIGJ1bGxldCBwb2ludHMpXG4gICAgXG4gICAgRG9jdW1lbnQ6XG4gICAgJHt0ZXh0LnN1YnN0cmluZygwLCA2MDAwKX1cbiAgICBcbiAgICBSZXR1cm4gdGhlIHN1bW1hcmllcyBpbiB0aGlzIEpTT04gZm9ybWF0OlxuICAgIHtcbiAgICAgIFwib25lTGluZVwiOiBcIk9uZS1saW5lIHN1bW1hcnkgaGVyZVwiLFxuICAgICAgXCJwYXJhZ3JhcGhcIjogXCJQYXJhZ3JhcGggc3VtbWFyeSBoZXJlXCIsXG4gICAgICBcImRldGFpbGVkXCI6IFwiRGV0YWlsZWQgc3VtbWFyeSBoZXJlXCIsXG4gICAgICBcImtleVBvaW50c1wiOiBbXCJwb2ludCAxXCIsIFwicG9pbnQgMlwiLCAuLi5dXG4gICAgfVxuICBgO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBzdW1tYXJ5UmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6ICdncHQtNCcsXG4gICAgICBtZXNzYWdlczogW3sgcm9sZTogJ3VzZXInLCBjb250ZW50OiBzdW1tYXJ5UHJvbXB0IH1dXG4gICAgfSk7XG4gICAgXG4gICAgLy8gUGFyc2UgdGhlIHN1bW1hcmllcyBmcm9tIHRoZSByZXNwb25zZVxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdW1tYXJ5UmVzcG9uc2UuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQgfHwgJ3t9JztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIEpTT04gZnJvbSBnZW5lcmF0ZVN1bW1hcmllcyByZXNwb25zZTpcIiwgcGFyc2VFcnJvcik7XG4gICAgICAvLyBDcmVhdGUgYmFzaWMgc3VtbWFyaWVzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbmVMaW5lOiBhbmFseXNpcy50aXRsZSxcbiAgICAgICAgcGFyYWdyYXBoOiBgRG9jdW1lbnQgYWJvdXQgJHthbmFseXNpcy50b3BpY3Muam9pbignLCAnKX0uYCxcbiAgICAgICAgZGV0YWlsZWQ6IFwiTm8gZGV0YWlsZWQgc3VtbWFyeSBhdmFpbGFibGUuXCIsXG4gICAgICAgIGtleVBvaW50czogYW5hbHlzaXMudG9waWNzLm1hcCh0b3BpYyA9PiBgSW5mb3JtYXRpb24gYWJvdXQgJHt0b3BpY31gKVxuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBzdW1tYXJpZXM6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFJldHVybiBiYXNpYyBzdW1tYXJpZXMgaWYgTExNIGZhaWxzXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uZUxpbmU6IGFuYWx5c2lzLnRpdGxlLFxuICAgICAgcGFyYWdyYXBoOiBgRG9jdW1lbnQgYWJvdXQgJHthbmFseXNpcy50b3BpY3Muam9pbignLCAnKX0uYCxcbiAgICAgIGRldGFpbGVkOiBcIk5vIGRldGFpbGVkIHN1bW1hcnkgYXZhaWxhYmxlLlwiLFxuICAgICAga2V5UG9pbnRzOiBhbmFseXNpcy50b3BpY3MubWFwKHRvcGljID0+IGBJbmZvcm1hdGlvbiBhYm91dCAke3RvcGljfWApXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIElkZW50aWZ5IGxvZ2ljYWwgc2VjdGlvbnMgd2l0aGluIGEgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlkZW50aWZ5U2VjdGlvbnModGV4dDogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudFNlY3Rpb25bXT4ge1xuICBjb25zdCBzZWN0aW9uUHJvbXB0ID0gYFxuICAgIERpdmlkZSB0aGUgZm9sbG93aW5nIGRvY3VtZW50IGludG8gbG9naWNhbCBzZWN0aW9ucy5cbiAgICBGb3IgZWFjaCBzZWN0aW9uLCBwcm92aWRlOlxuICAgIDEuIEEgc2VjdGlvbiB0aXRsZVxuICAgIDIuIFRoZSBzZWN0aW9uIGNvbnRlbnRcbiAgICBcbiAgICBEb2N1bWVudDpcbiAgICAke3RleHQuc3Vic3RyaW5nKDAsIDgwMDApfVxuICAgIFxuICAgIFJldHVybiB0aGUgc2VjdGlvbnMgaW4gdGhpcyBKU09OIGZvcm1hdDpcbiAgICBbXG4gICAgICB7XG4gICAgICAgIFwidGl0bGVcIjogXCJTZWN0aW9uIHRpdGxlXCIsXG4gICAgICAgIFwidGV4dFwiOiBcIlNlY3Rpb24gY29udGVudFwiXG4gICAgICB9LFxuICAgICAgLi4uXG4gICAgXVxuICBgO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWN0aW9uc1Jlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiAnZ3B0LTQnLFxuICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogc2VjdGlvblByb21wdCB9XVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFBhcnNlIHRoZSBzZWN0aW9ucyBmcm9tIHRoZSByZXNwb25zZVxuICAgIGNvbnN0IGNvbnRlbnQgPSBzZWN0aW9uc1Jlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50IHx8ICd7fSc7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGFycmF5IG9mIHNlY3Rpb25zXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlZC5zZWN0aW9ucyAmJiBBcnJheS5pc0FycmF5KHBhcnNlZC5zZWN0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZC5zZWN0aW9ucztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgSlNPTiBmcm9tIGlkZW50aWZ5U2VjdGlvbnMgcmVzcG9uc2U6XCIsIHBhcnNlRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBjb3VsZG4ndCBwYXJzZSBjb3JyZWN0bHksIHJldHVybiB0aGUgd2hvbGUgdGV4dCBhcyBvbmUgc2VjdGlvblxuICAgIHJldHVybiBbe1xuICAgICAgdGl0bGU6ICdEb2N1bWVudCBDb250ZW50JyxcbiAgICAgIHRleHQ6IHRleHRcbiAgICB9XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpZGVudGlmeWluZyBzZWN0aW9uczonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSB3aG9sZSB0ZXh0IGFzIG9uZSBzZWN0aW9uIGlmIExMTSBmYWlsc1xuICAgIHJldHVybiBbe1xuICAgICAgdGl0bGU6ICdEb2N1bWVudCBDb250ZW50JyxcbiAgICAgIHRleHQ6IHRleHRcbiAgICB9XTtcbiAgfVxufVxuXG4vKipcbiAqIFNwbGl0IHNlY3Rpb24gaW50byBzbWFsbGVyIGNodW5rcyBmb3IgZW1iZWRkaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNlY3Rpb25JbnRvQ2h1bmtzKFxuICBzZWN0aW9uVGV4dDogc3RyaW5nLCBcbiAgY2h1bmtTaXplOiBudW1iZXIgPSA1MDBcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgY2h1bmtzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgaWYgKHNlY3Rpb25UZXh0Lmxlbmd0aCA8PSBjaHVua1NpemUpIHtcbiAgICByZXR1cm4gW3NlY3Rpb25UZXh0XTtcbiAgfVxuICBcbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gIHdoaWxlIChjdXJyZW50SW5kZXggPCBzZWN0aW9uVGV4dC5sZW5ndGgpIHtcbiAgICAvLyBHZXQgYSBjaHVuayBvZiBhcHByb3hpbWF0ZWx5IHRoZSB0YXJnZXQgc2l6ZVxuICAgIGxldCBjaHVuayA9IHNlY3Rpb25UZXh0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIGNodW5rU2l6ZSk7XG4gICAgXG4gICAgLy8gSWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHRleHQsIHRyeSB0byBicmVhayBhdCBhIG5hdHVyYWwgYm91bmRhcnlcbiAgICBpZiAoY3VycmVudEluZGV4ICsgY2h1bmtTaXplIDwgc2VjdGlvblRleHQubGVuZ3RoKSB7XG4gICAgICAvLyBMb29rIGZvciBwYXJhZ3JhcGggYnJlYWtzIGZpcnN0IChpZGVhbCBicmVha2luZyBwb2ludClcbiAgICAgIGNvbnN0IHBhcmFncmFwaEJyZWFrID0gY2h1bmsubGFzdEluZGV4T2YoJ1xcblxcbicpO1xuICAgICAgXG4gICAgICAvLyBUaGVuIGxvb2sgZm9yIHRoZSBsYXN0IHNlbnRlbmNlIGJyZWFrIGluIHRoaXMgY2h1bmtcbiAgICAgIGNvbnN0IHNlbnRlbmNlQnJlYWtzID0gW1xuICAgICAgICBjaHVuay5sYXN0SW5kZXhPZignLiAnKSxcbiAgICAgICAgY2h1bmsubGFzdEluZGV4T2YoJz8gJyksXG4gICAgICAgIGNodW5rLmxhc3RJbmRleE9mKCchICcpLFxuICAgICAgICBjaHVuay5sYXN0SW5kZXhPZignLlxcbicpLFxuICAgICAgICBjaHVuay5sYXN0SW5kZXhPZignP1xcbicpLFxuICAgICAgICBjaHVuay5sYXN0SW5kZXhPZignIVxcbicpXG4gICAgICBdO1xuICAgICAgY29uc3QgbGFzdFNlbnRlbmNlQnJlYWsgPSBNYXRoLm1heCguLi5zZW50ZW5jZUJyZWFrcyk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBwYXJhZ3JhcGggYnJlYWsgaWYgYXZhaWxhYmxlIGFuZCByZWFzb25hYmxlLCBvdGhlcndpc2UgdXNlIHNlbnRlbmNlIGJyZWFrXG4gICAgICBpZiAocGFyYWdyYXBoQnJlYWsgPiBjaHVua1NpemUgKiAwLjUpIHtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJzdHJpbmcoMCwgcGFyYWdyYXBoQnJlYWspO1xuICAgICAgfSBlbHNlIGlmIChsYXN0U2VudGVuY2VCcmVhayA+IGNodW5rU2l6ZSAqIDAuMykge1xuICAgICAgICAvLyBJZiB0aGUgc2VudGVuY2UgYnJlYWsgaXMgYXQgbGVhc3QgMzAlIHRocm91Z2ggdGhlIGNodW5rXG4gICAgICAgIGNvbnN0IGJyZWFrVHlwZSA9IHNlbnRlbmNlQnJlYWtzLmluZGV4T2YobGFzdFNlbnRlbmNlQnJlYWspO1xuICAgICAgICAvLyBBZGQgMiB0byBpbmNsdWRlIHRoZSBwZXJpb2QgYW5kIHNwYWNlL25ld2xpbmVcbiAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJzdHJpbmcoMCwgbGFzdFNlbnRlbmNlQnJlYWsgKyAoYnJlYWtUeXBlID49IDMgPyAyIDogMikpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjaHVua3MucHVzaChjaHVuay50cmltKCkpO1xuICAgIGN1cnJlbnRJbmRleCArPSBjaHVuay5sZW5ndGg7XG4gICAgXG4gICAgLy8gQWRkIHNsaWdodCBvdmVybGFwIGZvciBjb250ZXh0IGlmIG5lZWRlZFxuICAgIGlmIChjdXJyZW50SW5kZXggPCBzZWN0aW9uVGV4dC5sZW5ndGgpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGxhc3QgY29tcGxldGUgc2VudGVuY2UgZm9yIG92ZXJsYXBcbiAgICAgIGNvbnN0IGxhc3RTZW50ZW5jZU1hdGNoID0gY2h1bmsubWF0Y2goL1teLiE/XStbLiE/XStcXHMqJC8pO1xuICAgICAgY29uc3QgbGFzdFNlbnRlbmNlID0gbGFzdFNlbnRlbmNlTWF0Y2ggPyBsYXN0U2VudGVuY2VNYXRjaFswXSA6ICcnO1xuICAgICAgXG4gICAgICBpZiAobGFzdFNlbnRlbmNlICYmIGxhc3RTZW50ZW5jZS5sZW5ndGggPCBjaHVua1NpemUgKiAwLjIpIHtcbiAgICAgICAgY3VycmVudEluZGV4IC09IGxhc3RTZW50ZW5jZS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNodW5rcztcbn1cblxuLyoqXG4gKiBDcmVhdGUgc21hcnQgY2h1bmtzIHRoYXQgbWFpbnRhaW4gZG9jdW1lbnQgc3RydWN0dXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVTbWFydENodW5rcyhcbiAgdGV4dDogc3RyaW5nLFxuICBhbmFseXNpczogRG9jdW1lbnRBbmFseXNpcyxcbiAgc3VtbWFyaWVzOiBEb2N1bWVudFN1bW1hcmllcyxcbiAgc2VjdGlvbnM6IERvY3VtZW50U2VjdGlvbltdXG4pOiBQcm9taXNlPFNtYXJ0Q2h1bmtbXT4ge1xuICBjb25zdCBjaHVua3M6IFNtYXJ0Q2h1bmtbXSA9IFtdO1xuICBcbiAgLy8gQ3JlYXRlIGEgY2h1bmsgZm9yIHRoZSBvdmVyYWxsIGRvY3VtZW50XG4gIGNodW5rcy5wdXNoKHtcbiAgICB0ZXh0OiBzdW1tYXJpZXMucGFyYWdyYXBoLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBzb3VyY2U6IGFuYWx5c2lzLnRpdGxlLFxuICAgICAgY2h1bmtUeXBlOiAnZG9jdW1lbnRfc3VtbWFyeScsXG4gICAgICB0b3BpY3M6IGFuYWx5c2lzLnRvcGljcyxcbiAgICAgIGNvbnRlbnRUeXBlOiBhbmFseXNpcy5jb250ZW50VHlwZSxcbiAgICAgIHRlY2huaWNhbExldmVsOiBhbmFseXNpcy50ZWNobmljYWxMZXZlbFxuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBQcm9jZXNzIGVhY2ggc2VjdGlvbiBpbnRvIGNodW5rc1xuICBmb3IgKGNvbnN0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIHN1bW1hcnkgZm9yIHRoaXMgc2VjdGlvblxuICAgIGxldCBzZWN0aW9uU3VtbWFyeSA9ICcnO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWN0aW9uU3VtbWFyeVByb21wdCA9IGBcbiAgICAgICAgU3VtbWFyaXplIHRoaXMgc2VjdGlvbiBpbiAxLTIgc2VudGVuY2VzOlxuICAgICAgICBcbiAgICAgICAgU2VjdGlvbiBUaXRsZTogJHtzZWN0aW9uLnRpdGxlfVxuICAgICAgICBDb250ZW50OiAke3NlY3Rpb24udGV4dC5zdWJzdHJpbmcoMCwgMjAwMCl9XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCBzdW1tYXJ5UmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgICBtb2RlbDogJ2dwdC00JyxcbiAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogc2VjdGlvblN1bW1hcnlQcm9tcHQgfV1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBzZWN0aW9uU3VtbWFyeSA9IHN1bW1hcnlSZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudCB8fCAnJztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZW5lcmF0aW5nIHN1bW1hcnkgZm9yIHNlY3Rpb24gXCIke3NlY3Rpb24udGl0bGV9XCI6YCwgZXJyb3IpO1xuICAgICAgc2VjdGlvblN1bW1hcnkgPSBgU2VjdGlvbiBhYm91dCAke3NlY3Rpb24udGl0bGV9YDtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGEgY2h1bmsgZm9yIHRoZSBzZWN0aW9uIHN1bW1hcnlcbiAgICBjaHVua3MucHVzaCh7XG4gICAgICB0ZXh0OiBzZWN0aW9uU3VtbWFyeSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogYCR7YW5hbHlzaXMudGl0bGV9IC0gJHtzZWN0aW9uLnRpdGxlfWAsXG4gICAgICAgIGNodW5rVHlwZTogJ3NlY3Rpb25fc3VtbWFyeScsXG4gICAgICAgIHRvcGljczogYW5hbHlzaXMudG9waWNzLFxuICAgICAgICBjb250ZW50VHlwZTogYW5hbHlzaXMuY29udGVudFR5cGUsXG4gICAgICAgIHRlY2huaWNhbExldmVsOiBhbmFseXNpcy50ZWNobmljYWxMZXZlbFxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNwbGl0IHRoZSBzZWN0aW9uIGNvbnRlbnQgaW50byBzbWFsbGVyIGNodW5rc1xuICAgIGNvbnN0IGNvbnRlbnRDaHVua3MgPSBzcGxpdFNlY3Rpb25JbnRvQ2h1bmtzKHNlY3Rpb24udGV4dCwgMTAwMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Q2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaHVua3MucHVzaCh7XG4gICAgICAgIHRleHQ6IGNvbnRlbnRDaHVua3NbaV0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiBgJHthbmFseXNpcy50aXRsZX0gLSAke3NlY3Rpb24udGl0bGV9IChQYXJ0ICR7aSArIDF9LyR7Y29udGVudENodW5rcy5sZW5ndGh9KWAsXG4gICAgICAgICAgY2h1bmtUeXBlOiAnc2VjdGlvbl9jb250ZW50JyxcbiAgICAgICAgICB0b3BpY3M6IGFuYWx5c2lzLnRvcGljcyxcbiAgICAgICAgICBjb250ZW50VHlwZTogYW5hbHlzaXMuY29udGVudFR5cGUsXG4gICAgICAgICAgdGVjaG5pY2FsTGV2ZWw6IGFuYWx5c2lzLnRlY2huaWNhbExldmVsLFxuICAgICAgICAgIHNlY3Rpb25UaXRsZTogc2VjdGlvbi50aXRsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8qKlxuICogRW5oYW5jZSBjaHVua3Mgd2l0aCByaWNoIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlQ2h1bmtNZXRhZGF0YShcbiAgY2h1bms6IFNtYXJ0Q2h1bmssIFxuICBhbmFseXNpczogRG9jdW1lbnRBbmFseXNpcyxcbiAgc291cmNlOiBzdHJpbmcsXG4gIHBhZ2U/OiBudW1iZXJcbik6IEVuaGFuY2VkVmVjdG9ySXRlbSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgXG4gIHJldHVybiB7XG4gICAgdGV4dDogY2h1bmsudGV4dCxcbiAgICBlbWJlZGRpbmc6IGNodW5rLmVtYmVkZGluZyB8fCBbXSwgLy8gSGFuZGxlIHVuZGVmaW5lZCBjYXNlXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlY3Rpb246IGNodW5rLm1ldGFkYXRhPy5zZWN0aW9uVGl0bGUsXG4gICAgICBwYWdlLFxuICAgICAgdG9waWNzOiBhbmFseXNpcy50b3BpY3MsXG4gICAgICBjb250ZW50VHlwZTogYW5hbHlzaXMuY29udGVudFR5cGUsXG4gICAgICB0ZWNobmljYWxMZXZlbDogYW5hbHlzaXMudGVjaG5pY2FsTGV2ZWwsXG4gICAgICBjb25maWRlbnRpYWxpdHk6IGFuYWx5c2lzLmNvbnRhaW5zQ29uZmlkZW50aWFsID8gJ2NvbmZpZGVudGlhbCcgOiAncHVibGljJyxcbiAgICAgIHJlbGF0ZWRQcm9kdWN0czogYW5hbHlzaXMuZW50aXRpZXMucHJvZHVjdHMsXG4gICAgICByZWxhdGVkUHJvamVjdHM6IGFuYWx5c2lzLmVudGl0aWVzLnByb2plY3RzLFxuICAgICAgbGFzdFVwZGF0ZWQ6IG5vdyxcbiAgICAgIGRvY3VtZW50U3VtbWFyeTogJycsIC8vIFJlbW92ZWQgcmVmZXJlbmNlIHRvIG5vbmV4aXN0ZW50IHByb3BlcnR5XG4gICAgICBzZWN0aW9uU3VtbWFyeTogJycgLy8gUmVtb3ZlZCByZWZlcmVuY2UgdG8gbm9uZXhpc3RlbnQgcHJvcGVydHlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0byBwcm9jZXNzIG5ldyBkb2N1bWVudCB3aXRoIGFkdmFuY2VkIHVuZGVyc3RhbmRpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEb2N1bWVudFdpdGhVbmRlcnN0YW5kaW5nKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBtaW1ldHlwZTogc3RyaW5nLFxuICBmaWxlbmFtZTogc3RyaW5nXG4pOiBQcm9taXNlPHtcbiAgYW5hbHlzaXM6IERvY3VtZW50QW5hbHlzaXM7XG4gIGNodW5rQ291bnQ6IG51bWJlcjtcbn0+IHtcbiAgdHJ5IHtcbiAgICAvLyAxLiBFeHRyYWN0IHRleHQgZnJvbSBkb2N1bWVudFxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCBiYXNlRXh0cmFjdFRleHQoZmlsZVBhdGgsIG1pbWV0eXBlKTtcbiAgICBcbiAgICAvLyAyLiBHZXQgTExNIHRvIGFuYWx5emUgdGhlIGZ1bGwgZG9jdW1lbnRcbiAgICBjb25zdCBkb2N1bWVudEFuYWx5c2lzID0gYXdhaXQgYW5hbHl6ZURvY3VtZW50KHRleHQpO1xuICAgIFxuICAgIC8vIDMuIEdlbmVyYXRlIG11bHRpcGxlIGRvY3VtZW50IHN1bW1hcmllc1xuICAgIGNvbnN0IHN1bW1hcmllcyA9IGF3YWl0IGdlbmVyYXRlU3VtbWFyaWVzKHRleHQsIGRvY3VtZW50QW5hbHlzaXMpO1xuICAgIFxuICAgIC8vIDQuIENyZWF0ZSBzbWFydCBjaHVua3Mgd2l0aCBuZXN0ZWQgY29udGV4dFxuICAgIGNvbnN0IHNtYXJ0Q2h1bmtzID0gYXdhaXQgY3JlYXRlU21hcnRDaHVua3ModGV4dCwgZG9jdW1lbnRBbmFseXNpcywgc3VtbWFyaWVzLCBhd2FpdCBpZGVudGlmeVNlY3Rpb25zKHRleHQpKTtcbiAgICBcbiAgICAvLyA1LiBFbmhhbmNlIGVhY2ggY2h1bmsgd2l0aCByaWNoIG1ldGFkYXRhXG4gICAgY29uc3QgZW5oYW5jZWRDaHVua3MgPSBzbWFydENodW5rcy5tYXAoY2h1bmsgPT4gXG4gICAgICBlbmhhbmNlQ2h1bmtNZXRhZGF0YShjaHVuaywgZG9jdW1lbnRBbmFseXNpcywgZmlsZW5hbWUpXG4gICAgKTtcbiAgICBcbiAgICAvLyA2LiBHZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciBhbGwgY2h1bmtzIGFuZCBhZGQgdG8gdmVjdG9yIHN0b3JlXG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBlbmhhbmNlZENodW5rcykge1xuICAgICAgY2h1bmsuZW1iZWRkaW5nID0gYXdhaXQgZW1iZWRUZXh0KGNodW5rLnRleHQpO1xuICAgICAgYWRkVG9WZWN0b3JTdG9yZShjaHVuayk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBhbmFseXNpczogZG9jdW1lbnRBbmFseXNpcyxcbiAgICAgIGNodW5rQ291bnQ6IGVuaGFuY2VkQ2h1bmtzLmxlbmd0aFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBkb2N1bWVudCB3aXRoIHVuZGVyc3RhbmRpbmc6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgZG9jdW1lbnQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICB9XG59XG5cbi8qKlxuICogQWR2YW5jZWQgZG9jdW1lbnQgcHJvY2Vzc2luZyB1dGlsaXRpZXNcbiAqIENvbnRhaW5zIGZ1bmN0aW9ucyBmb3IgcXVlcnkgYW5hbHlzaXMgYW5kIGRvY3VtZW50IHByb2Nlc3NpbmdcbiAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuYWx5c2lzIHJlc3VsdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QW5hbHlzaXNSZXN1bHQge1xuICB0ZWNobmljYWxMZXZlbDogbnVtYmVyOyAgLy8gMS01IHNjYWxlLCAxID0gYmFzaWMsIDUgPSBoaWdobHkgdGVjaG5pY2FsXG4gIGV4cGVjdGVkRm9ybWF0OiAndGV4dCcgfCAnbGlzdCcgfCAnc3RlcHMnIHwgJ3RhYmxlJztcbiAgY29tcGxleGl0eTogbnVtYmVyOyAgLy8gMS01IHNjYWxlLCAxID0gc2ltcGxlLCA1ID0gY29tcGxleFxuICB0b3BpY3M6IHN0cmluZ1tdO1xuICB1cmdlbmN5OiBudW1iZXI7ICAvLyAxLTUgc2NhbGUsIDEgPSBub3QgdXJnZW50LCA1ID0gdmVyeSB1cmdlbnRcbn1cblxuLyoqXG4gKiBBbmFseXplIGEgcXVlcnkgdG8gZGV0ZXJtaW5lIGl0cyBjaGFyYWN0ZXJpc3RpY3NcbiAqIFRoaXMgaGVscHMgaW4gb3B0aW1pemluZyByZXRyaWV2YWwgYW5kIGFuc3dlciBnZW5lcmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhbmFseXplUXVlcnkocXVlcnk6IHN0cmluZyk6IFByb21pc2U8UXVlcnlBbmFseXNpc1Jlc3VsdD4ge1xuICBjb25zdCBsb3dlclF1ZXJ5ID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIFNpbXBsZSBydWxlLWJhc2VkIGFuYWx5c2lzXG4gIC8vIEluIGEgcHJvZHVjdGlvbiBzeXN0ZW0sIHRoaXMgd291bGQgYmUgbW9yZSBzb3BoaXN0aWNhdGVkXG4gIC8vIGFuZCBwb3RlbnRpYWxseSB1c2UgTUwgbW9kZWxzIGZvciBjbGFzc2lmaWNhdGlvblxuICBcbiAgLy8gRGV0ZXJtaW5lIHRlY2huaWNhbCBsZXZlbFxuICBjb25zdCB0ZWNobmljYWxUZXJtcyA9IFtcbiAgICAnYWxnb3JpdGhtJywgJ2FyY2hpdGVjdHVyZScsICdpbXBsZW1lbnRhdGlvbicsICdpbmZyYXN0cnVjdHVyZScsXG4gICAgJ2JhY2tlbmQnLCAnZnJvbnRlbmQnLCAnYXBpJywgJ2VuZHBvaW50JywgJ3Byb3RvY29sJyxcbiAgICAnZW5jcnlwdGlvbicsICdzY2hlbWEnLCAnZGF0YWJhc2UnLCAnaW50ZWdyYXRpb24nXG4gIF07XG4gIFxuICAvLyBDb3VudCB0ZWNobmljYWwgdGVybXNcbiAgY29uc3QgdGVjaG5pY2FsVGVybUNvdW50ID0gdGVjaG5pY2FsVGVybXMuZmlsdGVyKHRlcm0gPT4gXG4gICAgbG93ZXJRdWVyeS5pbmNsdWRlcyh0ZXJtKVxuICApLmxlbmd0aDtcbiAgXG4gIGxldCB0ZWNobmljYWxMZXZlbCA9IDM7IC8vIERlZmF1bHQgbWlkLWxldmVsXG4gIHRlY2huaWNhbExldmVsICs9IHRlY2huaWNhbFRlcm1Db3VudCAqIDAuNTtcblxuICAvLyBDaGVjayBmb3Igc2ltcGxlIGxhbmd1YWdlIHRoYXQgd291bGQgaW5kaWNhdGUgbG93ZXIgdGVjaG5pY2FsIGxldmVsXG4gIGlmIChsb3dlclF1ZXJ5LmluY2x1ZGVzKCdzaW1wbGUnKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ2Vhc3knKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ2Jhc2ljcycpKSB7XG4gICAgdGVjaG5pY2FsTGV2ZWwgLT0gMTtcbiAgfVxuICBcbiAgLy8gRGV0ZXJtaW5lIGV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdFxuICBsZXQgZXhwZWN0ZWRGb3JtYXQ6ICd0ZXh0JyB8ICdsaXN0JyB8ICdzdGVwcycgfCAndGFibGUnID0gJ3RleHQnO1xuICBcbiAgaWYgKGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3N0ZXAnKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ2d1aWRlJykgfHwgXG4gICAgICBsb3dlclF1ZXJ5LmluY2x1ZGVzKCdob3cgdG8nKSkge1xuICAgIGV4cGVjdGVkRm9ybWF0ID0gJ3N0ZXBzJztcbiAgfSBlbHNlIGlmIChsb3dlclF1ZXJ5LmluY2x1ZGVzKCdsaXN0JykgfHwgXG4gICAgICAgICAgICAgbG93ZXJRdWVyeS5tYXRjaCgvd2hhdCBhcmUoIHRoZSk/IChkaWZmZXJlbnR8dmFyaW91c3xtYWlufGtleSkvKSkge1xuICAgIGV4cGVjdGVkRm9ybWF0ID0gJ2xpc3QnO1xuICB9IGVsc2UgaWYgKGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3RhYmxlJykgfHwgXG4gICAgICAgICAgICAgbG93ZXJRdWVyeS5pbmNsdWRlcygnY29tcGFyZScpIHx8XG4gICAgICAgICAgICAgbG93ZXJRdWVyeS5pbmNsdWRlcygnY29tcGFyaXNvbicpKSB7XG4gICAgZXhwZWN0ZWRGb3JtYXQgPSAndGFibGUnO1xuICB9XG4gIFxuICAvLyBEZXRlcm1pbmUgY29tcGxleGl0eVxuICBjb25zdCBjb21wbGV4V29yZHMgPSBbXG4gICAgJ2RpZmZlcmVuY2VzJywgJ2JldHdlZW4nLCAnY29tcGFyZScsICdleHBsYWluJywgJ3doeScsIFxuICAgICdob3cnLCAndGVjaG5pY2FsJywgJ2FyY2hpdGVjdHVyZScsICdkZXRhaWwnLCAndmVyc3VzJ1xuICBdO1xuICBcbiAgY29uc3QgY29tcGxleFdvcmRDb3VudCA9IGNvbXBsZXhXb3Jkcy5maWx0ZXIod29yZCA9PiBcbiAgICBsb3dlclF1ZXJ5LmluY2x1ZGVzKHdvcmQpXG4gICkubGVuZ3RoO1xuICBcbiAgbGV0IGNvbXBsZXhpdHkgPSAyOyAvLyBEZWZhdWx0IHNsaWdodGx5IGJlbG93IG1pZC1sZXZlbFxuICBjb21wbGV4aXR5ICs9IGNvbXBsZXhXb3JkQ291bnQgKiAwLjU7XG4gIFxuICAvLyBTaW1wbGUgdG9waWMgZXh0cmFjdGlvblxuICAvLyBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIG1vcmUgc29waGlzdGljYXRlZCBORVIvdG9waWMgbW9kZWxpbmdcbiAgY29uc3QgcG90ZW50aWFsVG9waWNzID0gW1xuICAgICdwcmljaW5nJywgJ2ZlYXR1cmVzJywgJ3NlY3VyaXR5JywgJ2ludGVncmF0aW9uJywgJ2FwaScsXG4gICAgJ2NvbXBhcmlzb24nLCAnaW1wbGVtZW50YXRpb24nLCAnZW50ZXJwcmlzZScsICdzdXBwb3J0JyxcbiAgICAnZGVtbycsICd0cmlhbCcsICdjb250cmFjdCcsICdkaXNjb3VudCcsICdjb21wZXRpdG9ycydcbiAgXTtcbiAgXG4gIGNvbnN0IHRvcGljcyA9IHBvdGVudGlhbFRvcGljcy5maWx0ZXIodG9waWMgPT4gXG4gICAgbG93ZXJRdWVyeS5pbmNsdWRlcyh0b3BpYylcbiAgKTtcbiAgXG4gIC8vIERldGVybWluZSB1cmdlbmN5XG4gIGxldCB1cmdlbmN5ID0gMTsgLy8gRGVmYXVsdCBsb3cgdXJnZW5jeVxuICBcbiAgaWYgKGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3VyZ2VudCcpIHx8IFxuICAgICAgbG93ZXJRdWVyeS5pbmNsdWRlcygnYXNhcCcpIHx8IFxuICAgICAgbG93ZXJRdWVyeS5pbmNsdWRlcygnaW1tZWRpYXRlbHknKSkge1xuICAgIHVyZ2VuY3kgPSA1O1xuICB9IGVsc2UgaWYgKGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3Nvb24nKSB8fCBcbiAgICAgICAgICAgICBsb3dlclF1ZXJ5LmluY2x1ZGVzKCdxdWlja2x5JykpIHtcbiAgICB1cmdlbmN5ID0gMztcbiAgfVxuICBcbiAgLy8gTm9ybWFsaXplIHNjb3JlcyB0byBpbnRlbmRlZCByYW5nZXNcbiAgdGVjaG5pY2FsTGV2ZWwgPSBNYXRoLm1heCgxLCBNYXRoLm1pbig1LCB0ZWNobmljYWxMZXZlbCkpO1xuICBjb21wbGV4aXR5ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oNSwgY29tcGxleGl0eSkpO1xuICBcbiAgcmV0dXJuIHtcbiAgICB0ZWNobmljYWxMZXZlbCxcbiAgICBleHBlY3RlZEZvcm1hdCxcbiAgICBjb21wbGV4aXR5LFxuICAgIHRvcGljcyxcbiAgICB1cmdlbmN5XG4gIH07XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBmcm9tIG5vbi1KU09OIHJlc3BvbnNlc1xuZnVuY3Rpb24gZXh0cmFjdFRpdGxlKHRleHQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCB0aXRsZU1hdGNoID0gdGV4dC5tYXRjaCgvdGl0bGU6Lio/W1wiJ10oLis/KVtcIiddL2kpO1xuICByZXR1cm4gdGl0bGVNYXRjaCA/IHRpdGxlTWF0Y2hbMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VG9waWNzKHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdIHwgbnVsbCB7XG4gIGNvbnN0IHRvcGljc01hdGNoID0gdGV4dC5tYXRjaCgvdG9waWNzOi4qP1xcWyguKj8pXFxdL2kpO1xuICBpZiAodG9waWNzTWF0Y2ggJiYgdG9waWNzTWF0Y2hbMV0pIHtcbiAgICByZXR1cm4gdG9waWNzTWF0Y2hbMV0uc3BsaXQoJywnKS5tYXAodCA9PiB0LnRyaW0oKS5yZXBsYWNlKC9bXCInXS9nLCAnJykpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0Q29udGVudFR5cGUodGV4dDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHR5cGVNYXRjaCA9IHRleHQubWF0Y2goL2NvbnRlbnRUeXBlOi4qP1tcIiddKC4rPylbXCInXS9pKTtcbiAgcmV0dXJuIHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEZvcm1hdCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZm9ybWF0TWF0Y2ggPSB0ZXh0Lm1hdGNoKC9leHBlY3RlZEZvcm1hdDouKj9bXCInXT8obGlzdHxleHBsYW5hdGlvbnxzdGVwc3xzdGVwLWJ5LXN0ZXB8Y29tcGFyaXNvbnxzdW1tYXJ5fGRldGFpbGVkKVtcIiddPy9pKTtcbiAgcmV0dXJuIGZvcm1hdE1hdGNoID8gZm9ybWF0TWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUZWNoTGV2ZWwodGV4dDogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IGxldmVsTWF0Y2ggPSB0ZXh0Lm1hdGNoKC90ZWNobmljYWxMZXZlbDouKj8oWzEtNV0pL2kpO1xuICByZXR1cm4gbGV2ZWxNYXRjaCA/IHBhcnNlSW50KGxldmVsTWF0Y2hbMV0pIDogbnVsbDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY29udGVudC1iYXNlZCByZWxldmFuY2UgYm9vc3QgZmFjdG9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ29udGVudEJvb3N0KFxuICBxdWVyeUFuYWx5c2lzOiBhbnksIFxuICBjaHVuazogRW5oYW5jZWRWZWN0b3JJdGVtXG4pOiBudW1iZXIge1xuICBsZXQgYm9vc3RGYWN0b3IgPSAxLjA7XG4gIFxuICAvLyBUb3BpYyBvdmVybGFwXG4gIGNvbnN0IHRvcGljT3ZlcmxhcCA9IHF1ZXJ5QW5hbHlzaXMudG9waWNzLmZpbHRlcihcbiAgICAodG9waWM6IHN0cmluZykgPT4gY2h1bmsubWV0YWRhdGEudG9waWNzLmluY2x1ZGVzKHRvcGljKVxuICApLmxlbmd0aDtcbiAgXG4gIGlmICh0b3BpY092ZXJsYXAgPiAwKSB7XG4gICAgYm9vc3RGYWN0b3IgKj0gMS4wICsgKHRvcGljT3ZlcmxhcCAvIHF1ZXJ5QW5hbHlzaXMudG9waWNzLmxlbmd0aCk7XG4gIH1cbiAgXG4gIC8vIFRlY2huaWNhbCBsZXZlbCBtYXRjaFxuICBjb25zdCB0ZWNoTGV2ZWxEaWZmZXJlbmNlID0gTWF0aC5hYnMoXG4gICAgcXVlcnlBbmFseXNpcy50ZWNobmljYWxMZXZlbCAtIGNodW5rLm1ldGFkYXRhLnRlY2huaWNhbExldmVsXG4gICk7XG4gIFxuICBpZiAodGVjaExldmVsRGlmZmVyZW5jZSA8PSAxKSB7XG4gICAgYm9vc3RGYWN0b3IgKj0gMS4yOyAvLyBCb29zdCBpZiB0ZWNobmljYWwgbGV2ZWxzIGFyZSBhIGdvb2QgbWF0Y2hcbiAgfVxuICBcbiAgLy8gU3RydWN0dXJlZCBjb250ZW50IG1hdGNoXG4gIGlmIChxdWVyeUFuYWx5c2lzLmV4cGVjdGVkRm9ybWF0ID09PSAnbGlzdCcgJiYgY2h1bmsudGV4dC5pbmNsdWRlcygnLSAnKSkge1xuICAgIGJvb3N0RmFjdG9yICo9IDEuMzsgLy8gQm9vc3QgbGlzdC1saWtlIGNvbnRlbnQgZm9yIGxpc3QgcXVlcmllc1xuICB9XG4gIFxuICBpZiAocXVlcnlBbmFseXNpcy5leHBlY3RlZEZvcm1hdCA9PT0gJ3N0ZXBzJyAmJiBcbiAgICAgKGNodW5rLnRleHQuaW5jbHVkZXMoJ1N0ZXAgJykgfHwgY2h1bmsudGV4dC5pbmNsdWRlcygnLiAnKSkpIHtcbiAgICBib29zdEZhY3RvciAqPSAxLjM7IC8vIEJvb3N0IHN0ZXAtbGlrZSBjb250ZW50IGZvciBzdGVwcyBxdWVyaWVzXG4gIH1cbiAgXG4gIC8vIFJlY2VuY3kgYm9vc3RcbiAgY29uc3QgbGFzdFVwZGF0ZWQgPSBuZXcgRGF0ZShjaHVuay5tZXRhZGF0YS5sYXN0VXBkYXRlZCkuZ2V0VGltZSgpO1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgY29uc3QgZGF5c1NpbmNlVXBkYXRlID0gKG5vdyAtIGxhc3RVcGRhdGVkKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgXG4gIGlmIChkYXlzU2luY2VVcGRhdGUgPCAzMCkge1xuICAgIGJvb3N0RmFjdG9yICo9IDEuMTsgLy8gU2xpZ2h0IGJvb3N0IGZvciByZWNlbnQgY29udGVudFxuICB9XG4gIFxuICByZXR1cm4gYm9vc3RGYWN0b3I7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGZpbGUgd2l0aCBmdWxsIEFJIHVuZGVyc3RhbmRpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NGaWxlV2l0aFVuZGVyc3RhbmRpbmcoXG4gIGZpbGU6IEV4cHJlc3MuTXVsdGVyLkZpbGUsIFxuICB1c2VEZWZhdWx0VGl0bGU6IGJvb2xlYW4gPSBmYWxzZVxuKTogUHJvbWlzZTxQcm9jZXNzaW5nUmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgLy8gRXh0cmFjdCB0ZXh0IGZyb20gdGhlIGZpbGVcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZXh0cmFjdFRleHQoZmlsZSk7XG4gICAgXG4gICAgLy8gUHJvY2VzcyB0aGUgZXh0cmFjdGVkIHRleHRcbiAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc1RleHRXaXRoVW5kZXJzdGFuZGluZyh0ZXh0LCBmaWxlLm9yaWdpbmFsbmFtZSwgdXNlRGVmYXVsdFRpdGxlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIGZpbGUgd2l0aCB1bmRlcnN0YW5kaW5nOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFByb2Nlc3MgdGV4dCBjb250ZW50IHdpdGggZnVsbCBBSSB1bmRlcnN0YW5kaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzVGV4dFdpdGhVbmRlcnN0YW5kaW5nKFxuICB0ZXh0OiBzdHJpbmcsIFxuICBvcmlnaW5hbFRpdGxlPzogc3RyaW5nLFxuICB1c2VEZWZhdWx0VGl0bGU6IGJvb2xlYW4gPSBmYWxzZVxuKTogUHJvbWlzZTxQcm9jZXNzaW5nUmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgLy8gQW5hbHl6ZSB0aGUgZG9jdW1lbnQgdG8gZXh0cmFjdCBtZXRhZGF0YVxuICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgYW5hbHl6ZURvY3VtZW50KHRleHQpO1xuICAgIFxuICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgdGl0bGUgaWYgYXZhaWxhYmxlIGFuZCByZXF1ZXN0ZWRcbiAgICBpZiAodXNlRGVmYXVsdFRpdGxlICYmIG9yaWdpbmFsVGl0bGUpIHtcbiAgICAgIGFuYWx5c2lzLnRpdGxlID0gb3JpZ2luYWxUaXRsZTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBzYWZlIHRpdGxlIGZvciBmaWxlIG9wZXJhdGlvbnNcbiAgICBjb25zdCBzYWZlVGl0bGUgPSAoYW5hbHlzaXMudGl0bGUgfHwgb3JpZ2luYWxUaXRsZSB8fCAnZG9jdW1lbnQnKS5yZXBsYWNlKC9bXmEtekEtWjAtOS1fXS9nLCAnXycpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHN1bW1hcmllc1xuICAgIGNvbnN0IHN1bW1hcmllcyA9IGF3YWl0IGdlbmVyYXRlU3VtbWFyaWVzKHRleHQsIGFuYWx5c2lzKTtcbiAgICBcbiAgICAvLyBJZGVudGlmeSBzZWN0aW9ucyBpbiB0aGUgZG9jdW1lbnRcbiAgICBjb25zdCBzZWN0aW9ucyA9IGF3YWl0IGlkZW50aWZ5U2VjdGlvbnModGV4dCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHNtYXJ0IGNodW5rcyB0aGF0IHByZXNlcnZlIGRvY3VtZW50IHN0cnVjdHVyZVxuICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IGNyZWF0ZVNtYXJ0Q2h1bmtzKHRleHQsIGFuYWx5c2lzLCBzdW1tYXJpZXMsIHNlY3Rpb25zKTtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgY2h1bmtzIGluIHRoZSB2ZWN0b3Igc3RvcmVcbiAgICBjb25zdCBlbWJlZGRpbmdzID0gYXdhaXQgc3RvcmVTbWFydENodW5rcyhjaHVua3MpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0aXRsZTogYW5hbHlzaXMudGl0bGUgfHwgJ1VudGl0bGVkIERvY3VtZW50JyxcbiAgICAgIHRvcGljczogYW5hbHlzaXMudG9waWNzLFxuICAgICAgY29udGVudFR5cGU6IGFuYWx5c2lzLmNvbnRlbnRUeXBlLFxuICAgICAgc3VtbWFyaWVzLFxuICAgICAgY2h1bmtzOiBjaHVua3MubGVuZ3RoLFxuICAgICAgc2VjdGlvbnM6IHNlY3Rpb25zLm1hcChzID0+IHMudGl0bGUpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHRleHQgd2l0aCB1bmRlcnN0YW5kaW5nOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGV4dCBmcm9tIGEgZmlsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRleHQoZmlsZTogRXhwcmVzcy5NdWx0ZXIuRmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIC8vIEZvciBzaW1wbGljaXR5LCB3ZSdyZSBqdXN0IHJldHVybmluZyB0aGUgZmlsZSBidWZmZXIgYXMgdGV4dFxuICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCB1c2UgbGlicmFyaWVzIGxpa2UgcGRmLXBhcnNlLCBkb2N4LCBldGMuXG4gIHJldHVybiBmaWxlLmJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcbn1cblxuLyoqXG4gKiBTdG9yZSBzbWFydCBjaHVua3MgaW4gdGhlIHZlY3RvciBzdG9yZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcmVTbWFydENodW5rcyhjaHVua3M6IFNtYXJ0Q2h1bmtbXSk6IFByb21pc2U8bnVtYmVyPiB7XG4gIGxldCBzdG9yZWRDb3VudCA9IDA7XG4gIFxuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZW5lcmF0ZSBlbWJlZGRpbmcgZm9yIHRoZSBjaHVuayB0ZXh0XG4gICAgICBjb25zdCBlbWJlZGRpbmcgPSBhd2FpdCBlbWJlZFRleHQoY2h1bmsudGV4dCk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIGluIHZlY3RvciBkYXRhYmFzZVxuICAgICAgYWRkVG9WZWN0b3JTdG9yZSh7XG4gICAgICAgIHRleHQ6IGNodW5rLnRleHQsXG4gICAgICAgIG1ldGFkYXRhOiBjaHVuay5tZXRhZGF0YSxcbiAgICAgICAgZW1iZWRkaW5nXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgc3RvcmVkQ291bnQrKztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RvcmluZyBjaHVuazonLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gc3RvcmVkQ291bnQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgZW1iZWRkaW5nIGZvciB0ZXh0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVtYmVkVGV4dCh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcltdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuZW1iZWRkaW5ncy5jcmVhdGUoe1xuICAgICAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy1hZGEtMDAyJyxcbiAgICAgIGlucHV0OiB0ZXh0XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFbMF0uZW1iZWRkaW5nO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgZW1iZWRkaW5nOicsIGVycm9yKTtcbiAgICAvLyBSZXR1cm4gYSBkdW1teSBlbWJlZGRpbmcgZm9yIGVycm9yIGNhc2VzXG4gICAgcmV0dXJuIEFycmF5KDE1MzYpLmZpbGwoMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3BsaXQgdGV4dCBpbnRvIGNodW5rc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRUZXh0SW50b0NodW5rcyh0ZXh0OiBzdHJpbmcsIG1heENodW5rU2l6ZTogbnVtYmVyID0gMTAwMCk6IHN0cmluZ1tdIHtcbiAgLy8gSW1wbGVtZW50IHRleHQgc3BsaXR0aW5nIGxvZ2ljIHRoYXQgcHJlc2VydmVzIHBhcmFncmFwaHMgYW5kIHNlbnRlbmNlIGJvdW5kYXJpZXNcbiAgY29uc3QgY2h1bmtzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgLy8gU2ltcGxlIGltcGxlbWVudGF0aW9uIGZvciBub3cgLSBzcGxpdCBieSBwYXJhZ3JhcGhzIHRoZW4gcmVjb21iaW5lIHRvIHN0YXkgdW5kZXIgbWF4Q2h1bmtTaXplXG4gIGNvbnN0IHBhcmFncmFwaHMgPSB0ZXh0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gIGxldCBjdXJyZW50Q2h1bmsgPSAnJztcbiAgXG4gIGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHBhcmFncmFwaHMpIHtcbiAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCArIHBhcmFncmFwaC5sZW5ndGggPiBtYXhDaHVua1NpemUgJiYgY3VycmVudENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGNodW5rcy5wdXNoKGN1cnJlbnRDaHVuayk7XG4gICAgICBjdXJyZW50Q2h1bmsgPSBwYXJhZ3JhcGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDaHVuayArPSAoY3VycmVudENodW5rID8gJ1xcblxcbicgOiAnJykgKyBwYXJhZ3JhcGg7XG4gICAgfVxuICB9XG4gIFxuICBpZiAoY3VycmVudENodW5rKSB7XG4gICAgY2h1bmtzLnB1c2goY3VycmVudENodW5rKTtcbiAgfVxuICBcbiAgcmV0dXJuIGNodW5rcztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzbWFydCBjaHVuayB3aXRoIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbWFydENodW5rV2l0aE1ldGFkYXRhKFxuICB0ZXh0OiBzdHJpbmcsXG4gIHNlY3Rpb246IERvY3VtZW50U2VjdGlvbixcbiAgYW5hbHlzaXM6IERvY3VtZW50QW5hbHlzaXMsXG4gIHBhcnRJbmRleDogbnVtYmVyLFxuICB0b3RhbFBhcnRzOiBudW1iZXJcbik6IFNtYXJ0Q2h1bmsge1xuICByZXR1cm4ge1xuICAgIHRleHQsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHNvdXJjZTogYCR7YW5hbHlzaXMudGl0bGV9IC0gJHtzZWN0aW9uLnRpdGxlfSAoUGFydCAke3BhcnRJbmRleH0vJHt0b3RhbFBhcnRzfSlgLFxuICAgICAgY2h1bmtUeXBlOiAnc2VjdGlvbl9jb250ZW50JyxcbiAgICAgIHRvcGljczogYW5hbHlzaXMudG9waWNzLFxuICAgICAgY29udGVudFR5cGU6IGFuYWx5c2lzLmNvbnRlbnRUeXBlLFxuICAgICAgdGVjaG5pY2FsTGV2ZWw6IGFuYWx5c2lzLnRlY2huaWNhbExldmVsLFxuICAgICAgc2VjdGlvblRpdGxlOiBzZWN0aW9uLnRpdGxlXG4gICAgfVxuICB9O1xufSAiXSwibmFtZXMiOlsiZXh0cmFjdFRleHQiLCJiYXNlRXh0cmFjdFRleHQiLCJhZGRUb1ZlY3RvclN0b3JlIiwiT3BlbkFJIiwib3BlbmFpIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk9QRU5BSV9BUElfS0VZIiwiYW5hbHl6ZURvY3VtZW50IiwidGV4dCIsImFuYWx5c2lzUHJvbXB0Iiwic3Vic3RyaW5nIiwiYW5hbHlzaXMiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJtb2RlbCIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJjaG9pY2VzIiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsInBhcnNlRXJyb3IiLCJjb25zb2xlIiwid2FybiIsInRpdGxlIiwiZXh0cmFjdFRpdGxlIiwidG9waWNzIiwiZXh0cmFjdFRvcGljcyIsImVudGl0aWVzIiwicGVvcGxlIiwicHJvZHVjdHMiLCJmZWF0dXJlcyIsInByb2plY3RzIiwiY29udGVudFR5cGUiLCJleHRyYWN0Q29udGVudFR5cGUiLCJ0ZWNobmljYWxMZXZlbCIsImV4dHJhY3RUZWNoTGV2ZWwiLCJjb250YWluc0NvbmZpZGVudGlhbCIsImVycm9yIiwiZ2VuZXJhdGVTdW1tYXJpZXMiLCJzdW1tYXJ5UHJvbXB0Iiwic3VtbWFyeVJlc3BvbnNlIiwib25lTGluZSIsInBhcmFncmFwaCIsImpvaW4iLCJkZXRhaWxlZCIsImtleVBvaW50cyIsIm1hcCIsInRvcGljIiwiaWRlbnRpZnlTZWN0aW9ucyIsInNlY3Rpb25Qcm9tcHQiLCJzZWN0aW9uc1Jlc3BvbnNlIiwicGFyc2VkIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VjdGlvbnMiLCJzcGxpdFNlY3Rpb25JbnRvQ2h1bmtzIiwic2VjdGlvblRleHQiLCJjaHVua1NpemUiLCJjaHVua3MiLCJsZW5ndGgiLCJjdXJyZW50SW5kZXgiLCJjaHVuayIsInBhcmFncmFwaEJyZWFrIiwibGFzdEluZGV4T2YiLCJzZW50ZW5jZUJyZWFrcyIsImxhc3RTZW50ZW5jZUJyZWFrIiwiTWF0aCIsIm1heCIsImJyZWFrVHlwZSIsImluZGV4T2YiLCJwdXNoIiwidHJpbSIsImxhc3RTZW50ZW5jZU1hdGNoIiwibWF0Y2giLCJsYXN0U2VudGVuY2UiLCJjcmVhdGVTbWFydENodW5rcyIsInN1bW1hcmllcyIsIm1ldGFkYXRhIiwic291cmNlIiwiY2h1bmtUeXBlIiwic2VjdGlvbiIsInNlY3Rpb25TdW1tYXJ5Iiwic2VjdGlvblN1bW1hcnlQcm9tcHQiLCJjb250ZW50Q2h1bmtzIiwiaSIsInNlY3Rpb25UaXRsZSIsImVuaGFuY2VDaHVua01ldGFkYXRhIiwicGFnZSIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVtYmVkZGluZyIsImNvbmZpZGVudGlhbGl0eSIsInJlbGF0ZWRQcm9kdWN0cyIsInJlbGF0ZWRQcm9qZWN0cyIsImxhc3RVcGRhdGVkIiwiZG9jdW1lbnRTdW1tYXJ5IiwicHJvY2Vzc0RvY3VtZW50V2l0aFVuZGVyc3RhbmRpbmciLCJmaWxlUGF0aCIsIm1pbWV0eXBlIiwiZmlsZW5hbWUiLCJkb2N1bWVudEFuYWx5c2lzIiwic21hcnRDaHVua3MiLCJlbmhhbmNlZENodW5rcyIsImVtYmVkVGV4dCIsImNodW5rQ291bnQiLCJFcnJvciIsIlN0cmluZyIsImFuYWx5emVRdWVyeSIsInF1ZXJ5IiwibG93ZXJRdWVyeSIsInRvTG93ZXJDYXNlIiwidGVjaG5pY2FsVGVybXMiLCJ0ZWNobmljYWxUZXJtQ291bnQiLCJmaWx0ZXIiLCJ0ZXJtIiwiaW5jbHVkZXMiLCJleHBlY3RlZEZvcm1hdCIsImNvbXBsZXhXb3JkcyIsImNvbXBsZXhXb3JkQ291bnQiLCJ3b3JkIiwiY29tcGxleGl0eSIsInBvdGVudGlhbFRvcGljcyIsInVyZ2VuY3kiLCJtaW4iLCJ0aXRsZU1hdGNoIiwidG9waWNzTWF0Y2giLCJzcGxpdCIsInQiLCJyZXBsYWNlIiwidHlwZU1hdGNoIiwiZXh0cmFjdEZvcm1hdCIsImZvcm1hdE1hdGNoIiwibGV2ZWxNYXRjaCIsInBhcnNlSW50IiwiY2FsY3VsYXRlQ29udGVudEJvb3N0IiwicXVlcnlBbmFseXNpcyIsImJvb3N0RmFjdG9yIiwidG9waWNPdmVybGFwIiwidGVjaExldmVsRGlmZmVyZW5jZSIsImFicyIsImdldFRpbWUiLCJkYXlzU2luY2VVcGRhdGUiLCJwcm9jZXNzRmlsZVdpdGhVbmRlcnN0YW5kaW5nIiwiZmlsZSIsInVzZURlZmF1bHRUaXRsZSIsInByb2Nlc3NUZXh0V2l0aFVuZGVyc3RhbmRpbmciLCJvcmlnaW5hbG5hbWUiLCJvcmlnaW5hbFRpdGxlIiwic2FmZVRpdGxlIiwiZW1iZWRkaW5ncyIsInN0b3JlU21hcnRDaHVua3MiLCJzIiwiYnVmZmVyIiwidG9TdHJpbmciLCJzdG9yZWRDb3VudCIsInJlc3BvbnNlIiwiaW5wdXQiLCJkYXRhIiwiZmlsbCIsInNwbGl0VGV4dEludG9DaHVua3MiLCJtYXhDaHVua1NpemUiLCJwYXJhZ3JhcGhzIiwiY3VycmVudENodW5rIiwiY3JlYXRlU21hcnRDaHVua1dpdGhNZXRhZGF0YSIsInBhcnRJbmRleCIsInRvdGFsUGFydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./utils/advancedDocumentProcessing.ts\n");

/***/ }),

/***/ "(api)/./utils/bm25.ts":
/*!***********************!*\
  !*** ./utils/bm25.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BM25_B: () => (/* binding */ BM25_B),\n/* harmony export */   BM25_K1: () => (/* binding */ BM25_K1),\n/* harmony export */   calculateBM25Score: () => (/* binding */ calculateBM25Score),\n/* harmony export */   calculateCorpusStatistics: () => (/* binding */ calculateCorpusStatistics),\n/* harmony export */   combineScores: () => (/* binding */ combineScores),\n/* harmony export */   loadCorpusStatistics: () => (/* binding */ loadCorpusStatistics),\n/* harmony export */   saveCorpusStatistics: () => (/* binding */ saveCorpusStatistics)\n/* harmony export */ });\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tokenization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokenization */ \"(api)/./utils/tokenization.ts\");\n/**\n * BM25 Implementation for improved document retrieval\n * \n * This file contains the core BM25 implementation for improved document\n * retrieval beyond vector-based similarity search. BM25 is a widely used\n * ranking function that scores documents based on term frequency and\n * inverse document frequency.\n */ \n\n\n// BM25 parameters (can be tuned)\nconst BM25_K1 = 1.2; // Term frequency saturation parameter\nconst BM25_B = 0.75; // Document length normalization parameter\n/**\n * Load corpus statistics from disk\n * These statistics are calculated by the calculate-corpus-stats script\n */ async function loadCorpusStatistics() {\n    try {\n        const statsDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\", \"corpus_stats\");\n        const statsPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(statsDir, \"corpus_statistics.json\");\n        const dfPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(statsDir, \"document_frequency.json\");\n        const docLengthsPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(statsDir, \"document_lengths.json\");\n        // Load main statistics\n        const statsData = await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().readFile(statsPath, \"utf8\");\n        const stats = JSON.parse(statsData);\n        // Load document frequency\n        const dfData = await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().readFile(dfPath, \"utf8\");\n        stats.documentFrequency = JSON.parse(dfData);\n        // Load document lengths\n        const docLengthsData = await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().readFile(docLengthsPath, \"utf8\");\n        stats.documentLengths = JSON.parse(docLengthsData);\n        return stats;\n    } catch (error) {\n        console.error(\"Error loading corpus statistics:\", error);\n        throw new Error(\"Failed to load corpus statistics\");\n    }\n}\n/**\n * Calculate corpus statistics from vector store\n * Used by the calculate-corpus-stats script\n */ async function calculateCorpusStatistics(documents) {\n    // Initialize statistics\n    const stats = {\n        totalDocuments: documents.length,\n        averageDocumentLength: 0,\n        documentFrequency: {},\n        documentLengths: {},\n        termFrequency: {},\n        mostCommonTerms: []\n    };\n    // Process in batches to avoid memory issues\n    const batchSize = 100;\n    let totalLength = 0;\n    console.log(`Processing ${documents.length} documents in increments of ${batchSize}...`);\n    for(let i = 0; i < documents.length; i += batchSize){\n        const batch = documents.slice(i, i + batchSize);\n        console.log(`Processing documents ${i + 1} to ${Math.min(i + batchSize, documents.length)}...`);\n        for (const doc of batch){\n            const docId = doc.metadata?.source || `doc_${i}`;\n            const text = doc.text || \"\";\n            // Calculate document length (number of terms)\n            const docLength = (0,_tokenization__WEBPACK_IMPORTED_MODULE_2__.getDocumentLength)(text);\n            stats.documentLengths[docId] = docLength;\n            totalLength += docLength;\n            // Calculate term frequencies for the document\n            const terms = (0,_tokenization__WEBPACK_IMPORTED_MODULE_2__.tokenize)(text);\n            const uniqueTerms = new Set(terms);\n            // Update document frequency (number of documents containing each term)\n            uniqueTerms.forEach((term)=>{\n                stats.documentFrequency[term] = (stats.documentFrequency[term] || 0) + 1;\n                stats.termFrequency[term] = (stats.termFrequency[term] || 0) + terms.filter((t)=>t === term).length;\n            });\n        }\n    }\n    // Calculate average document length\n    stats.averageDocumentLength = totalLength / documents.length;\n    // Calculate most common terms\n    const termEntries = Object.entries(stats.documentFrequency).map(([term, count])=>({\n            term,\n            count,\n            percentage: count / documents.length * 100\n        })).sort((a, b)=>b.count - a.count).slice(0, 20); // Top 20 terms\n    stats.mostCommonTerms = termEntries;\n    return stats;\n}\n/**\n * Save corpus statistics to disk\n * Used by the calculate-corpus-stats script\n */ async function saveCorpusStatistics(stats) {\n    try {\n        const statsDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\", \"corpus_stats\");\n        // Ensure directory exists\n        await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().mkdir(statsDir, {\n            recursive: true\n        });\n        // Save main statistics\n        const mainStats = {\n            totalDocuments: stats.totalDocuments,\n            averageDocumentLength: stats.averageDocumentLength,\n            uniqueTerms: Object.keys(stats.documentFrequency).length,\n            termFrequencyStats: calculateTermFrequencyStats(stats.termFrequency || {}),\n            mostCommonTerms: stats.mostCommonTerms\n        };\n        await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().writeFile(path__WEBPACK_IMPORTED_MODULE_1___default().join(statsDir, \"corpus_statistics.json\"), JSON.stringify(mainStats, null, 2));\n        // Save document frequency\n        await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().writeFile(path__WEBPACK_IMPORTED_MODULE_1___default().join(statsDir, \"document_frequency.json\"), JSON.stringify(stats.documentFrequency, null, 2));\n        // Save document lengths\n        await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().writeFile(path__WEBPACK_IMPORTED_MODULE_1___default().join(statsDir, \"document_lengths.json\"), JSON.stringify(stats.documentLengths, null, 2));\n        console.log(\"Corpus statistics saved to\", statsDir);\n    } catch (error) {\n        console.error(\"Error saving corpus statistics:\", error);\n        throw new Error(\"Failed to save corpus statistics\");\n    }\n}\n/**\n * Calculate statistics about term frequency\n */ function calculateTermFrequencyStats(termFrequency) {\n    const values = Object.values(termFrequency);\n    if (values.length === 0) {\n        return {\n            min: 0,\n            max: 0,\n            avg: 0\n        };\n    }\n    const min = Math.min(...values);\n    const max = Math.max(...values);\n    const avg = values.reduce((sum, val)=>sum + val, 0) / values.length;\n    return {\n        min,\n        max,\n        avg\n    };\n}\n/**\n * Calculate BM25 score for a document given a query\n */ function calculateBM25Score(query, document, corpusStats) {\n    const queryTerms = (0,_tokenization__WEBPACK_IMPORTED_MODULE_2__.tokenize)(query);\n    const docLength = (0,_tokenization__WEBPACK_IMPORTED_MODULE_2__.getDocumentLength)(document.text);\n    const docId = document.id;\n    let score = 0;\n    // If query or document is empty, return 0\n    if (queryTerms.length === 0 || docLength === 0) {\n        return 0;\n    }\n    // Calculate score for each query term\n    for (const term of queryTerms){\n        // Skip if term not in corpus\n        if (!corpusStats.documentFrequency[term]) {\n            continue;\n        }\n        // Calculate term frequency in the document\n        const tf = (0,_tokenization__WEBPACK_IMPORTED_MODULE_2__.countTermFrequency)(document.text)[term] || 0;\n        // Skip if term not in document\n        if (tf === 0) {\n            continue;\n        }\n        // Calculate inverse document frequency\n        const idf = Math.log((corpusStats.totalDocuments - corpusStats.documentFrequency[term] + 0.5) / (corpusStats.documentFrequency[term] + 0.5));\n        // Prevent negative IDF which can happen in certain edge cases\n        const safeIdf = Math.max(0, idf);\n        // Calculate normalized term frequency\n        const normalizedTf = tf * (BM25_K1 + 1) / (tf + BM25_K1 * (1 - BM25_B + BM25_B * (docLength / corpusStats.averageDocumentLength)));\n        // Add this term's contribution to the total score\n        score += normalizedTf * safeIdf;\n    }\n    return score;\n}\n/**\n * Hybrid search combining BM25 and vector similarity\n * @param bm25Score The BM25 score (0-1)\n * @param vectorScore The vector similarity score (0-1)\n * @param alpha Weight for BM25 (between 0 and 1)\n * @returns Combined score\n */ function combineScores(bm25Score, vectorScore, alpha = 0.5) {\n    return alpha * bm25Score + (1 - alpha) * vectorScore;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUIsY0FBYyxHQUFHO1FBQzlDLE9BQU87SUFDVDtJQUVBLHNDQUFzQztJQUN0QyxLQUFLLE1BQU1LLFFBQVErQixXQUFZO1FBQzdCLDZCQUE2QjtRQUM3QixJQUFJLENBQUNELFlBQVk3RCxpQkFBaUIsQ0FBQytCLEtBQUssRUFBRTtZQUN4QztRQUNGO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU1rQyxLQUFLbkYsaUVBQWtCQSxDQUFDOEUsU0FBU25DLElBQUksQ0FBQyxDQUFDTSxLQUFLLElBQUk7UUFFdEQsK0JBQStCO1FBQy9CLElBQUlrQyxPQUFPLEdBQUc7WUFDWjtRQUNGO1FBRUEsdUNBQXVDO1FBQ3ZDLE1BQU1DLE1BQU0vQyxLQUFLSixHQUFHLENBQ2xCLENBQUM4QyxZQUFZckQsY0FBYyxHQUFHcUQsWUFBWTdELGlCQUFpQixDQUFDK0IsS0FBSyxHQUFHLEdBQUUsSUFDckU4QixDQUFBQSxZQUFZN0QsaUJBQWlCLENBQUMrQixLQUFLLEdBQUcsR0FBRTtRQUczQyw4REFBOEQ7UUFDOUQsTUFBTW9DLFVBQVVoRCxLQUFLa0MsR0FBRyxDQUFDLEdBQUdhO1FBRTVCLHNDQUFzQztRQUN0QyxNQUFNRSxlQUNKLEtBQU9wRixDQUFBQSxVQUFVLEtBQ2hCaUYsQ0FBQUEsS0FBS2pGLFVBQVcsS0FBSUMsU0FBU0EsU0FBVXlDLENBQUFBLFlBQVltQyxZQUFZbkQscUJBQXFCLEVBQUM7UUFFeEYsa0RBQWtEO1FBQ2xEc0QsU0FBU0ksZUFBZUQ7SUFDMUI7SUFFQSxPQUFPSDtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ00sU0FBU0ssY0FBY0MsU0FBaUIsRUFBRUMsV0FBbUIsRUFBRUMsUUFBZ0IsR0FBRztJQUN2RixPQUFPQSxRQUFRRixZQUFZLENBQUMsSUFBSUUsS0FBSSxJQUFLRDtBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWNoYXQtb3BlbmFpLXJhZy8uL3V0aWxzL2JtMjUudHM/ZjkzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJNMjUgSW1wbGVtZW50YXRpb24gZm9yIGltcHJvdmVkIGRvY3VtZW50IHJldHJpZXZhbFxuICogXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGNvcmUgQk0yNSBpbXBsZW1lbnRhdGlvbiBmb3IgaW1wcm92ZWQgZG9jdW1lbnRcbiAqIHJldHJpZXZhbCBiZXlvbmQgdmVjdG9yLWJhc2VkIHNpbWlsYXJpdHkgc2VhcmNoLiBCTTI1IGlzIGEgd2lkZWx5IHVzZWRcbiAqIHJhbmtpbmcgZnVuY3Rpb24gdGhhdCBzY29yZXMgZG9jdW1lbnRzIGJhc2VkIG9uIHRlcm0gZnJlcXVlbmN5IGFuZFxuICogaW52ZXJzZSBkb2N1bWVudCBmcmVxdWVuY3kuXG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgdG9rZW5pemUsIGNvdW50VGVybUZyZXF1ZW5jeSwgZ2V0RG9jdW1lbnRMZW5ndGggfSBmcm9tICcuL3Rva2VuaXphdGlvbic7XG5pbXBvcnQgeyBWZWN0b3JTdG9yZUl0ZW0gfSBmcm9tICcuL3ZlY3RvclN0b3JlJztcblxuLy8gSW50ZXJmYWNlIGZvciBhIGRvY3VtZW50XG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50IHtcbiAgaWQ6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xufVxuXG4vLyBCTTI1IHBhcmFtZXRlcnMgKGNhbiBiZSB0dW5lZClcbmV4cG9ydCBjb25zdCBCTTI1X0sxID0gMS4yOyAgLy8gVGVybSBmcmVxdWVuY3kgc2F0dXJhdGlvbiBwYXJhbWV0ZXJcbmV4cG9ydCBjb25zdCBCTTI1X0IgPSAwLjc1OyAgLy8gRG9jdW1lbnQgbGVuZ3RoIG5vcm1hbGl6YXRpb24gcGFyYW1ldGVyXG5cbi8vIENvcnB1cyBzdGF0aXN0aWNzIGZvciBCTTI1IGNhbGN1bGF0aW9uXG5leHBvcnQgaW50ZXJmYWNlIENvcnB1c1N0YXRpc3RpY3Mge1xuICB0b3RhbERvY3VtZW50czogbnVtYmVyO1xuICBhdmVyYWdlRG9jdW1lbnRMZW5ndGg6IG51bWJlcjtcbiAgZG9jdW1lbnRGcmVxdWVuY3k6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIGRvY3VtZW50TGVuZ3RoczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgdGVybUZyZXF1ZW5jeT86IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIG1vc3RDb21tb25UZXJtcz86IEFycmF5PHsgdGVybTogc3RyaW5nLCBjb3VudDogbnVtYmVyLCBwZXJjZW50YWdlOiBudW1iZXIgfT47XG59XG5cbi8qKlxuICogTG9hZCBjb3JwdXMgc3RhdGlzdGljcyBmcm9tIGRpc2tcbiAqIFRoZXNlIHN0YXRpc3RpY3MgYXJlIGNhbGN1bGF0ZWQgYnkgdGhlIGNhbGN1bGF0ZS1jb3JwdXMtc3RhdHMgc2NyaXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQ29ycHVzU3RhdGlzdGljcygpOiBQcm9taXNlPENvcnB1c1N0YXRpc3RpY3M+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0c0RpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGF0YScsICdjb3JwdXNfc3RhdHMnKTtcbiAgICBjb25zdCBzdGF0c1BhdGggPSBwYXRoLmpvaW4oc3RhdHNEaXIsICdjb3JwdXNfc3RhdGlzdGljcy5qc29uJyk7XG4gICAgY29uc3QgZGZQYXRoID0gcGF0aC5qb2luKHN0YXRzRGlyLCAnZG9jdW1lbnRfZnJlcXVlbmN5Lmpzb24nKTtcbiAgICBjb25zdCBkb2NMZW5ndGhzUGF0aCA9IHBhdGguam9pbihzdGF0c0RpciwgJ2RvY3VtZW50X2xlbmd0aHMuanNvbicpO1xuICAgIFxuICAgIC8vIExvYWQgbWFpbiBzdGF0aXN0aWNzXG4gICAgY29uc3Qgc3RhdHNEYXRhID0gYXdhaXQgZnMucmVhZEZpbGUoc3RhdHNQYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IHN0YXRzID0gSlNPTi5wYXJzZShzdGF0c0RhdGEpIGFzIENvcnB1c1N0YXRpc3RpY3M7XG4gICAgXG4gICAgLy8gTG9hZCBkb2N1bWVudCBmcmVxdWVuY3lcbiAgICBjb25zdCBkZkRhdGEgPSBhd2FpdCBmcy5yZWFkRmlsZShkZlBhdGgsICd1dGY4Jyk7XG4gICAgc3RhdHMuZG9jdW1lbnRGcmVxdWVuY3kgPSBKU09OLnBhcnNlKGRmRGF0YSk7XG4gICAgXG4gICAgLy8gTG9hZCBkb2N1bWVudCBsZW5ndGhzXG4gICAgY29uc3QgZG9jTGVuZ3Roc0RhdGEgPSBhd2FpdCBmcy5yZWFkRmlsZShkb2NMZW5ndGhzUGF0aCwgJ3V0ZjgnKTtcbiAgICBzdGF0cy5kb2N1bWVudExlbmd0aHMgPSBKU09OLnBhcnNlKGRvY0xlbmd0aHNEYXRhKTtcbiAgICBcbiAgICByZXR1cm4gc3RhdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBjb3JwdXMgc3RhdGlzdGljczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjb3JwdXMgc3RhdGlzdGljcycpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvcnB1cyBzdGF0aXN0aWNzIGZyb20gdmVjdG9yIHN0b3JlXG4gKiBVc2VkIGJ5IHRoZSBjYWxjdWxhdGUtY29ycHVzLXN0YXRzIHNjcmlwdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlQ29ycHVzU3RhdGlzdGljcyhkb2N1bWVudHM6IFZlY3RvclN0b3JlSXRlbVtdKTogUHJvbWlzZTxDb3JwdXNTdGF0aXN0aWNzPiB7XG4gIC8vIEluaXRpYWxpemUgc3RhdGlzdGljc1xuICBjb25zdCBzdGF0czogQ29ycHVzU3RhdGlzdGljcyA9IHtcbiAgICB0b3RhbERvY3VtZW50czogZG9jdW1lbnRzLmxlbmd0aCxcbiAgICBhdmVyYWdlRG9jdW1lbnRMZW5ndGg6IDAsXG4gICAgZG9jdW1lbnRGcmVxdWVuY3k6IHt9LFxuICAgIGRvY3VtZW50TGVuZ3Roczoge30sXG4gICAgdGVybUZyZXF1ZW5jeToge30sXG4gICAgbW9zdENvbW1vblRlcm1zOiBbXVxuICB9O1xuICBcbiAgLy8gUHJvY2VzcyBpbiBiYXRjaGVzIHRvIGF2b2lkIG1lbW9yeSBpc3N1ZXNcbiAgY29uc3QgYmF0Y2hTaXplID0gMTAwO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICBcbiAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgJHtkb2N1bWVudHMubGVuZ3RofSBkb2N1bWVudHMgaW4gaW5jcmVtZW50cyBvZiAke2JhdGNoU2l6ZX0uLi5gKTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jdW1lbnRzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICBjb25zdCBiYXRjaCA9IGRvY3VtZW50cy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcbiAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBkb2N1bWVudHMgJHtpICsgMX0gdG8gJHtNYXRoLm1pbihpICsgYmF0Y2hTaXplLCBkb2N1bWVudHMubGVuZ3RoKX0uLi5gKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBiYXRjaCkge1xuICAgICAgY29uc3QgZG9jSWQgPSBkb2MubWV0YWRhdGE/LnNvdXJjZSB8fCBgZG9jXyR7aX1gO1xuICAgICAgY29uc3QgdGV4dCA9IGRvYy50ZXh0IHx8ICcnO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZG9jdW1lbnQgbGVuZ3RoIChudW1iZXIgb2YgdGVybXMpXG4gICAgICBjb25zdCBkb2NMZW5ndGggPSBnZXREb2N1bWVudExlbmd0aCh0ZXh0KTtcbiAgICAgIHN0YXRzLmRvY3VtZW50TGVuZ3Roc1tkb2NJZF0gPSBkb2NMZW5ndGg7XG4gICAgICB0b3RhbExlbmd0aCArPSBkb2NMZW5ndGg7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0ZXJtIGZyZXF1ZW5jaWVzIGZvciB0aGUgZG9jdW1lbnRcbiAgICAgIGNvbnN0IHRlcm1zID0gdG9rZW5pemUodGV4dCk7XG4gICAgICBjb25zdCB1bmlxdWVUZXJtcyA9IG5ldyBTZXQodGVybXMpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZG9jdW1lbnQgZnJlcXVlbmN5IChudW1iZXIgb2YgZG9jdW1lbnRzIGNvbnRhaW5pbmcgZWFjaCB0ZXJtKVxuICAgICAgdW5pcXVlVGVybXMuZm9yRWFjaCh0ZXJtID0+IHtcbiAgICAgICAgc3RhdHMuZG9jdW1lbnRGcmVxdWVuY3lbdGVybV0gPSAoc3RhdHMuZG9jdW1lbnRGcmVxdWVuY3lbdGVybV0gfHwgMCkgKyAxO1xuICAgICAgICBzdGF0cy50ZXJtRnJlcXVlbmN5IVt0ZXJtXSA9IChzdGF0cy50ZXJtRnJlcXVlbmN5IVt0ZXJtXSB8fCAwKSArIHRlcm1zLmZpbHRlcih0ID0+IHQgPT09IHRlcm0pLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgZG9jdW1lbnQgbGVuZ3RoXG4gIHN0YXRzLmF2ZXJhZ2VEb2N1bWVudExlbmd0aCA9IHRvdGFsTGVuZ3RoIC8gZG9jdW1lbnRzLmxlbmd0aDtcbiAgXG4gIC8vIENhbGN1bGF0ZSBtb3N0IGNvbW1vbiB0ZXJtc1xuICBjb25zdCB0ZXJtRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHN0YXRzLmRvY3VtZW50RnJlcXVlbmN5KVxuICAgIC5tYXAoKFt0ZXJtLCBjb3VudF0pID0+ICh7IHRlcm0sIGNvdW50LCBwZXJjZW50YWdlOiAoY291bnQgLyBkb2N1bWVudHMubGVuZ3RoKSAqIDEwMCB9KSlcbiAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpXG4gICAgLnNsaWNlKDAsIDIwKTsgLy8gVG9wIDIwIHRlcm1zXG4gIFxuICBzdGF0cy5tb3N0Q29tbW9uVGVybXMgPSB0ZXJtRW50cmllcztcbiAgXG4gIHJldHVybiBzdGF0cztcbn1cblxuLyoqXG4gKiBTYXZlIGNvcnB1cyBzdGF0aXN0aWNzIHRvIGRpc2tcbiAqIFVzZWQgYnkgdGhlIGNhbGN1bGF0ZS1jb3JwdXMtc3RhdHMgc2NyaXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlQ29ycHVzU3RhdGlzdGljcyhzdGF0czogQ29ycHVzU3RhdGlzdGljcyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0YXRzRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdkYXRhJywgJ2NvcnB1c19zdGF0cycpO1xuICAgIFxuICAgIC8vIEVuc3VyZSBkaXJlY3RvcnkgZXhpc3RzXG4gICAgYXdhaXQgZnMubWtkaXIoc3RhdHNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIFxuICAgIC8vIFNhdmUgbWFpbiBzdGF0aXN0aWNzXG4gICAgY29uc3QgbWFpblN0YXRzID0ge1xuICAgICAgdG90YWxEb2N1bWVudHM6IHN0YXRzLnRvdGFsRG9jdW1lbnRzLFxuICAgICAgYXZlcmFnZURvY3VtZW50TGVuZ3RoOiBzdGF0cy5hdmVyYWdlRG9jdW1lbnRMZW5ndGgsXG4gICAgICB1bmlxdWVUZXJtczogT2JqZWN0LmtleXMoc3RhdHMuZG9jdW1lbnRGcmVxdWVuY3kpLmxlbmd0aCxcbiAgICAgIHRlcm1GcmVxdWVuY3lTdGF0czogY2FsY3VsYXRlVGVybUZyZXF1ZW5jeVN0YXRzKHN0YXRzLnRlcm1GcmVxdWVuY3kgfHwge30pLFxuICAgICAgbW9zdENvbW1vblRlcm1zOiBzdGF0cy5tb3N0Q29tbW9uVGVybXNcbiAgICB9O1xuICAgIFxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShcbiAgICAgIHBhdGguam9pbihzdGF0c0RpciwgJ2NvcnB1c19zdGF0aXN0aWNzLmpzb24nKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KG1haW5TdGF0cywgbnVsbCwgMilcbiAgICApO1xuICAgIFxuICAgIC8vIFNhdmUgZG9jdW1lbnQgZnJlcXVlbmN5XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgcGF0aC5qb2luKHN0YXRzRGlyLCAnZG9jdW1lbnRfZnJlcXVlbmN5Lmpzb24nKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHN0YXRzLmRvY3VtZW50RnJlcXVlbmN5LCBudWxsLCAyKVxuICAgICk7XG4gICAgXG4gICAgLy8gU2F2ZSBkb2N1bWVudCBsZW5ndGhzXG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgcGF0aC5qb2luKHN0YXRzRGlyLCAnZG9jdW1lbnRfbGVuZ3Rocy5qc29uJyksXG4gICAgICBKU09OLnN0cmluZ2lmeShzdGF0cy5kb2N1bWVudExlbmd0aHMsIG51bGwsIDIpXG4gICAgKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ29ycHVzIHN0YXRpc3RpY3Mgc2F2ZWQgdG8nLCBzdGF0c0Rpcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGNvcnB1cyBzdGF0aXN0aWNzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGNvcnB1cyBzdGF0aXN0aWNzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgc3RhdGlzdGljcyBhYm91dCB0ZXJtIGZyZXF1ZW5jeVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUZXJtRnJlcXVlbmN5U3RhdHModGVybUZyZXF1ZW5jeTogUmVjb3JkPHN0cmluZywgbnVtYmVyPik6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBhdmc6IG51bWJlciB9IHtcbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyh0ZXJtRnJlcXVlbmN5KTtcbiAgXG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgbWluOiAwLCBtYXg6IDAsIGF2ZzogMCB9O1xuICB9XG4gIFxuICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heCguLi52YWx1ZXMpO1xuICBjb25zdCBhdmcgPSB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHZhbHVlcy5sZW5ndGg7XG4gIFxuICByZXR1cm4geyBtaW4sIG1heCwgYXZnIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIEJNMjUgc2NvcmUgZm9yIGEgZG9jdW1lbnQgZ2l2ZW4gYSBxdWVyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQk0yNVNjb3JlKHF1ZXJ5OiBzdHJpbmcsIGRvY3VtZW50OiBEb2N1bWVudCwgY29ycHVzU3RhdHM6IENvcnB1c1N0YXRpc3RpY3MpOiBudW1iZXIge1xuICBjb25zdCBxdWVyeVRlcm1zID0gdG9rZW5pemUocXVlcnkpO1xuICBjb25zdCBkb2NMZW5ndGggPSBnZXREb2N1bWVudExlbmd0aChkb2N1bWVudC50ZXh0KTtcbiAgY29uc3QgZG9jSWQgPSBkb2N1bWVudC5pZDtcbiAgXG4gIGxldCBzY29yZSA9IDA7XG4gIFxuICAvLyBJZiBxdWVyeSBvciBkb2N1bWVudCBpcyBlbXB0eSwgcmV0dXJuIDBcbiAgaWYgKHF1ZXJ5VGVybXMubGVuZ3RoID09PSAwIHx8IGRvY0xlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgc2NvcmUgZm9yIGVhY2ggcXVlcnkgdGVybVxuICBmb3IgKGNvbnN0IHRlcm0gb2YgcXVlcnlUZXJtcykge1xuICAgIC8vIFNraXAgaWYgdGVybSBub3QgaW4gY29ycHVzXG4gICAgaWYgKCFjb3JwdXNTdGF0cy5kb2N1bWVudEZyZXF1ZW5jeVt0ZXJtXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0ZXJtIGZyZXF1ZW5jeSBpbiB0aGUgZG9jdW1lbnRcbiAgICBjb25zdCB0ZiA9IGNvdW50VGVybUZyZXF1ZW5jeShkb2N1bWVudC50ZXh0KVt0ZXJtXSB8fCAwO1xuICAgIFxuICAgIC8vIFNraXAgaWYgdGVybSBub3QgaW4gZG9jdW1lbnRcbiAgICBpZiAodGYgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgaW52ZXJzZSBkb2N1bWVudCBmcmVxdWVuY3lcbiAgICBjb25zdCBpZGYgPSBNYXRoLmxvZyhcbiAgICAgIChjb3JwdXNTdGF0cy50b3RhbERvY3VtZW50cyAtIGNvcnB1c1N0YXRzLmRvY3VtZW50RnJlcXVlbmN5W3Rlcm1dICsgMC41KSAvXG4gICAgICAoY29ycHVzU3RhdHMuZG9jdW1lbnRGcmVxdWVuY3lbdGVybV0gKyAwLjUpXG4gICAgKTtcbiAgICBcbiAgICAvLyBQcmV2ZW50IG5lZ2F0aXZlIElERiB3aGljaCBjYW4gaGFwcGVuIGluIGNlcnRhaW4gZWRnZSBjYXNlc1xuICAgIGNvbnN0IHNhZmVJZGYgPSBNYXRoLm1heCgwLCBpZGYpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBub3JtYWxpemVkIHRlcm0gZnJlcXVlbmN5XG4gICAgY29uc3Qgbm9ybWFsaXplZFRmID0gXG4gICAgICAodGYgKiAoQk0yNV9LMSArIDEpKSAvIFxuICAgICAgKHRmICsgQk0yNV9LMSAqICgxIC0gQk0yNV9CICsgQk0yNV9CICogKGRvY0xlbmd0aCAvIGNvcnB1c1N0YXRzLmF2ZXJhZ2VEb2N1bWVudExlbmd0aCkpKTtcbiAgICBcbiAgICAvLyBBZGQgdGhpcyB0ZXJtJ3MgY29udHJpYnV0aW9uIHRvIHRoZSB0b3RhbCBzY29yZVxuICAgIHNjb3JlICs9IG5vcm1hbGl6ZWRUZiAqIHNhZmVJZGY7XG4gIH1cbiAgXG4gIHJldHVybiBzY29yZTtcbn1cblxuLyoqXG4gKiBIeWJyaWQgc2VhcmNoIGNvbWJpbmluZyBCTTI1IGFuZCB2ZWN0b3Igc2ltaWxhcml0eVxuICogQHBhcmFtIGJtMjVTY29yZSBUaGUgQk0yNSBzY29yZSAoMC0xKVxuICogQHBhcmFtIHZlY3RvclNjb3JlIFRoZSB2ZWN0b3Igc2ltaWxhcml0eSBzY29yZSAoMC0xKVxuICogQHBhcmFtIGFscGhhIFdlaWdodCBmb3IgQk0yNSAoYmV0d2VlbiAwIGFuZCAxKVxuICogQHJldHVybnMgQ29tYmluZWQgc2NvcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVTY29yZXMoYm0yNVNjb3JlOiBudW1iZXIsIHZlY3RvclNjb3JlOiBudW1iZXIsIGFscGhhOiBudW1iZXIgPSAwLjUpOiBudW1iZXIge1xuICByZXR1cm4gYWxwaGEgKiBibTI1U2NvcmUgKyAoMSAtIGFscGhhKSAqIHZlY3RvclNjb3JlO1xufSAiXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwidG9rZW5pemUiLCJjb3VudFRlcm1GcmVxdWVuY3kiLCJnZXREb2N1bWVudExlbmd0aCIsIkJNMjVfSzEiLCJCTTI1X0IiLCJsb2FkQ29ycHVzU3RhdGlzdGljcyIsInN0YXRzRGlyIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJzdGF0c1BhdGgiLCJkZlBhdGgiLCJkb2NMZW5ndGhzUGF0aCIsInN0YXRzRGF0YSIsInJlYWRGaWxlIiwic3RhdHMiLCJKU09OIiwicGFyc2UiLCJkZkRhdGEiLCJkb2N1bWVudEZyZXF1ZW5jeSIsImRvY0xlbmd0aHNEYXRhIiwiZG9jdW1lbnRMZW5ndGhzIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJjYWxjdWxhdGVDb3JwdXNTdGF0aXN0aWNzIiwiZG9jdW1lbnRzIiwidG90YWxEb2N1bWVudHMiLCJsZW5ndGgiLCJhdmVyYWdlRG9jdW1lbnRMZW5ndGgiLCJ0ZXJtRnJlcXVlbmN5IiwibW9zdENvbW1vblRlcm1zIiwiYmF0Y2hTaXplIiwidG90YWxMZW5ndGgiLCJsb2ciLCJpIiwiYmF0Y2giLCJzbGljZSIsIk1hdGgiLCJtaW4iLCJkb2MiLCJkb2NJZCIsIm1ldGFkYXRhIiwic291cmNlIiwidGV4dCIsImRvY0xlbmd0aCIsInRlcm1zIiwidW5pcXVlVGVybXMiLCJTZXQiLCJmb3JFYWNoIiwidGVybSIsImZpbHRlciIsInQiLCJ0ZXJtRW50cmllcyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJjb3VudCIsInBlcmNlbnRhZ2UiLCJzb3J0IiwiYSIsImIiLCJzYXZlQ29ycHVzU3RhdGlzdGljcyIsIm1rZGlyIiwicmVjdXJzaXZlIiwibWFpblN0YXRzIiwia2V5cyIsInRlcm1GcmVxdWVuY3lTdGF0cyIsImNhbGN1bGF0ZVRlcm1GcmVxdWVuY3lTdGF0cyIsIndyaXRlRmlsZSIsInN0cmluZ2lmeSIsInZhbHVlcyIsIm1heCIsImF2ZyIsInJlZHVjZSIsInN1bSIsInZhbCIsImNhbGN1bGF0ZUJNMjVTY29yZSIsInF1ZXJ5IiwiZG9jdW1lbnQiLCJjb3JwdXNTdGF0cyIsInF1ZXJ5VGVybXMiLCJpZCIsInNjb3JlIiwidGYiLCJpZGYiLCJzYWZlSWRmIiwibm9ybWFsaXplZFRmIiwiY29tYmluZVNjb3JlcyIsImJtMjVTY29yZSIsInZlY3RvclNjb3JlIiwiYWxwaGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./utils/bm25.ts\n");

/***/ }),

/***/ "(api)/./utils/caching.ts":
/*!**************************!*\
  !*** ./utils/caching.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheResult: () => (/* binding */ cacheResult),\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   generateCacheKey: () => (/* binding */ generateCacheKey),\n/* harmony export */   getCacheStats: () => (/* binding */ getCacheStats),\n/* harmony export */   getCachedResult: () => (/* binding */ getCachedResult)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Simple caching utilities for the RAG system\n * \n * Provides in-memory caching functionality for query results\n * to improve performance for repeated queries.\n */ \n// Simple in-memory cache\nconst cache = {};\n/**\n * Generate a cache key for a query\n */ function generateCacheKey(query) {\n    return `query:${crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha256\").update(query).digest(\"hex\")}`;\n}\n/**\n * Check if a query result is cached\n */ async function getCachedResult(query) {\n    try {\n        const cacheKey = generateCacheKey(query);\n        const entry = cache[cacheKey];\n        if (entry && entry.expiresAt > Date.now()) {\n            console.log(\"Cache hit for query:\", query);\n            return entry.data;\n        }\n        if (entry) {\n            // Expired entry, clean up\n            console.log(\"Cache entry expired for query:\", query);\n            delete cache[cacheKey];\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error retrieving from cache:\", error);\n        return null;\n    }\n}\n/**\n * Cache a query result\n */ async function cacheResult(query, result, ttlSeconds = 3600) {\n    try {\n        const cacheKey = generateCacheKey(query);\n        const expiresAt = Date.now() + ttlSeconds * 1000;\n        cache[cacheKey] = {\n            data: result,\n            expiresAt\n        };\n        console.log(`Cached result for query \"${query}\" (expires in ${ttlSeconds}s)`);\n        // Cleanup old entries every 100 cache operations\n        if (Math.random() < 0.01) {\n            cleanupExpiredEntries();\n        }\n    } catch (error) {\n        console.error(\"Error caching result:\", error);\n    }\n}\n/**\n * Remove all expired entries from the cache\n */ function cleanupExpiredEntries() {\n    const now = Date.now();\n    let cleanedCount = 0;\n    Object.keys(cache).forEach((key)=>{\n        if (cache[key].expiresAt < now) {\n            delete cache[key];\n            cleanedCount++;\n        }\n    });\n    if (cleanedCount > 0) {\n        console.log(`Cleaned up ${cleanedCount} expired cache entries`);\n    }\n}\n/**\n * Get cache statistics\n */ function getCacheStats() {\n    const now = Date.now();\n    const keys = Object.keys(cache);\n    const activeEntries = keys.filter((key)=>cache[key].expiresAt >= now).length;\n    return {\n        size: keys.length,\n        activeEntries,\n        expiredEntries: keys.length - activeEntries\n    };\n}\n/**\n * Clear the entire cache\n */ function clearCache() {\n    const count = Object.keys(cache).length;\n    Object.keys(cache).forEach((key)=>delete cache[key]);\n    console.log(`Cleared ${count} entries from cache`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtY2hhdC1vcGVuYWktcmFnLy4vdXRpbHMvY2FjaGluZy50cz8xNmJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2ltcGxlIGNhY2hpbmcgdXRpbGl0aWVzIGZvciB0aGUgUkFHIHN5c3RlbVxuICogXG4gKiBQcm92aWRlcyBpbi1tZW1vcnkgY2FjaGluZyBmdW5jdGlvbmFsaXR5IGZvciBxdWVyeSByZXN1bHRzXG4gKiB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGZvciByZXBlYXRlZCBxdWVyaWVzLlxuICovXG5cbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLy8gSW4tbWVtb3J5IGNhY2hlIHN0b3JhZ2VcbmludGVyZmFjZSBDYWNoZUVudHJ5IHtcbiAgZGF0YTogYW55O1xuICBleHBpcmVzQXQ6IG51bWJlcjtcbn1cblxuLy8gU2ltcGxlIGluLW1lbW9yeSBjYWNoZVxuY29uc3QgY2FjaGU6IFJlY29yZDxzdHJpbmcsIENhY2hlRW50cnk+ID0ge307XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjYWNoZSBrZXkgZm9yIGEgcXVlcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2FjaGVLZXkocXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgcXVlcnk6JHtjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHF1ZXJ5KS5kaWdlc3QoJ2hleCcpfWA7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBxdWVyeSByZXN1bHQgaXMgY2FjaGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRSZXN1bHQocXVlcnk6IHN0cmluZyk6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2VuZXJhdGVDYWNoZUtleShxdWVyeSk7XG4gICAgY29uc3QgZW50cnkgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgXG4gICAgaWYgKGVudHJ5ICYmIGVudHJ5LmV4cGlyZXNBdCA+IERhdGUubm93KCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDYWNoZSBoaXQgZm9yIHF1ZXJ5OicsIHF1ZXJ5KTtcbiAgICAgIHJldHVybiBlbnRyeS5kYXRhO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIC8vIEV4cGlyZWQgZW50cnksIGNsZWFuIHVwXG4gICAgICBjb25zb2xlLmxvZygnQ2FjaGUgZW50cnkgZXhwaXJlZCBmb3IgcXVlcnk6JywgcXVlcnkpO1xuICAgICAgZGVsZXRlIGNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmV0cmlldmluZyBmcm9tIGNhY2hlOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENhY2hlIGEgcXVlcnkgcmVzdWx0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZVJlc3VsdChcbiAgcXVlcnk6IHN0cmluZywgXG4gIHJlc3VsdDogYW55LCBcbiAgdHRsU2Vjb25kczogbnVtYmVyID0gMzYwMFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZW5lcmF0ZUNhY2hlS2V5KHF1ZXJ5KTtcbiAgICBjb25zdCBleHBpcmVzQXQgPSBEYXRlLm5vdygpICsgKHR0bFNlY29uZHMgKiAxMDAwKTtcbiAgICBcbiAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICBkYXRhOiByZXN1bHQsXG4gICAgICBleHBpcmVzQXRcbiAgICB9O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBDYWNoZWQgcmVzdWx0IGZvciBxdWVyeSBcIiR7cXVlcnl9XCIgKGV4cGlyZXMgaW4gJHt0dGxTZWNvbmRzfXMpYCk7XG4gICAgXG4gICAgLy8gQ2xlYW51cCBvbGQgZW50cmllcyBldmVyeSAxMDAgY2FjaGUgb3BlcmF0aW9uc1xuICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xuICAgICAgY2xlYW51cEV4cGlyZWRFbnRyaWVzKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgcmVzdWx0OicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgZXhwaXJlZCBlbnRyaWVzIGZyb20gdGhlIGNhY2hlXG4gKi9cbmZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkRW50cmllcygpOiB2b2lkIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgbGV0IGNsZWFuZWRDb3VudCA9IDA7XG4gIFxuICBPYmplY3Qua2V5cyhjYWNoZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChjYWNoZVtrZXldLmV4cGlyZXNBdCA8IG5vdykge1xuICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICBjbGVhbmVkQ291bnQrKztcbiAgICB9XG4gIH0pO1xuICBcbiAgaWYgKGNsZWFuZWRDb3VudCA+IDApIHtcbiAgICBjb25zb2xlLmxvZyhgQ2xlYW5lZCB1cCAke2NsZWFuZWRDb3VudH0gZXhwaXJlZCBjYWNoZSBlbnRyaWVzYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgY2FjaGUgc3RhdGlzdGljc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVTdGF0cygpOiB7XG4gIHNpemU6IG51bWJlcjtcbiAgYWN0aXZlRW50cmllczogbnVtYmVyO1xuICBleHBpcmVkRW50cmllczogbnVtYmVyO1xufSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG4gIGNvbnN0IGFjdGl2ZUVudHJpZXMgPSBrZXlzLmZpbHRlcihrZXkgPT4gY2FjaGVba2V5XS5leHBpcmVzQXQgPj0gbm93KS5sZW5ndGg7XG4gIFxuICByZXR1cm4ge1xuICAgIHNpemU6IGtleXMubGVuZ3RoLFxuICAgIGFjdGl2ZUVudHJpZXMsXG4gICAgZXhwaXJlZEVudHJpZXM6IGtleXMubGVuZ3RoIC0gYWN0aXZlRW50cmllc1xuICB9O1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSBlbnRpcmUgY2FjaGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gIGNvbnN0IGNvdW50ID0gT2JqZWN0LmtleXMoY2FjaGUpLmxlbmd0aDtcbiAgT2JqZWN0LmtleXMoY2FjaGUpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBjYWNoZVtrZXldKTtcbiAgY29uc29sZS5sb2coYENsZWFyZWQgJHtjb3VudH0gZW50cmllcyBmcm9tIGNhY2hlYCk7XG59ICJdLCJuYW1lcyI6WyJjcnlwdG8iLCJjYWNoZSIsImdlbmVyYXRlQ2FjaGVLZXkiLCJxdWVyeSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJnZXRDYWNoZWRSZXN1bHQiLCJjYWNoZUtleSIsImVudHJ5IiwiZXhwaXJlc0F0IiwiRGF0ZSIsIm5vdyIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJjYWNoZVJlc3VsdCIsInJlc3VsdCIsInR0bFNlY29uZHMiLCJNYXRoIiwicmFuZG9tIiwiY2xlYW51cEV4cGlyZWRFbnRyaWVzIiwiY2xlYW5lZENvdW50IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJnZXRDYWNoZVN0YXRzIiwiYWN0aXZlRW50cmllcyIsImZpbHRlciIsImxlbmd0aCIsInNpemUiLCJleHBpcmVkRW50cmllcyIsImNsZWFyQ2FjaGUiLCJjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/caching.ts\n");

/***/ }),

/***/ "(api)/./utils/documentProcessing.ts":
/*!*************************************!*\
  !*** ./utils/documentProcessing.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectStructuredInfo: () => (/* binding */ detectStructuredInfo),\n/* harmony export */   extractText: () => (/* binding */ extractText),\n/* harmony export */   splitIntoChunks: () => (/* binding */ splitIntoChunks)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var mammoth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mammoth */ \"mammoth\");\n/* harmony import */ var mammoth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mammoth__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var pdf_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pdf-parse */ \"pdf-parse\");\n/* harmony import */ var pdf_parse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pdf_parse__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Extract text content from various document formats\n * @param filePath Path to the file\n * @param mimetype MIME type of the file\n * @returns Extracted text content\n */ async function extractText(filePath, mimetype) {\n    try {\n        if (mimetype === \"application/pdf\") {\n            const dataBuffer = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(filePath);\n            const result = await pdf_parse__WEBPACK_IMPORTED_MODULE_2___default()(dataBuffer);\n            return result.text;\n        } else if (mimetype === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\") {\n            const result = await extractTextFromDoc(filePath);\n            return result;\n        } else if (mimetype === \"text/plain\") {\n            return fs__WEBPACK_IMPORTED_MODULE_0___default().promises.readFile(filePath, \"utf-8\");\n        } else {\n            throw new Error(`Unsupported file type: ${mimetype}`);\n        }\n    } catch (error) {\n        console.error(\"Error extracting text:\", error);\n        throw new Error(`Failed to extract text from document: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\nasync function extractTextFromDoc(filePath) {\n    try {\n        // Read the file as a buffer\n        const fileBuffer = await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.readFile(filePath);\n        // Use the buffer directly instead of the path\n        const result = await mammoth__WEBPACK_IMPORTED_MODULE_1___default().extractRawText(fileBuffer);\n        return result.value;\n    } catch (error) {\n        console.error(\"Error extracting text from DOCX:\", error);\n        throw new Error(`Failed to extract text from DOCX file: ${error.message || \"Unknown error\"}`);\n    }\n}\n/**\n * Detect if text contains structured information like company values, investors,\n * leadership, pricing, or sales-related content\n */ function detectStructuredInfo(text) {\n    const textLower = text.toLowerCase();\n    // Detect company values\n    const hasCompanyValues = textLower.includes(\"our values\") || textLower.includes(\"company values\") || textLower.includes(\"core values\") || textLower.includes(\"our culture\") || textLower.includes(\"culture\") || textLower.includes(\"mission statement\") || textLower.includes(\"vision statement\") || textLower.includes(\"what we believe\") || textLower.includes(\"our beliefs\") || textLower.includes(\"our mission\") || textLower.includes(\"our vision\");\n    // Detect investor information\n    const hasInvestors = textLower.includes(\"investor\") || textLower.includes(\"investors\") || textLower.includes(\"funding\") || textLower.includes(\"backed by\") || textLower.includes(\"investment\") || textLower.includes(\"venture capital\") || textLower.includes(\"series \") || textLower.includes(\"financing\") || textLower.includes(\"raised\");\n    // Detect leadership information\n    const hasLeadership = textLower.includes(\"founder\") || textLower.includes(\"founders\") || textLower.includes(\"ceo\") || textLower.includes(\"cto\") || textLower.includes(\"cfo\") || textLower.includes(\"chief\") || textLower.includes(\"president\") || textLower.includes(\"executive\") || textLower.includes(\"director\") || textLower.includes(\"head of\") || textLower.includes(\"lead\") || textLower.includes(\"manager\") || textLower.includes(\"management team\") || textLower.includes(\"leadership team\");\n    // Detect pricing information\n    const hasPricing = textLower.includes(\"pricing\") || textLower.includes(\"price\") || textLower.includes(\"cost\") || textLower.includes(\"subscription\") || textLower.includes(\"tier\") || textLower.includes(\"plan\") || textLower.includes(\"package\") || textLower.includes(\"fee\") || textLower.includes(\"$ \") || textLower.includes(\"dollar\") || textLower.includes(\"per month\") || textLower.includes(\"per year\") || textLower.includes(\"monthly\") || textLower.includes(\"annually\") || textLower.includes(\"free trial\");\n    // Detect product features\n    const hasProductFeatures = textLower.includes(\"feature\") || textLower.includes(\"benefits\") || textLower.includes(\"capabilities\") || textLower.includes(\"functionality\") || textLower.includes(\"module\") || textLower.includes(\"component\") || textLower.includes(\"how it works\") || textLower.includes(\"what it does\") || textLower.includes(\"our product\") || textLower.includes(\"platform\");\n    // Detect sales-specific information\n    const hasSalesInfo = textLower.includes(\"sales pitch\") || textLower.includes(\"pitch deck\") || textLower.includes(\"value proposition\") || textLower.includes(\"why choose us\") || textLower.includes(\"competitor\") || textLower.includes(\"vs.\") || textLower.includes(\"versus\") || textLower.includes(\"comparison\") || textLower.includes(\"case study\") || textLower.includes(\"success story\") || textLower.includes(\"testimonial\") || textLower.includes(\"roi\") || textLower.includes(\"return on investment\");\n    return {\n        hasCompanyValues,\n        hasInvestors,\n        hasLeadership,\n        hasPricing,\n        hasProductFeatures,\n        hasSalesInfo\n    };\n}\n/**\n * Split text into chunks of approximately the specified size\n * Enhanced to preserve context and structured information\n * @param text Text to split\n * @param chunkSize Target size for each chunk\n * @param source Optional source metadata for context-aware chunking\n * @returns Array of text chunks with metadata\n */ function splitIntoChunks(text, chunkSize = 500, source) {\n    // Remove excess whitespace\n    const cleanedText = text.replace(/\\s+/g, \" \").trim();\n    if (cleanedText.length <= chunkSize) {\n        // For small text, check if it contains structured information\n        const structuredInfo = detectStructuredInfo(cleanedText);\n        const metadata = {};\n        if (structuredInfo.hasCompanyValues || structuredInfo.hasInvestors || structuredInfo.hasLeadership || structuredInfo.hasPricing || structuredInfo.hasProductFeatures || structuredInfo.hasSalesInfo) {\n            metadata.isStructured = true;\n            if (structuredInfo.hasCompanyValues) {\n                metadata.infoType = \"company_values\";\n            } else if (structuredInfo.hasInvestors) {\n                metadata.infoType = \"investors\";\n            } else if (structuredInfo.hasLeadership) {\n                metadata.infoType = \"leadership\";\n            } else if (structuredInfo.hasPricing) {\n                metadata.infoType = \"pricing\";\n            } else if (structuredInfo.hasProductFeatures) {\n                metadata.infoType = \"product_features\";\n            } else if (structuredInfo.hasSalesInfo) {\n                metadata.infoType = \"sales_info\";\n            }\n        }\n        return [\n            {\n                text: cleanedText,\n                metadata\n            }\n        ];\n    }\n    // If this is a careers or about page, we may need special handling\n    const isAboutPage = source?.includes(\"/about\") || source?.toLowerCase().includes(\"about us\");\n    const isCareersPage = source?.includes(\"/careers\") || source?.toLowerCase().includes(\"careers\");\n    // For career and about pages, try to locate sections for special handling\n    if (isAboutPage || isCareersPage) {\n        return splitStructuredContent(cleanedText, chunkSize, source);\n    }\n    // Standard chunking for other content\n    return splitRegularContent(cleanedText, chunkSize);\n}\n/**\n * Split potentially structured content like about pages and careers pages\n * Preserves sections related to company information\n */ function splitStructuredContent(text, chunkSize, source) {\n    const chunks = [];\n    // Try to identify sections in the text\n    const sections = identifySections(text);\n    // If we identified structured sections, process them specially\n    if (sections.length > 0) {\n        for (const section of sections){\n            const structuredInfo = detectStructuredInfo(section.text);\n            const metadata = {};\n            if (structuredInfo.hasCompanyValues) {\n                metadata.isStructured = true;\n                metadata.infoType = \"company_values\";\n            } else if (structuredInfo.hasInvestors) {\n                metadata.isStructured = true;\n                metadata.infoType = \"investors\";\n            } else if (structuredInfo.hasLeadership) {\n                metadata.isStructured = true;\n                metadata.infoType = \"leadership\";\n            } else if (structuredInfo.hasPricing) {\n                metadata.isStructured = true;\n                metadata.infoType = \"pricing\";\n            } else if (structuredInfo.hasProductFeatures) {\n                metadata.isStructured = true;\n                metadata.infoType = \"product_features\";\n            } else if (structuredInfo.hasSalesInfo) {\n                metadata.isStructured = true;\n                metadata.infoType = \"sales_info\";\n            }\n            // If this is a structured section, try to keep it intact if possible\n            if (metadata.isStructured && section.text.length <= chunkSize * 1.5) {\n                chunks.push({\n                    text: section.text,\n                    metadata\n                });\n            } else {\n                // If too large, split but preserve the metadata\n                const sectionChunks = splitRegularContent(section.text, chunkSize);\n                for (const chunk of sectionChunks){\n                    if (metadata.isStructured) {\n                        chunk.metadata = {\n                            ...metadata\n                        };\n                    }\n                    chunks.push(chunk);\n                }\n            }\n        }\n        return chunks;\n    }\n    // If we couldn't identify structured sections, fall back to regular chunking\n    return splitRegularContent(text, chunkSize);\n}\n/**\n * Identify potential sections in text based on headings and patterns\n */ function identifySections(text) {\n    const sections = [];\n    // Common section indicators\n    const sectionIndicators = [\n        \"our values\",\n        \"company values\",\n        \"our investors\",\n        \"our mission\",\n        \"leadership\",\n        \"team\",\n        \"about us\",\n        \"our story\",\n        \"vision\",\n        \"what we do\",\n        \"who we are\",\n        \"our investors\"\n    ];\n    // Try to split by common headings and indicators\n    let remainingText = text;\n    // First pass: Look for section headings\n    for (const indicator of sectionIndicators){\n        const indicatorRegex = new RegExp(`(^|\\\\s)${indicator}[:\\\\s]`, \"i\");\n        const match = remainingText.match(indicatorRegex);\n        if (match && match.index !== undefined) {\n            // Find the next section indicator after this one\n            let nextIndex = remainingText.length;\n            for (const nextIndicator of sectionIndicators){\n                if (nextIndicator === indicator) continue;\n                const nextRegex = new RegExp(`(^|\\\\s)${nextIndicator}[:\\\\s]`, \"i\");\n                const nextMatch = remainingText.slice(match.index + indicator.length).match(nextRegex);\n                if (nextMatch && nextMatch.index !== undefined) {\n                    nextIndex = Math.min(nextIndex, match.index + indicator.length + nextMatch.index);\n                }\n            }\n            // Extract this section\n            const sectionText = remainingText.slice(Math.max(0, match.index - 20), nextIndex + 20 // Include some context after\n            ).trim();\n            if (sectionText.length > 50) {\n                sections.push({\n                    text: sectionText,\n                    type: indicator\n                });\n            }\n        }\n    }\n    // If we didn't find sections, try another approach with paragraph breaks\n    if (sections.length === 0) {\n        const paragraphs = text.split(/\\n\\s*\\n/);\n        let currentSection = \"\";\n        let currentType = undefined;\n        for (const paragraph of paragraphs){\n            if (paragraph.trim().length < 10) continue; // Skip very short paragraphs\n            // Check if this paragraph starts a new section\n            let foundNewSection = false;\n            for (const indicator of sectionIndicators){\n                if (paragraph.toLowerCase().includes(indicator)) {\n                    // If we have a current section, add it before starting a new one\n                    if (currentSection.length > 0) {\n                        sections.push({\n                            text: currentSection,\n                            type: currentType\n                        });\n                    }\n                    // Start a new section\n                    currentSection = paragraph;\n                    currentType = indicator;\n                    foundNewSection = true;\n                    break;\n                }\n            }\n            // If not a new section, add to current section\n            if (!foundNewSection) {\n                if (currentSection.length > 0) {\n                    currentSection += \"\\n\\n\" + paragraph;\n                } else {\n                    currentSection = paragraph;\n                }\n            }\n        }\n        // Add the final section if it exists\n        if (currentSection.length > 0) {\n            sections.push({\n                text: currentSection,\n                type: currentType\n            });\n        }\n    }\n    // If we still don't have sections, create one for the whole text\n    if (sections.length === 0) {\n        sections.push({\n            text\n        });\n    }\n    return sections;\n}\n/**\n * Split text using the standard chunking algorithm\n * @param text Text to split\n * @param chunkSize Target size for each chunk\n * @returns Array of text chunks\n */ function splitRegularContent(text, chunkSize) {\n    const chunks = [];\n    let currentIndex = 0;\n    while(currentIndex < text.length){\n        // Get a chunk of approximately the target size\n        let chunk = text.substring(currentIndex, currentIndex + chunkSize);\n        // If we're not at the end of the text, try to break at a natural boundary\n        if (currentIndex + chunkSize < text.length) {\n            // Look for paragraph breaks first (ideal breaking point)\n            const paragraphBreak = chunk.lastIndexOf(\"\\n\\n\");\n            // Then look for the last sentence break in this chunk\n            const sentenceBreaks = [\n                chunk.lastIndexOf(\". \"),\n                chunk.lastIndexOf(\"? \"),\n                chunk.lastIndexOf(\"! \"),\n                chunk.lastIndexOf(\".\\n\"),\n                chunk.lastIndexOf(\"?\\n\"),\n                chunk.lastIndexOf(\"!\\n\")\n            ];\n            const lastSentenceBreak = Math.max(...sentenceBreaks);\n            // Use paragraph break if available and reasonable, otherwise use sentence break\n            if (paragraphBreak > chunkSize * 0.5) {\n                chunk = chunk.substring(0, paragraphBreak);\n            } else if (lastSentenceBreak > chunkSize * 0.3) {\n                // If the sentence break is at least 30% through the chunk\n                const breakType = sentenceBreaks.indexOf(lastSentenceBreak);\n                // Add 2 to include the period and space/newline\n                chunk = chunk.substring(0, lastSentenceBreak + (breakType >= 3 ? 2 : 2));\n            }\n        }\n        // Create chunkObj with proper type that includes optional metadata\n        const chunkObj = {\n            text: chunk.trim()\n        };\n        const structuredInfo = detectStructuredInfo(chunk);\n        if (structuredInfo.hasCompanyValues || structuredInfo.hasInvestors || structuredInfo.hasLeadership || structuredInfo.hasPricing || structuredInfo.hasProductFeatures || structuredInfo.hasSalesInfo) {\n            const metadata = {\n                isStructured: true\n            };\n            if (structuredInfo.hasCompanyValues) {\n                metadata.infoType = \"company_values\";\n            } else if (structuredInfo.hasInvestors) {\n                metadata.infoType = \"investors\";\n            } else if (structuredInfo.hasLeadership) {\n                metadata.infoType = \"leadership\";\n            } else if (structuredInfo.hasPricing) {\n                metadata.infoType = \"pricing\";\n            } else if (structuredInfo.hasProductFeatures) {\n                metadata.infoType = \"product_features\";\n            } else if (structuredInfo.hasSalesInfo) {\n                metadata.infoType = \"sales_info\";\n            }\n            chunkObj.metadata = metadata;\n        }\n        chunks.push(chunkObj);\n        currentIndex += chunk.length;\n        // Add slight overlap for context if needed\n        if (currentIndex < text.length) {\n            const lastSentence = findLastSentence(chunk);\n            if (lastSentence && lastSentence.length < chunkSize * 0.2) {\n                currentIndex -= lastSentence.length;\n            }\n        }\n    }\n    return chunks;\n}\n/**\n * Find the last complete sentence in a text\n */ function findLastSentence(text) {\n    const sentences = text.match(/[^.!?]+[.!?]+/g);\n    if (sentences && sentences.length > 0) {\n        return sentences[sentences.length - 1];\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RztZQUN0QixPQUFPLElBQUlILGVBQWVYLGFBQWEsRUFBRTtnQkFDdkNZLFNBQVNFLFFBQVEsR0FBRztZQUN0QixPQUFPLElBQUlILGVBQWVWLFVBQVUsRUFBRTtnQkFDcENXLFNBQVNFLFFBQVEsR0FBRztZQUN0QixPQUFPLElBQUlILGVBQWVULGtCQUFrQixFQUFFO2dCQUM1Q1UsU0FBU0UsUUFBUSxHQUFHO1lBQ3RCLE9BQU8sSUFBSUgsZUFBZVIsWUFBWSxFQUFFO2dCQUN0Q1MsU0FBU0UsUUFBUSxHQUFHO1lBQ3RCO1lBRUE0QyxTQUFTOUMsUUFBUSxHQUFHQTtRQUN0QjtRQUVBTyxPQUFPSSxJQUFJLENBQUNtQztRQUNaUixnQkFBZ0J6QixNQUFNZixNQUFNO1FBRTVCLDJDQUEyQztRQUMzQyxJQUFJd0MsZUFBZXBFLEtBQUs0QixNQUFNLEVBQUU7WUFDOUIsTUFBTWlELGVBQWVDLGlCQUFpQm5DO1lBQ3RDLElBQUlrQyxnQkFBZ0JBLGFBQWFqRCxNQUFNLEdBQUdMLFlBQVksS0FBSztnQkFDekQ2QyxnQkFBZ0JTLGFBQWFqRCxNQUFNO1lBQ3JDO1FBQ0Y7SUFDRjtJQUVBLE9BQU9TO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELFNBQVN5QyxpQkFBaUI5RSxJQUFZO0lBQ3BDLE1BQU0rRSxZQUFZL0UsS0FBS2lELEtBQUssQ0FBQztJQUM3QixJQUFJOEIsYUFBYUEsVUFBVW5ELE1BQU0sR0FBRyxHQUFHO1FBQ3JDLE9BQU9tRCxTQUFTLENBQUNBLFVBQVVuRCxNQUFNLEdBQUcsRUFBRTtJQUN4QztJQUNBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWNoYXQtb3BlbmFpLXJhZy8uL3V0aWxzL2RvY3VtZW50UHJvY2Vzc2luZy50cz9mYTc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgbWFtbW90aCBmcm9tICdtYW1tb3RoJztcbmltcG9ydCBwZGZQYXJzZSBmcm9tICdwZGYtcGFyc2UnO1xuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRNaW1lVHlwZSA9IFxuICB8ICdhcHBsaWNhdGlvbi9wZGYnXG4gIHwgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50J1xuICB8ICd0ZXh0L3BsYWluJztcblxuLyoqXG4gKiBFeHRyYWN0IHRleHQgY29udGVudCBmcm9tIHZhcmlvdXMgZG9jdW1lbnQgZm9ybWF0c1xuICogQHBhcmFtIGZpbGVQYXRoIFBhdGggdG8gdGhlIGZpbGVcbiAqIEBwYXJhbSBtaW1ldHlwZSBNSU1FIHR5cGUgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm5zIEV4dHJhY3RlZCB0ZXh0IGNvbnRlbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RUZXh0KGZpbGVQYXRoOiBzdHJpbmcsIG1pbWV0eXBlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIGlmIChtaW1ldHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicpIHtcbiAgICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGRmUGFyc2UoZGF0YUJ1ZmZlcik7XG4gICAgICByZXR1cm4gcmVzdWx0LnRleHQ7XG4gICAgfSBlbHNlIGlmIChtaW1ldHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Jykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXh0cmFjdFRleHRGcm9tRG9jKGZpbGVQYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChtaW1ldHlwZSA9PT0gJ3RleHQvcGxhaW4nKSB7XG4gICAgICByZXR1cm4gZnMucHJvbWlzZXMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGZpbGUgdHlwZTogJHttaW1ldHlwZX1gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZXh0cmFjdGluZyB0ZXh0OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IHRleHQgZnJvbSBkb2N1bWVudDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRleHRGcm9tRG9jKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIC8vIFJlYWQgdGhlIGZpbGUgYXMgYSBidWZmZXJcbiAgICBjb25zdCBmaWxlQnVmZmVyID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUoZmlsZVBhdGgpO1xuICAgIFxuICAgIC8vIFVzZSB0aGUgYnVmZmVyIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHBhdGhcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtYW1tb3RoLmV4dHJhY3RSYXdUZXh0KGZpbGVCdWZmZXIpO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIHRleHQgZnJvbSBET0NYOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IHRleHQgZnJvbSBET0NYIGZpbGU6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgdGV4dCBjb250YWlucyBzdHJ1Y3R1cmVkIGluZm9ybWF0aW9uIGxpa2UgY29tcGFueSB2YWx1ZXMsIGludmVzdG9ycyxcbiAqIGxlYWRlcnNoaXAsIHByaWNpbmcsIG9yIHNhbGVzLXJlbGF0ZWQgY29udGVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0U3RydWN0dXJlZEluZm8odGV4dDogc3RyaW5nKTogeyBcbiAgaGFzQ29tcGFueVZhbHVlczogYm9vbGVhbjsgXG4gIGhhc0ludmVzdG9yczogYm9vbGVhbjtcbiAgaGFzTGVhZGVyc2hpcDogYm9vbGVhbjtcbiAgaGFzUHJpY2luZzogYm9vbGVhbjtcbiAgaGFzUHJvZHVjdEZlYXR1cmVzOiBib29sZWFuO1xuICBoYXNTYWxlc0luZm86IGJvb2xlYW47XG59IHtcbiAgY29uc3QgdGV4dExvd2VyID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICBcbiAgLy8gRGV0ZWN0IGNvbXBhbnkgdmFsdWVzXG4gIGNvbnN0IGhhc0NvbXBhbnlWYWx1ZXMgPSBcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ291ciB2YWx1ZXMnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnY29tcGFueSB2YWx1ZXMnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnY29yZSB2YWx1ZXMnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnb3VyIGN1bHR1cmUnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnY3VsdHVyZScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdtaXNzaW9uIHN0YXRlbWVudCcpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCd2aXNpb24gc3RhdGVtZW50JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3doYXQgd2UgYmVsaWV2ZScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdvdXIgYmVsaWVmcycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdvdXIgbWlzc2lvbicpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdvdXIgdmlzaW9uJyk7XG4gIFxuICAvLyBEZXRlY3QgaW52ZXN0b3IgaW5mb3JtYXRpb25cbiAgY29uc3QgaGFzSW52ZXN0b3JzID1cbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2ludmVzdG9yJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2ludmVzdG9ycycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdmdW5kaW5nJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2JhY2tlZCBieScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdpbnZlc3RtZW50JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3ZlbnR1cmUgY2FwaXRhbCcpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdzZXJpZXMgJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2ZpbmFuY2luZycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdyYWlzZWQnKTtcbiAgXG4gIC8vIERldGVjdCBsZWFkZXJzaGlwIGluZm9ybWF0aW9uXG4gIGNvbnN0IGhhc0xlYWRlcnNoaXAgPVxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnZm91bmRlcicpIHx8IFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnZm91bmRlcnMnKSB8fCBcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2NlbycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdjdG8nKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnY2ZvJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2NoaWVmJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3ByZXNpZGVudCcpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdleGVjdXRpdmUnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnZGlyZWN0b3InKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnaGVhZCBvZicpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdsZWFkJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ21hbmFnZXInKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnbWFuYWdlbWVudCB0ZWFtJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2xlYWRlcnNoaXAgdGVhbScpO1xuXG4gIC8vIERldGVjdCBwcmljaW5nIGluZm9ybWF0aW9uXG4gIGNvbnN0IGhhc1ByaWNpbmcgPVxuICAgIHRleHRMb3dlci5pbmNsdWRlcygncHJpY2luZycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdwcmljZScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdjb3N0JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3N1YnNjcmlwdGlvbicpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCd0aWVyJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3BsYW4nKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygncGFja2FnZScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdmZWUnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnJCAnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnZG9sbGFyJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3BlciBtb250aCcpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdwZXIgeWVhcicpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdtb250aGx5JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2FubnVhbGx5JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2ZyZWUgdHJpYWwnKTtcblxuICAvLyBEZXRlY3QgcHJvZHVjdCBmZWF0dXJlc1xuICBjb25zdCBoYXNQcm9kdWN0RmVhdHVyZXMgPVxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnZmVhdHVyZScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdiZW5lZml0cycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdjYXBhYmlsaXRpZXMnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnZnVuY3Rpb25hbGl0eScpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdtb2R1bGUnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnY29tcG9uZW50JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ2hvdyBpdCB3b3JrcycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCd3aGF0IGl0IGRvZXMnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnb3VyIHByb2R1Y3QnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygncGxhdGZvcm0nKTtcblxuICAvLyBEZXRlY3Qgc2FsZXMtc3BlY2lmaWMgaW5mb3JtYXRpb25cbiAgY29uc3QgaGFzU2FsZXNJbmZvID1cbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3NhbGVzIHBpdGNoJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3BpdGNoIGRlY2snKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygndmFsdWUgcHJvcG9zaXRpb24nKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnd2h5IGNob29zZSB1cycpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdjb21wZXRpdG9yJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3ZzLicpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCd2ZXJzdXMnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygnY29tcGFyaXNvbicpIHx8XG4gICAgdGV4dExvd2VyLmluY2x1ZGVzKCdjYXNlIHN0dWR5JykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3N1Y2Nlc3Mgc3RvcnknKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygndGVzdGltb25pYWwnKSB8fFxuICAgIHRleHRMb3dlci5pbmNsdWRlcygncm9pJykgfHxcbiAgICB0ZXh0TG93ZXIuaW5jbHVkZXMoJ3JldHVybiBvbiBpbnZlc3RtZW50Jyk7XG4gIFxuICByZXR1cm4geyBcbiAgICBoYXNDb21wYW55VmFsdWVzLCBcbiAgICBoYXNJbnZlc3RvcnMsXG4gICAgaGFzTGVhZGVyc2hpcCxcbiAgICBoYXNQcmljaW5nLFxuICAgIGhhc1Byb2R1Y3RGZWF0dXJlcyxcbiAgICBoYXNTYWxlc0luZm9cbiAgfTtcbn1cblxuLyoqXG4gKiBTcGxpdCB0ZXh0IGludG8gY2h1bmtzIG9mIGFwcHJveGltYXRlbHkgdGhlIHNwZWNpZmllZCBzaXplXG4gKiBFbmhhbmNlZCB0byBwcmVzZXJ2ZSBjb250ZXh0IGFuZCBzdHJ1Y3R1cmVkIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gdGV4dCBUZXh0IHRvIHNwbGl0XG4gKiBAcGFyYW0gY2h1bmtTaXplIFRhcmdldCBzaXplIGZvciBlYWNoIGNodW5rXG4gKiBAcGFyYW0gc291cmNlIE9wdGlvbmFsIHNvdXJjZSBtZXRhZGF0YSBmb3IgY29udGV4dC1hd2FyZSBjaHVua2luZ1xuICogQHJldHVybnMgQXJyYXkgb2YgdGV4dCBjaHVua3Mgd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRJbnRvQ2h1bmtzKFxuICB0ZXh0OiBzdHJpbmcsIFxuICBjaHVua1NpemU6IG51bWJlciA9IDUwMCxcbiAgc291cmNlPzogc3RyaW5nXG4pOiBBcnJheTx7IHRleHQ6IHN0cmluZzsgbWV0YWRhdGE/OiB7IGlzU3RydWN0dXJlZD86IGJvb2xlYW47IGluZm9UeXBlPzogc3RyaW5nOyB9IH0+IHtcbiAgLy8gUmVtb3ZlIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gIGNvbnN0IGNsZWFuZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICBcbiAgaWYgKGNsZWFuZWRUZXh0Lmxlbmd0aCA8PSBjaHVua1NpemUpIHtcbiAgICAvLyBGb3Igc21hbGwgdGV4dCwgY2hlY2sgaWYgaXQgY29udGFpbnMgc3RydWN0dXJlZCBpbmZvcm1hdGlvblxuICAgIGNvbnN0IHN0cnVjdHVyZWRJbmZvID0gZGV0ZWN0U3RydWN0dXJlZEluZm8oY2xlYW5lZFRleHQpO1xuICAgIGNvbnN0IG1ldGFkYXRhOiB7IGlzU3RydWN0dXJlZD86IGJvb2xlYW47IGluZm9UeXBlPzogc3RyaW5nIH0gPSB7fTtcbiAgICBcbiAgICBpZiAoc3RydWN0dXJlZEluZm8uaGFzQ29tcGFueVZhbHVlcyB8fCBzdHJ1Y3R1cmVkSW5mby5oYXNJbnZlc3RvcnMgfHwgc3RydWN0dXJlZEluZm8uaGFzTGVhZGVyc2hpcCB8fFxuICAgICAgICBzdHJ1Y3R1cmVkSW5mby5oYXNQcmljaW5nIHx8IHN0cnVjdHVyZWRJbmZvLmhhc1Byb2R1Y3RGZWF0dXJlcyB8fCBzdHJ1Y3R1cmVkSW5mby5oYXNTYWxlc0luZm8pIHtcbiAgICAgIG1ldGFkYXRhLmlzU3RydWN0dXJlZCA9IHRydWU7XG4gICAgICBcbiAgICAgIGlmIChzdHJ1Y3R1cmVkSW5mby5oYXNDb21wYW55VmFsdWVzKSB7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ2NvbXBhbnlfdmFsdWVzJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzSW52ZXN0b3JzKSB7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ2ludmVzdG9ycyc7XG4gICAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc0xlYWRlcnNoaXApIHtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAnbGVhZGVyc2hpcCc7XG4gICAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc1ByaWNpbmcpIHtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAncHJpY2luZyc7XG4gICAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc1Byb2R1Y3RGZWF0dXJlcykge1xuICAgICAgICBtZXRhZGF0YS5pbmZvVHlwZSA9ICdwcm9kdWN0X2ZlYXR1cmVzJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzU2FsZXNJbmZvKSB7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ3NhbGVzX2luZm8nO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gW3sgdGV4dDogY2xlYW5lZFRleHQsIG1ldGFkYXRhIH1dO1xuICB9XG5cbiAgLy8gSWYgdGhpcyBpcyBhIGNhcmVlcnMgb3IgYWJvdXQgcGFnZSwgd2UgbWF5IG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xuICBjb25zdCBpc0Fib3V0UGFnZSA9IHNvdXJjZT8uaW5jbHVkZXMoJy9hYm91dCcpIHx8IHNvdXJjZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYWJvdXQgdXMnKTtcbiAgY29uc3QgaXNDYXJlZXJzUGFnZSA9IHNvdXJjZT8uaW5jbHVkZXMoJy9jYXJlZXJzJykgfHwgc291cmNlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjYXJlZXJzJyk7XG4gIFxuICAvLyBGb3IgY2FyZWVyIGFuZCBhYm91dCBwYWdlcywgdHJ5IHRvIGxvY2F0ZSBzZWN0aW9ucyBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICBpZiAoaXNBYm91dFBhZ2UgfHwgaXNDYXJlZXJzUGFnZSkge1xuICAgIHJldHVybiBzcGxpdFN0cnVjdHVyZWRDb250ZW50KGNsZWFuZWRUZXh0LCBjaHVua1NpemUsIHNvdXJjZSk7XG4gIH1cblxuICAvLyBTdGFuZGFyZCBjaHVua2luZyBmb3Igb3RoZXIgY29udGVudFxuICByZXR1cm4gc3BsaXRSZWd1bGFyQ29udGVudChjbGVhbmVkVGV4dCwgY2h1bmtTaXplKTtcbn1cblxuLyoqXG4gKiBTcGxpdCBwb3RlbnRpYWxseSBzdHJ1Y3R1cmVkIGNvbnRlbnQgbGlrZSBhYm91dCBwYWdlcyBhbmQgY2FyZWVycyBwYWdlc1xuICogUHJlc2VydmVzIHNlY3Rpb25zIHJlbGF0ZWQgdG8gY29tcGFueSBpbmZvcm1hdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdFN0cnVjdHVyZWRDb250ZW50KFxuICB0ZXh0OiBzdHJpbmcsXG4gIGNodW5rU2l6ZTogbnVtYmVyLFxuICBzb3VyY2U/OiBzdHJpbmdcbik6IEFycmF5PHsgdGV4dDogc3RyaW5nOyBtZXRhZGF0YT86IHsgaXNTdHJ1Y3R1cmVkPzogYm9vbGVhbjsgaW5mb1R5cGU/OiBzdHJpbmc7IH0gfT4ge1xuICBjb25zdCBjaHVua3M6IEFycmF5PHsgdGV4dDogc3RyaW5nOyBtZXRhZGF0YT86IHsgaXNTdHJ1Y3R1cmVkPzogYm9vbGVhbjsgaW5mb1R5cGU/OiBzdHJpbmc7IH0gfT4gPSBbXTtcbiAgXG4gIC8vIFRyeSB0byBpZGVudGlmeSBzZWN0aW9ucyBpbiB0aGUgdGV4dFxuICBjb25zdCBzZWN0aW9ucyA9IGlkZW50aWZ5U2VjdGlvbnModGV4dCk7XG4gIFxuICAvLyBJZiB3ZSBpZGVudGlmaWVkIHN0cnVjdHVyZWQgc2VjdGlvbnMsIHByb2Nlc3MgdGhlbSBzcGVjaWFsbHlcbiAgaWYgKHNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHN0cnVjdHVyZWRJbmZvID0gZGV0ZWN0U3RydWN0dXJlZEluZm8oc2VjdGlvbi50ZXh0KTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhOiB7IGlzU3RydWN0dXJlZD86IGJvb2xlYW47IGluZm9UeXBlPzogc3RyaW5nIH0gPSB7fTtcbiAgICAgIFxuICAgICAgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc0NvbXBhbnlWYWx1ZXMpIHtcbiAgICAgICAgbWV0YWRhdGEuaXNTdHJ1Y3R1cmVkID0gdHJ1ZTtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAnY29tcGFueV92YWx1ZXMnO1xuICAgICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkSW5mby5oYXNJbnZlc3RvcnMpIHtcbiAgICAgICAgbWV0YWRhdGEuaXNTdHJ1Y3R1cmVkID0gdHJ1ZTtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAnaW52ZXN0b3JzJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzTGVhZGVyc2hpcCkge1xuICAgICAgICBtZXRhZGF0YS5pc1N0cnVjdHVyZWQgPSB0cnVlO1xuICAgICAgICBtZXRhZGF0YS5pbmZvVHlwZSA9ICdsZWFkZXJzaGlwJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzUHJpY2luZykge1xuICAgICAgICBtZXRhZGF0YS5pc1N0cnVjdHVyZWQgPSB0cnVlO1xuICAgICAgICBtZXRhZGF0YS5pbmZvVHlwZSA9ICdwcmljaW5nJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzUHJvZHVjdEZlYXR1cmVzKSB7XG4gICAgICAgIG1ldGFkYXRhLmlzU3RydWN0dXJlZCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ3Byb2R1Y3RfZmVhdHVyZXMnO1xuICAgICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkSW5mby5oYXNTYWxlc0luZm8pIHtcbiAgICAgICAgbWV0YWRhdGEuaXNTdHJ1Y3R1cmVkID0gdHJ1ZTtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAnc2FsZXNfaW5mbyc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJ1Y3R1cmVkIHNlY3Rpb24sIHRyeSB0byBrZWVwIGl0IGludGFjdCBpZiBwb3NzaWJsZVxuICAgICAgaWYgKG1ldGFkYXRhLmlzU3RydWN0dXJlZCAmJiBzZWN0aW9uLnRleHQubGVuZ3RoIDw9IGNodW5rU2l6ZSAqIDEuNSkge1xuICAgICAgICBjaHVua3MucHVzaCh7IHRleHQ6IHNlY3Rpb24udGV4dCwgbWV0YWRhdGEgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0b28gbGFyZ2UsIHNwbGl0IGJ1dCBwcmVzZXJ2ZSB0aGUgbWV0YWRhdGFcbiAgICAgICAgY29uc3Qgc2VjdGlvbkNodW5rcyA9IHNwbGl0UmVndWxhckNvbnRlbnQoc2VjdGlvbi50ZXh0LCBjaHVua1NpemUpO1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHNlY3Rpb25DaHVua3MpIHtcbiAgICAgICAgICBpZiAobWV0YWRhdGEuaXNTdHJ1Y3R1cmVkKSB7XG4gICAgICAgICAgICBjaHVuay5tZXRhZGF0YSA9IHsgLi4ubWV0YWRhdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjaHVua3M7XG4gIH1cbiAgXG4gIC8vIElmIHdlIGNvdWxkbid0IGlkZW50aWZ5IHN0cnVjdHVyZWQgc2VjdGlvbnMsIGZhbGwgYmFjayB0byByZWd1bGFyIGNodW5raW5nXG4gIHJldHVybiBzcGxpdFJlZ3VsYXJDb250ZW50KHRleHQsIGNodW5rU2l6ZSk7XG59XG5cbi8qKlxuICogSWRlbnRpZnkgcG90ZW50aWFsIHNlY3Rpb25zIGluIHRleHQgYmFzZWQgb24gaGVhZGluZ3MgYW5kIHBhdHRlcm5zXG4gKi9cbmZ1bmN0aW9uIGlkZW50aWZ5U2VjdGlvbnModGV4dDogc3RyaW5nKTogQXJyYXk8eyB0ZXh0OiBzdHJpbmc7IHR5cGU/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBzZWN0aW9uczogQXJyYXk8eyB0ZXh0OiBzdHJpbmc7IHR5cGU/OiBzdHJpbmcgfT4gPSBbXTtcbiAgXG4gIC8vIENvbW1vbiBzZWN0aW9uIGluZGljYXRvcnNcbiAgY29uc3Qgc2VjdGlvbkluZGljYXRvcnMgPSBbXG4gICAgJ291ciB2YWx1ZXMnLCAnY29tcGFueSB2YWx1ZXMnLCAnb3VyIGludmVzdG9ycycsICdvdXIgbWlzc2lvbicsXG4gICAgJ2xlYWRlcnNoaXAnLCAndGVhbScsICdhYm91dCB1cycsICdvdXIgc3RvcnknLCAndmlzaW9uJyxcbiAgICAnd2hhdCB3ZSBkbycsICd3aG8gd2UgYXJlJywgJ291ciBpbnZlc3RvcnMnXG4gIF07XG4gIFxuICAvLyBUcnkgdG8gc3BsaXQgYnkgY29tbW9uIGhlYWRpbmdzIGFuZCBpbmRpY2F0b3JzXG4gIGxldCByZW1haW5pbmdUZXh0ID0gdGV4dDtcbiAgXG4gIC8vIEZpcnN0IHBhc3M6IExvb2sgZm9yIHNlY3Rpb24gaGVhZGluZ3NcbiAgZm9yIChjb25zdCBpbmRpY2F0b3Igb2Ygc2VjdGlvbkluZGljYXRvcnMpIHtcbiAgICBjb25zdCBpbmRpY2F0b3JSZWdleCA9IG5ldyBSZWdFeHAoYChefFxcXFxzKSR7aW5kaWNhdG9yfVs6XFxcXHNdYCwgJ2knKTtcbiAgICBjb25zdCBtYXRjaCA9IHJlbWFpbmluZ1RleHQubWF0Y2goaW5kaWNhdG9yUmVnZXgpO1xuICAgIFxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IHNlY3Rpb24gaW5kaWNhdG9yIGFmdGVyIHRoaXMgb25lXG4gICAgICBsZXQgbmV4dEluZGV4ID0gcmVtYWluaW5nVGV4dC5sZW5ndGg7XG4gICAgICBmb3IgKGNvbnN0IG5leHRJbmRpY2F0b3Igb2Ygc2VjdGlvbkluZGljYXRvcnMpIHtcbiAgICAgICAgaWYgKG5leHRJbmRpY2F0b3IgPT09IGluZGljYXRvcikgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBuZXh0UmVnZXggPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke25leHRJbmRpY2F0b3J9WzpcXFxcc11gLCAnaScpO1xuICAgICAgICBjb25zdCBuZXh0TWF0Y2ggPSByZW1haW5pbmdUZXh0LnNsaWNlKG1hdGNoLmluZGV4ICsgaW5kaWNhdG9yLmxlbmd0aCkubWF0Y2gobmV4dFJlZ2V4KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChuZXh0TWF0Y2ggJiYgbmV4dE1hdGNoLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBNYXRoLm1pbihuZXh0SW5kZXgsIG1hdGNoLmluZGV4ICsgaW5kaWNhdG9yLmxlbmd0aCArIG5leHRNYXRjaC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCB0aGlzIHNlY3Rpb25cbiAgICAgIGNvbnN0IHNlY3Rpb25UZXh0ID0gcmVtYWluaW5nVGV4dC5zbGljZShcbiAgICAgICAgTWF0aC5tYXgoMCwgbWF0Y2guaW5kZXggLSAyMCksIC8vIEluY2x1ZGUgc29tZSBjb250ZXh0IGJlZm9yZVxuICAgICAgICBuZXh0SW5kZXggKyAyMCAvLyBJbmNsdWRlIHNvbWUgY29udGV4dCBhZnRlclxuICAgICAgKS50cmltKCk7XG4gICAgICBcbiAgICAgIGlmIChzZWN0aW9uVGV4dC5sZW5ndGggPiA1MCkgeyAvLyBFbnN1cmUgaXQncyBhIG1lYW5pbmdmdWwgc2VjdGlvblxuICAgICAgICBzZWN0aW9ucy5wdXNoKHsgdGV4dDogc2VjdGlvblRleHQsIHR5cGU6IGluZGljYXRvciB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIHdlIGRpZG4ndCBmaW5kIHNlY3Rpb25zLCB0cnkgYW5vdGhlciBhcHByb2FjaCB3aXRoIHBhcmFncmFwaCBicmVha3NcbiAgaWYgKHNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IHBhcmFncmFwaHMgPSB0ZXh0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgbGV0IGN1cnJlbnRTZWN0aW9uID0gXCJcIjtcbiAgICBsZXQgY3VycmVudFR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XG4gICAgICBpZiAocGFyYWdyYXBoLnRyaW0oKS5sZW5ndGggPCAxMCkgY29udGludWU7IC8vIFNraXAgdmVyeSBzaG9ydCBwYXJhZ3JhcGhzXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgcGFyYWdyYXBoIHN0YXJ0cyBhIG5ldyBzZWN0aW9uXG4gICAgICBsZXQgZm91bmROZXdTZWN0aW9uID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGluZGljYXRvciBvZiBzZWN0aW9uSW5kaWNhdG9ycykge1xuICAgICAgICBpZiAocGFyYWdyYXBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5kaWNhdG9yKSkge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBjdXJyZW50IHNlY3Rpb24sIGFkZCBpdCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgb25lXG4gICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goeyB0ZXh0OiBjdXJyZW50U2VjdGlvbiwgdHlwZTogY3VycmVudFR5cGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IHNlY3Rpb25cbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9IHBhcmFncmFwaDtcbiAgICAgICAgICBjdXJyZW50VHlwZSA9IGluZGljYXRvcjtcbiAgICAgICAgICBmb3VuZE5ld1NlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIG5vdCBhIG5ldyBzZWN0aW9uLCBhZGQgdG8gY3VycmVudCBzZWN0aW9uXG4gICAgICBpZiAoIWZvdW5kTmV3U2VjdGlvbikge1xuICAgICAgICBpZiAoY3VycmVudFNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uICs9IFwiXFxuXFxuXCIgKyBwYXJhZ3JhcGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFNlY3Rpb24gPSBwYXJhZ3JhcGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHRoZSBmaW5hbCBzZWN0aW9uIGlmIGl0IGV4aXN0c1xuICAgIGlmIChjdXJyZW50U2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKHsgdGV4dDogY3VycmVudFNlY3Rpb24sIHR5cGU6IGN1cnJlbnRUeXBlIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBzZWN0aW9ucywgY3JlYXRlIG9uZSBmb3IgdGhlIHdob2xlIHRleHRcbiAgaWYgKHNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlY3Rpb25zLnB1c2goeyB0ZXh0IH0pO1xuICB9XG4gIFxuICByZXR1cm4gc2VjdGlvbnM7XG59XG5cbi8qKlxuICogU3BsaXQgdGV4dCB1c2luZyB0aGUgc3RhbmRhcmQgY2h1bmtpbmcgYWxnb3JpdGhtXG4gKiBAcGFyYW0gdGV4dCBUZXh0IHRvIHNwbGl0XG4gKiBAcGFyYW0gY2h1bmtTaXplIFRhcmdldCBzaXplIGZvciBlYWNoIGNodW5rXG4gKiBAcmV0dXJucyBBcnJheSBvZiB0ZXh0IGNodW5rc1xuICovXG5mdW5jdGlvbiBzcGxpdFJlZ3VsYXJDb250ZW50KFxuICB0ZXh0OiBzdHJpbmcsXG4gIGNodW5rU2l6ZTogbnVtYmVyXG4pOiBBcnJheTx7IHRleHQ6IHN0cmluZzsgbWV0YWRhdGE/OiB7IGlzU3RydWN0dXJlZD86IGJvb2xlYW47IGluZm9UeXBlPzogc3RyaW5nOyB9IH0+IHtcbiAgY29uc3QgY2h1bmtzOiBBcnJheTx7IHRleHQ6IHN0cmluZzsgbWV0YWRhdGE/OiB7IGlzU3RydWN0dXJlZD86IGJvb2xlYW47IGluZm9UeXBlPzogc3RyaW5nOyB9IH0+ID0gW107XG4gIFxuICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgLy8gR2V0IGEgY2h1bmsgb2YgYXBwcm94aW1hdGVseSB0aGUgdGFyZ2V0IHNpemVcbiAgICBsZXQgY2h1bmsgPSB0ZXh0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIGNodW5rU2l6ZSk7XG4gICAgXG4gICAgLy8gSWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHRleHQsIHRyeSB0byBicmVhayBhdCBhIG5hdHVyYWwgYm91bmRhcnlcbiAgICBpZiAoY3VycmVudEluZGV4ICsgY2h1bmtTaXplIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIC8vIExvb2sgZm9yIHBhcmFncmFwaCBicmVha3MgZmlyc3QgKGlkZWFsIGJyZWFraW5nIHBvaW50KVxuICAgICAgY29uc3QgcGFyYWdyYXBoQnJlYWsgPSBjaHVuay5sYXN0SW5kZXhPZignXFxuXFxuJyk7XG4gICAgICBcbiAgICAgIC8vIFRoZW4gbG9vayBmb3IgdGhlIGxhc3Qgc2VudGVuY2UgYnJlYWsgaW4gdGhpcyBjaHVua1xuICAgICAgY29uc3Qgc2VudGVuY2VCcmVha3MgPSBbXG4gICAgICAgIGNodW5rLmxhc3RJbmRleE9mKCcuICcpLFxuICAgICAgICBjaHVuay5sYXN0SW5kZXhPZignPyAnKSxcbiAgICAgICAgY2h1bmsubGFzdEluZGV4T2YoJyEgJyksXG4gICAgICAgIGNodW5rLmxhc3RJbmRleE9mKCcuXFxuJyksXG4gICAgICAgIGNodW5rLmxhc3RJbmRleE9mKCc/XFxuJyksXG4gICAgICAgIGNodW5rLmxhc3RJbmRleE9mKCchXFxuJylcbiAgICAgIF07XG4gICAgICBjb25zdCBsYXN0U2VudGVuY2VCcmVhayA9IE1hdGgubWF4KC4uLnNlbnRlbmNlQnJlYWtzKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHBhcmFncmFwaCBicmVhayBpZiBhdmFpbGFibGUgYW5kIHJlYXNvbmFibGUsIG90aGVyd2lzZSB1c2Ugc2VudGVuY2UgYnJlYWtcbiAgICAgIGlmIChwYXJhZ3JhcGhCcmVhayA+IGNodW5rU2l6ZSAqIDAuNSkge1xuICAgICAgICBjaHVuayA9IGNodW5rLnN1YnN0cmluZygwLCBwYXJhZ3JhcGhCcmVhayk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTZW50ZW5jZUJyZWFrID4gY2h1bmtTaXplICogMC4zKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZW50ZW5jZSBicmVhayBpcyBhdCBsZWFzdCAzMCUgdGhyb3VnaCB0aGUgY2h1bmtcbiAgICAgICAgY29uc3QgYnJlYWtUeXBlID0gc2VudGVuY2VCcmVha3MuaW5kZXhPZihsYXN0U2VudGVuY2VCcmVhayk7XG4gICAgICAgIC8vIEFkZCAyIHRvIGluY2x1ZGUgdGhlIHBlcmlvZCBhbmQgc3BhY2UvbmV3bGluZVxuICAgICAgICBjaHVuayA9IGNodW5rLnN1YnN0cmluZygwLCBsYXN0U2VudGVuY2VCcmVhayArIChicmVha1R5cGUgPj0gMyA/IDIgOiAyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBjaHVua09iaiB3aXRoIHByb3BlciB0eXBlIHRoYXQgaW5jbHVkZXMgb3B0aW9uYWwgbWV0YWRhdGFcbiAgICBjb25zdCBjaHVua09iajogeyB0ZXh0OiBzdHJpbmc7IG1ldGFkYXRhPzogeyBpc1N0cnVjdHVyZWQ6IGJvb2xlYW47IGluZm9UeXBlPzogc3RyaW5nIH0gfSA9IHsgXG4gICAgICB0ZXh0OiBjaHVuay50cmltKCkgXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCBzdHJ1Y3R1cmVkSW5mbyA9IGRldGVjdFN0cnVjdHVyZWRJbmZvKGNodW5rKTtcbiAgICBcbiAgICBpZiAoc3RydWN0dXJlZEluZm8uaGFzQ29tcGFueVZhbHVlcyB8fCBzdHJ1Y3R1cmVkSW5mby5oYXNJbnZlc3RvcnMgfHwgc3RydWN0dXJlZEluZm8uaGFzTGVhZGVyc2hpcCB8fFxuICAgICAgICBzdHJ1Y3R1cmVkSW5mby5oYXNQcmljaW5nIHx8IHN0cnVjdHVyZWRJbmZvLmhhc1Byb2R1Y3RGZWF0dXJlcyB8fCBzdHJ1Y3R1cmVkSW5mby5oYXNTYWxlc0luZm8pIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhOiB7IGlzU3RydWN0dXJlZDogYm9vbGVhbjsgaW5mb1R5cGU/OiBzdHJpbmcgfSA9IHsgaXNTdHJ1Y3R1cmVkOiB0cnVlIH07XG4gICAgICBcbiAgICAgIGlmIChzdHJ1Y3R1cmVkSW5mby5oYXNDb21wYW55VmFsdWVzKSB7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ2NvbXBhbnlfdmFsdWVzJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzSW52ZXN0b3JzKSB7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ2ludmVzdG9ycyc7XG4gICAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc0xlYWRlcnNoaXApIHtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAnbGVhZGVyc2hpcCc7XG4gICAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc1ByaWNpbmcpIHtcbiAgICAgICAgbWV0YWRhdGEuaW5mb1R5cGUgPSAncHJpY2luZyc7XG4gICAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRJbmZvLmhhc1Byb2R1Y3RGZWF0dXJlcykge1xuICAgICAgICBtZXRhZGF0YS5pbmZvVHlwZSA9ICdwcm9kdWN0X2ZlYXR1cmVzJztcbiAgICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZEluZm8uaGFzU2FsZXNJbmZvKSB7XG4gICAgICAgIG1ldGFkYXRhLmluZm9UeXBlID0gJ3NhbGVzX2luZm8nO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjaHVua09iai5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIH1cbiAgICBcbiAgICBjaHVua3MucHVzaChjaHVua09iaik7XG4gICAgY3VycmVudEluZGV4ICs9IGNodW5rLmxlbmd0aDtcbiAgICBcbiAgICAvLyBBZGQgc2xpZ2h0IG92ZXJsYXAgZm9yIGNvbnRleHQgaWYgbmVlZGVkXG4gICAgaWYgKGN1cnJlbnRJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYXN0U2VudGVuY2UgPSBmaW5kTGFzdFNlbnRlbmNlKGNodW5rKTtcbiAgICAgIGlmIChsYXN0U2VudGVuY2UgJiYgbGFzdFNlbnRlbmNlLmxlbmd0aCA8IGNodW5rU2l6ZSAqIDAuMikge1xuICAgICAgICBjdXJyZW50SW5kZXggLT0gbGFzdFNlbnRlbmNlLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGxhc3QgY29tcGxldGUgc2VudGVuY2UgaW4gYSB0ZXh0XG4gKi9cbmZ1bmN0aW9uIGZpbmRMYXN0U2VudGVuY2UodGV4dDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHNlbnRlbmNlcyA9IHRleHQubWF0Y2goL1teLiE/XStbLiE/XSsvZyk7XG4gIGlmIChzZW50ZW5jZXMgJiYgc2VudGVuY2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gc2VudGVuY2VzW3NlbnRlbmNlcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0gIl0sIm5hbWVzIjpbImZzIiwibWFtbW90aCIsInBkZlBhcnNlIiwiZXh0cmFjdFRleHQiLCJmaWxlUGF0aCIsIm1pbWV0eXBlIiwiZGF0YUJ1ZmZlciIsInJlYWRGaWxlU3luYyIsInJlc3VsdCIsInRleHQiLCJleHRyYWN0VGV4dEZyb21Eb2MiLCJwcm9taXNlcyIsInJlYWRGaWxlIiwiRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlIiwiU3RyaW5nIiwiZmlsZUJ1ZmZlciIsImV4dHJhY3RSYXdUZXh0IiwidmFsdWUiLCJkZXRlY3RTdHJ1Y3R1cmVkSW5mbyIsInRleHRMb3dlciIsInRvTG93ZXJDYXNlIiwiaGFzQ29tcGFueVZhbHVlcyIsImluY2x1ZGVzIiwiaGFzSW52ZXN0b3JzIiwiaGFzTGVhZGVyc2hpcCIsImhhc1ByaWNpbmciLCJoYXNQcm9kdWN0RmVhdHVyZXMiLCJoYXNTYWxlc0luZm8iLCJzcGxpdEludG9DaHVua3MiLCJjaHVua1NpemUiLCJzb3VyY2UiLCJjbGVhbmVkVGV4dCIsInJlcGxhY2UiLCJ0cmltIiwibGVuZ3RoIiwic3RydWN0dXJlZEluZm8iLCJtZXRhZGF0YSIsImlzU3RydWN0dXJlZCIsImluZm9UeXBlIiwiaXNBYm91dFBhZ2UiLCJpc0NhcmVlcnNQYWdlIiwic3BsaXRTdHJ1Y3R1cmVkQ29udGVudCIsInNwbGl0UmVndWxhckNvbnRlbnQiLCJjaHVua3MiLCJzZWN0aW9ucyIsImlkZW50aWZ5U2VjdGlvbnMiLCJzZWN0aW9uIiwicHVzaCIsInNlY3Rpb25DaHVua3MiLCJjaHVuayIsInNlY3Rpb25JbmRpY2F0b3JzIiwicmVtYWluaW5nVGV4dCIsImluZGljYXRvciIsImluZGljYXRvclJlZ2V4IiwiUmVnRXhwIiwibWF0Y2giLCJpbmRleCIsInVuZGVmaW5lZCIsIm5leHRJbmRleCIsIm5leHRJbmRpY2F0b3IiLCJuZXh0UmVnZXgiLCJuZXh0TWF0Y2giLCJzbGljZSIsIk1hdGgiLCJtaW4iLCJzZWN0aW9uVGV4dCIsIm1heCIsInR5cGUiLCJwYXJhZ3JhcGhzIiwic3BsaXQiLCJjdXJyZW50U2VjdGlvbiIsImN1cnJlbnRUeXBlIiwicGFyYWdyYXBoIiwiZm91bmROZXdTZWN0aW9uIiwiY3VycmVudEluZGV4Iiwic3Vic3RyaW5nIiwicGFyYWdyYXBoQnJlYWsiLCJsYXN0SW5kZXhPZiIsInNlbnRlbmNlQnJlYWtzIiwibGFzdFNlbnRlbmNlQnJlYWsiLCJicmVha1R5cGUiLCJpbmRleE9mIiwiY2h1bmtPYmoiLCJsYXN0U2VudGVuY2UiLCJmaW5kTGFzdFNlbnRlbmNlIiwic2VudGVuY2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/documentProcessing.ts\n");

/***/ }),

/***/ "(api)/./utils/enhancedRetrieval.ts":
/*!************************************!*\
  !*** ./utils/enhancedRetrieval.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_ENHANCED_RETRIEVAL_CONFIG: () => (/* binding */ DEFAULT_ENHANCED_RETRIEVAL_CONFIG),\n/* harmony export */   EnhancedRetrieval: () => (/* binding */ EnhancedRetrieval)\n/* harmony export */ });\n/* harmony import */ var _bm25__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bm25 */ \"(api)/./utils/bm25.ts\");\n/* harmony import */ var _vectorStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vectorStore */ \"(api)/./utils/vectorStore.ts\");\n/* harmony import */ var _tokenization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokenization */ \"(api)/./utils/tokenization.ts\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_4__);\n/**\n * Enhanced Retrieval System\n * \n * This module integrates BM25 with vector-based similarity search\n * to create a hybrid retrieval approach that improves result quality.\n */ \n\n\n\n\n/**\n * Default configuration for enhanced retrieval\n */ const DEFAULT_ENHANCED_RETRIEVAL_CONFIG = {\n    bm25Weight: 0.3,\n    minBM25Score: 0.01,\n    minVectorScore: 0.6,\n    normalizeScores: true,\n    maxResults: 5,\n    debug: false\n};\n/**\n * Enhanced retrieval system that combines BM25 and vector-based search\n */ class EnhancedRetrieval {\n    /**\n   * Create a new enhanced retrieval system\n   */ constructor(config = {}){\n        this.vectorStore = [];\n        this.corpusStats = null;\n        this.isInitialized = false;\n        this.config = {\n            ...DEFAULT_ENHANCED_RETRIEVAL_CONFIG,\n            ...config\n        };\n    }\n    /**\n   * Load vector store from disk\n   */ async loadVectorStore() {\n        try {\n            const filePath = path__WEBPACK_IMPORTED_MODULE_4___default().join(process.cwd(), \"data\", \"vectorStore.json\");\n            const fileData = await fs_promises__WEBPACK_IMPORTED_MODULE_3___default().readFile(filePath, \"utf8\");\n            const parsedData = JSON.parse(fileData);\n            if (Array.isArray(parsedData)) {\n                return parsedData;\n            } else if (parsedData.items && Array.isArray(parsedData.items)) {\n                return parsedData.items;\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error loading vector store:\", error);\n            return [];\n        }\n    }\n    /**\n   * Initialize the retrieval system\n   * Loads corpus statistics and vector store\n   */ async initialize() {\n        if (this.isInitialized) {\n            return;\n        }\n        try {\n            console.log(\"Initializing enhanced retrieval system...\");\n            // Load corpus statistics for BM25 scoring\n            this.corpusStats = await (0,_bm25__WEBPACK_IMPORTED_MODULE_0__.loadCorpusStatistics)();\n            console.log(`Loaded corpus statistics with ${Object.keys(this.corpusStats.documentFrequency).length} unique terms`);\n            // Load vector store\n            this.vectorStore = await this.loadVectorStore();\n            console.log(`Loaded vector store with ${this.vectorStore.length} items`);\n            this.isInitialized = true;\n            console.log(\"Enhanced retrieval system initialized\");\n        } catch (error) {\n            console.error(\"Error initializing enhanced retrieval system:\", error);\n            throw new Error(\"Failed to initialize enhanced retrieval system\");\n        }\n    }\n    /**\n   * Find similar documents using vector search\n   */ async findSimilarItems(query, options) {\n        // Implement a simplified version of vector search\n        // In a real implementation, this would use embedding API\n        // This is a mock implementation as we can't directly call the existing function\n        // Replace this with the actual embedding and vector search in production\n        const results = (0,_vectorStore__WEBPACK_IMPORTED_MODULE_1__.getSimilarItems)(// Mock embedding - in production, get this from OpenAI API\n        Array(1536).fill(0).map(()=>Math.random() - 0.5), options.maxResults, query);\n        return results.map((result)=>({\n                item: result,\n                score: result.score\n            }));\n    }\n    /**\n   * Find documents using the enhanced retrieval approach\n   */ async findSimilarDocuments(query, options = {}) {\n        // Ensure system is initialized\n        if (!this.isInitialized) {\n            await this.initialize();\n        }\n        // Apply options to config\n        const config = {\n            ...this.config,\n            ...options\n        };\n        if (config.debug) {\n            console.log(`Searching for: \"${query}\"`);\n            console.log(`Tokenized query: [${(0,_tokenization__WEBPACK_IMPORTED_MODULE_2__.tokenize)(query).join(\", \")}]`);\n        }\n        // Step 1: Get vector search results\n        const vectorResults = await this.findSimilarItems(query, {\n            minSimilarity: config.minVectorScore,\n            maxResults: config.maxResults * 2 // Get more results initially for re-ranking\n        });\n        if (config.debug) {\n            console.log(`Vector search returned ${vectorResults.length} results`);\n        }\n        // If no vector results or BM25 weight is 0, return vector results\n        if (vectorResults.length === 0 || config.bm25Weight === 0) {\n            return vectorResults.map((result)=>({\n                    item: result.item,\n                    bm25Score: 0,\n                    vectorScore: result.score,\n                    combinedScore: result.score\n                })).slice(0, config.maxResults);\n        }\n        // Step 2: Calculate BM25 scores for vector results\n        const enhancedResults = [];\n        for (const result of vectorResults){\n            const document = {\n                id: result.item.metadata?.source || \"unknown\",\n                text: result.item.text\n            };\n            const bm25Score = (0,_bm25__WEBPACK_IMPORTED_MODULE_0__.calculateBM25Score)(query, document, this.corpusStats);\n            // Skip if BM25 score is below threshold\n            if (bm25Score < config.minBM25Score && config.bm25Weight > 0) {\n                continue;\n            }\n            // Normalize scores if enabled\n            let normalizedBM25 = bm25Score;\n            let normalizedVector = result.score;\n            // Calculate combined score\n            const combinedScore = (0,_bm25__WEBPACK_IMPORTED_MODULE_0__.combineScores)(normalizedBM25, normalizedVector, config.bm25Weight);\n            enhancedResults.push({\n                item: result.item,\n                bm25Score,\n                vectorScore: result.score,\n                combinedScore\n            });\n        }\n        // Sort by combined score\n        enhancedResults.sort((a, b)=>b.combinedScore - a.combinedScore);\n        // Apply maximum results limit\n        const finalResults = enhancedResults.slice(0, config.maxResults);\n        if (config.debug) {\n            console.log(`Enhanced retrieval returned ${finalResults.length} results`);\n            finalResults.forEach((result, i)=>{\n                console.log(`Result ${i + 1}: Combined score ${result.combinedScore.toFixed(4)} (Vector: ${result.vectorScore.toFixed(4)}, BM25: ${result.bm25Score.toFixed(4)})`);\n            });\n        }\n        return finalResults;\n    }\n    /**\n   * Get document text from results for context generation\n   */ async getContextFromResults(results) {\n        return results.map((result)=>{\n            // Include metadata if available\n            const source = result.item.metadata?.source ? `Source: ${result.item.metadata.source}\\n` : \"\";\n            // Return formatted context\n            return `${source}${result.item.text}\\n\\n`;\n        }).join(\"---\\n\\n\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxTQUFTLENBQUNtQixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDaks7UUFDRjtRQUVBLE9BQU9IO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE1BQU1JLHNCQUFzQi9CLE9BQWtDLEVBQW1CO1FBQy9FLE9BQU9BLFFBQVFFLEdBQUcsQ0FBQ0csQ0FBQUE7WUFDakIsZ0NBQWdDO1lBQ2hDLE1BQU1jLFNBQVNkLE9BQU9DLElBQUksQ0FBQ1ksUUFBUSxFQUFFQyxTQUNqQyxDQUFDLFFBQVEsRUFBRWQsT0FBT0MsSUFBSSxDQUFDWSxRQUFRLENBQUNDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FDMUM7WUFFSiwyQkFBMkI7WUFDM0IsT0FBTyxDQUFDLEVBQUVBLE9BQU8sRUFBRWQsT0FBT0MsSUFBSSxDQUFDYyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzNDLEdBQUczQyxJQUFJLENBQUM7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtY2hhdC1vcGVuYWktcmFnLy4vdXRpbHMvZW5oYW5jZWRSZXRyaWV2YWwudHM/YTkzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuaGFuY2VkIFJldHJpZXZhbCBTeXN0ZW1cbiAqIFxuICogVGhpcyBtb2R1bGUgaW50ZWdyYXRlcyBCTTI1IHdpdGggdmVjdG9yLWJhc2VkIHNpbWlsYXJpdHkgc2VhcmNoXG4gKiB0byBjcmVhdGUgYSBoeWJyaWQgcmV0cmlldmFsIGFwcHJvYWNoIHRoYXQgaW1wcm92ZXMgcmVzdWx0IHF1YWxpdHkuXG4gKi9cblxuaW1wb3J0IHsgbG9hZENvcnB1c1N0YXRpc3RpY3MsIGNhbGN1bGF0ZUJNMjVTY29yZSwgY29tYmluZVNjb3JlcywgRG9jdW1lbnQgfSBmcm9tICcuL2JtMjUnO1xuaW1wb3J0IHsgY29zaW5lU2ltaWxhcml0eSwgVmVjdG9yU3RvcmVJdGVtLCBnZXRTaW1pbGFySXRlbXMgfSBmcm9tICcuL3ZlY3RvclN0b3JlJztcbmltcG9ydCB7IHRva2VuaXplIH0gZnJvbSAnLi90b2tlbml6YXRpb24nO1xuaW1wb3J0IGZzIGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vLyBSZS1leHBvcnQgZm9yIGVhc2llciBpbXBvcnRpbmdcbmV4cG9ydCB0eXBlIHsgRG9jdW1lbnQsIFZlY3RvclN0b3JlSXRlbSB9O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGVuaGFuY2VkIHJldHJpZXZhbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkUmV0cmlldmFsQ29uZmlnIHtcbiAgLy8gV2VpZ2h0IGZvciBCTTI1IHNjb3JlICgwLjAgdG8gMS4wKVxuICAvLyAwLjAgPSBwdXJlIHZlY3RvciBzZWFyY2gsIDEuMCA9IHB1cmUgQk0yNSBzZWFyY2hcbiAgYm0yNVdlaWdodDogbnVtYmVyO1xuICBcbiAgLy8gTWluaW11bSBCTTI1IHNjb3JlIHRvIGNvbnNpZGVyIGEgZG9jdW1lbnQgcmVsZXZhbnRcbiAgLy8gSGVscHMgZmlsdGVyIG91dCBsb3ctcXVhbGl0eSBtYXRjaGVzXG4gIG1pbkJNMjVTY29yZTogbnVtYmVyO1xuICBcbiAgLy8gTWluaW11bSB2ZWN0b3Igc2ltaWxhcml0eSB0byBjb25zaWRlciBhIGRvY3VtZW50IHJlbGV2YW50XG4gIG1pblZlY3RvclNjb3JlOiBudW1iZXI7XG4gIFxuICAvLyBXaGV0aGVyIHRvIG5vcm1hbGl6ZSBzY29yZXMgYmVmb3JlIGNvbWJpbmluZ1xuICAvLyBSZWNvbW1lbmRlZCB0byBrZWVwIHRoaXMgdHJ1ZVxuICBub3JtYWxpemVTY29yZXM6IGJvb2xlYW47XG4gIFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0dXJuXG4gIG1heFJlc3VsdHM6IG51bWJlcjtcbiAgXG4gIC8vIFdoZXRoZXIgdG8gbG9nIGRldGFpbGVkIHNjb3JpbmcgaW5mb3JtYXRpb25cbiAgZGVidWc6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBlbmhhbmNlZCByZXRyaWV2YWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfRU5IQU5DRURfUkVUUklFVkFMX0NPTkZJRzogRW5oYW5jZWRSZXRyaWV2YWxDb25maWcgPSB7XG4gIGJtMjVXZWlnaHQ6IDAuMyxcbiAgbWluQk0yNVNjb3JlOiAwLjAxLFxuICBtaW5WZWN0b3JTY29yZTogMC42LFxuICBub3JtYWxpemVTY29yZXM6IHRydWUsXG4gIG1heFJlc3VsdHM6IDUsXG4gIGRlYnVnOiBmYWxzZVxufTtcblxuLyoqXG4gKiBSZXN1bHQgaXRlbSBmb3IgZW5oYW5jZWQgcmV0cmlldmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZWRSZXRyaWV2YWxSZXN1bHQge1xuICBpdGVtOiBWZWN0b3JTdG9yZUl0ZW07XG4gIGJtMjVTY29yZTogbnVtYmVyO1xuICB2ZWN0b3JTY29yZTogbnVtYmVyO1xuICBjb21iaW5lZFNjb3JlOiBudW1iZXI7XG59XG5cbi8qKlxuICogVmVjdG9yIHNlYXJjaCByZXN1bHQgZm9ybWF0XG4gKi9cbmludGVyZmFjZSBWZWN0b3JTZWFyY2hSZXN1bHQge1xuICBpdGVtOiBWZWN0b3JTdG9yZUl0ZW07XG4gIHNjb3JlOiBudW1iZXI7XG59XG5cbi8qKlxuICogRW5oYW5jZWQgcmV0cmlldmFsIHN5c3RlbSB0aGF0IGNvbWJpbmVzIEJNMjUgYW5kIHZlY3Rvci1iYXNlZCBzZWFyY2hcbiAqL1xuZXhwb3J0IGNsYXNzIEVuaGFuY2VkUmV0cmlldmFsIHtcbiAgcHJpdmF0ZSB2ZWN0b3JTdG9yZTogVmVjdG9yU3RvcmVJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBjb3JwdXNTdGF0czogYW55ID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgY29uZmlnOiBFbmhhbmNlZFJldHJpZXZhbENvbmZpZztcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZW5oYW5jZWQgcmV0cmlldmFsIHN5c3RlbVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPEVuaGFuY2VkUmV0cmlldmFsQ29uZmlnPiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLkRFRkFVTFRfRU5IQU5DRURfUkVUUklFVkFMX0NPTkZJRywgLi4uY29uZmlnIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBMb2FkIHZlY3RvciBzdG9yZSBmcm9tIGRpc2tcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZFZlY3RvclN0b3JlKCk6IFByb21pc2U8VmVjdG9yU3RvcmVJdGVtW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2RhdGEnLCAndmVjdG9yU3RvcmUuanNvbicpO1xuICAgICAgY29uc3QgZmlsZURhdGEgPSBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGZpbGVEYXRhKTtcbiAgICAgIFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlZERhdGEuaXRlbXMgJiYgQXJyYXkuaXNBcnJheShwYXJzZWREYXRhLml0ZW1zKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VkRGF0YS5pdGVtcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHZlY3RvciBzdG9yZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcmV0cmlldmFsIHN5c3RlbVxuICAgKiBMb2FkcyBjb3JwdXMgc3RhdGlzdGljcyBhbmQgdmVjdG9yIHN0b3JlXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgZW5oYW5jZWQgcmV0cmlldmFsIHN5c3RlbS4uLicpO1xuICAgICAgXG4gICAgICAvLyBMb2FkIGNvcnB1cyBzdGF0aXN0aWNzIGZvciBCTTI1IHNjb3JpbmdcbiAgICAgIHRoaXMuY29ycHVzU3RhdHMgPSBhd2FpdCBsb2FkQ29ycHVzU3RhdGlzdGljcygpO1xuICAgICAgY29uc29sZS5sb2coYExvYWRlZCBjb3JwdXMgc3RhdGlzdGljcyB3aXRoICR7T2JqZWN0LmtleXModGhpcy5jb3JwdXNTdGF0cy5kb2N1bWVudEZyZXF1ZW5jeSkubGVuZ3RofSB1bmlxdWUgdGVybXNgKTtcbiAgICAgIFxuICAgICAgLy8gTG9hZCB2ZWN0b3Igc3RvcmVcbiAgICAgIHRoaXMudmVjdG9yU3RvcmUgPSBhd2FpdCB0aGlzLmxvYWRWZWN0b3JTdG9yZSgpO1xuICAgICAgY29uc29sZS5sb2coYExvYWRlZCB2ZWN0b3Igc3RvcmUgd2l0aCAke3RoaXMudmVjdG9yU3RvcmUubGVuZ3RofSBpdGVtc2ApO1xuICAgICAgXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ0VuaGFuY2VkIHJldHJpZXZhbCBzeXN0ZW0gaW5pdGlhbGl6ZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGVuaGFuY2VkIHJldHJpZXZhbCBzeXN0ZW06JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBlbmhhbmNlZCByZXRyaWV2YWwgc3lzdGVtJyk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmluZCBzaW1pbGFyIGRvY3VtZW50cyB1c2luZyB2ZWN0b3Igc2VhcmNoXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGZpbmRTaW1pbGFySXRlbXMocXVlcnk6IHN0cmluZywgb3B0aW9uczogeyBtaW5TaW1pbGFyaXR5OiBudW1iZXIsIG1heFJlc3VsdHM6IG51bWJlciB9KTogUHJvbWlzZTxWZWN0b3JTZWFyY2hSZXN1bHRbXT4ge1xuICAgIC8vIEltcGxlbWVudCBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB2ZWN0b3Igc2VhcmNoXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHVzZSBlbWJlZGRpbmcgQVBJXG4gICAgXG4gICAgLy8gVGhpcyBpcyBhIG1vY2sgaW1wbGVtZW50YXRpb24gYXMgd2UgY2FuJ3QgZGlyZWN0bHkgY2FsbCB0aGUgZXhpc3RpbmcgZnVuY3Rpb25cbiAgICAvLyBSZXBsYWNlIHRoaXMgd2l0aCB0aGUgYWN0dWFsIGVtYmVkZGluZyBhbmQgdmVjdG9yIHNlYXJjaCBpbiBwcm9kdWN0aW9uXG4gICAgY29uc3QgcmVzdWx0cyA9IGdldFNpbWlsYXJJdGVtcyhcbiAgICAgIC8vIE1vY2sgZW1iZWRkaW5nIC0gaW4gcHJvZHVjdGlvbiwgZ2V0IHRoaXMgZnJvbSBPcGVuQUkgQVBJXG4gICAgICBBcnJheSgxNTM2KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KSwgXG4gICAgICBvcHRpb25zLm1heFJlc3VsdHMsXG4gICAgICBxdWVyeVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKHJlc3VsdCA9PiAoe1xuICAgICAgaXRlbTogcmVzdWx0LFxuICAgICAgc2NvcmU6IHJlc3VsdC5zY29yZVxuICAgIH0pKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEZpbmQgZG9jdW1lbnRzIHVzaW5nIHRoZSBlbmhhbmNlZCByZXRyaWV2YWwgYXBwcm9hY2hcbiAgICovXG4gIGFzeW5jIGZpbmRTaW1pbGFyRG9jdW1lbnRzKHF1ZXJ5OiBzdHJpbmcsIG9wdGlvbnM6IFBhcnRpYWw8RW5oYW5jZWRSZXRyaWV2YWxDb25maWc+ID0ge30pOiBQcm9taXNlPEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0W10+IHtcbiAgICAvLyBFbnN1cmUgc3lzdGVtIGlzIGluaXRpYWxpemVkXG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBcHBseSBvcHRpb25zIHRvIGNvbmZpZ1xuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLm9wdGlvbnMgfTtcbiAgICBcbiAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU2VhcmNoaW5nIGZvcjogXCIke3F1ZXJ5fVwiYCk7XG4gICAgICBjb25zb2xlLmxvZyhgVG9rZW5pemVkIHF1ZXJ5OiBbJHt0b2tlbml6ZShxdWVyeSkuam9pbignLCAnKX1dYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0ZXAgMTogR2V0IHZlY3RvciBzZWFyY2ggcmVzdWx0c1xuICAgIGNvbnN0IHZlY3RvclJlc3VsdHMgPSBhd2FpdCB0aGlzLmZpbmRTaW1pbGFySXRlbXMocXVlcnksIHtcbiAgICAgIG1pblNpbWlsYXJpdHk6IGNvbmZpZy5taW5WZWN0b3JTY29yZSxcbiAgICAgIG1heFJlc3VsdHM6IGNvbmZpZy5tYXhSZXN1bHRzICogMiAvLyBHZXQgbW9yZSByZXN1bHRzIGluaXRpYWxseSBmb3IgcmUtcmFua2luZ1xuICAgIH0pO1xuICAgIFxuICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBWZWN0b3Igc2VhcmNoIHJldHVybmVkICR7dmVjdG9yUmVzdWx0cy5sZW5ndGh9IHJlc3VsdHNgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gdmVjdG9yIHJlc3VsdHMgb3IgQk0yNSB3ZWlnaHQgaXMgMCwgcmV0dXJuIHZlY3RvciByZXN1bHRzXG4gICAgaWYgKHZlY3RvclJlc3VsdHMubGVuZ3RoID09PSAwIHx8IGNvbmZpZy5ibTI1V2VpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm4gdmVjdG9yUmVzdWx0cy5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgIGl0ZW06IHJlc3VsdC5pdGVtLFxuICAgICAgICBibTI1U2NvcmU6IDAsXG4gICAgICAgIHZlY3RvclNjb3JlOiByZXN1bHQuc2NvcmUsXG4gICAgICAgIGNvbWJpbmVkU2NvcmU6IHJlc3VsdC5zY29yZVxuICAgICAgfSkpLnNsaWNlKDAsIGNvbmZpZy5tYXhSZXN1bHRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RlcCAyOiBDYWxjdWxhdGUgQk0yNSBzY29yZXMgZm9yIHZlY3RvciByZXN1bHRzXG4gICAgY29uc3QgZW5oYW5jZWRSZXN1bHRzOiBFbmhhbmNlZFJldHJpZXZhbFJlc3VsdFtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgdmVjdG9yUmVzdWx0cykge1xuICAgICAgY29uc3QgZG9jdW1lbnQ6IERvY3VtZW50ID0ge1xuICAgICAgICBpZDogcmVzdWx0Lml0ZW0ubWV0YWRhdGE/LnNvdXJjZSB8fCAndW5rbm93bicsXG4gICAgICAgIHRleHQ6IHJlc3VsdC5pdGVtLnRleHRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGJtMjVTY29yZSA9IGNhbGN1bGF0ZUJNMjVTY29yZShxdWVyeSwgZG9jdW1lbnQsIHRoaXMuY29ycHVzU3RhdHMpO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGlmIEJNMjUgc2NvcmUgaXMgYmVsb3cgdGhyZXNob2xkXG4gICAgICBpZiAoYm0yNVNjb3JlIDwgY29uZmlnLm1pbkJNMjVTY29yZSAmJiBjb25maWcuYm0yNVdlaWdodCA+IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE5vcm1hbGl6ZSBzY29yZXMgaWYgZW5hYmxlZFxuICAgICAgbGV0IG5vcm1hbGl6ZWRCTTI1ID0gYm0yNVNjb3JlO1xuICAgICAgbGV0IG5vcm1hbGl6ZWRWZWN0b3IgPSByZXN1bHQuc2NvcmU7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBjb21iaW5lZCBzY29yZVxuICAgICAgY29uc3QgY29tYmluZWRTY29yZSA9IGNvbWJpbmVTY29yZXMoXG4gICAgICAgIG5vcm1hbGl6ZWRCTTI1LFxuICAgICAgICBub3JtYWxpemVkVmVjdG9yLFxuICAgICAgICBjb25maWcuYm0yNVdlaWdodFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZW5oYW5jZWRSZXN1bHRzLnB1c2goe1xuICAgICAgICBpdGVtOiByZXN1bHQuaXRlbSxcbiAgICAgICAgYm0yNVNjb3JlLFxuICAgICAgICB2ZWN0b3JTY29yZTogcmVzdWx0LnNjb3JlLFxuICAgICAgICBjb21iaW5lZFNjb3JlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBieSBjb21iaW5lZCBzY29yZVxuICAgIGVuaGFuY2VkUmVzdWx0cy5zb3J0KChhLCBiKSA9PiBiLmNvbWJpbmVkU2NvcmUgLSBhLmNvbWJpbmVkU2NvcmUpO1xuICAgIFxuICAgIC8vIEFwcGx5IG1heGltdW0gcmVzdWx0cyBsaW1pdFxuICAgIGNvbnN0IGZpbmFsUmVzdWx0cyA9IGVuaGFuY2VkUmVzdWx0cy5zbGljZSgwLCBjb25maWcubWF4UmVzdWx0cyk7XG4gICAgXG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYEVuaGFuY2VkIHJldHJpZXZhbCByZXR1cm5lZCAke2ZpbmFsUmVzdWx0cy5sZW5ndGh9IHJlc3VsdHNgKTtcbiAgICAgIGZpbmFsUmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFJlc3VsdCAke2krMX06IENvbWJpbmVkIHNjb3JlICR7cmVzdWx0LmNvbWJpbmVkU2NvcmUudG9GaXhlZCg0KX0gKFZlY3RvcjogJHtyZXN1bHQudmVjdG9yU2NvcmUudG9GaXhlZCg0KX0sIEJNMjU6ICR7cmVzdWx0LmJtMjVTY29yZS50b0ZpeGVkKDQpfSlgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGRvY3VtZW50IHRleHQgZnJvbSByZXN1bHRzIGZvciBjb250ZXh0IGdlbmVyYXRpb25cbiAgICovXG4gIGFzeW5jIGdldENvbnRleHRGcm9tUmVzdWx0cyhyZXN1bHRzOiBFbmhhbmNlZFJldHJpZXZhbFJlc3VsdFtdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAocmVzdWx0ID0+IHtcbiAgICAgIC8vIEluY2x1ZGUgbWV0YWRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICBjb25zdCBzb3VyY2UgPSByZXN1bHQuaXRlbS5tZXRhZGF0YT8uc291cmNlIFxuICAgICAgICA/IGBTb3VyY2U6ICR7cmVzdWx0Lml0ZW0ubWV0YWRhdGEuc291cmNlfVxcbmAgXG4gICAgICAgIDogJyc7XG4gICAgICAgIFxuICAgICAgLy8gUmV0dXJuIGZvcm1hdHRlZCBjb250ZXh0XG4gICAgICByZXR1cm4gYCR7c291cmNlfSR7cmVzdWx0Lml0ZW0udGV4dH1cXG5cXG5gO1xuICAgIH0pLmpvaW4oJy0tLVxcblxcbicpO1xuICB9XG59ICJdLCJuYW1lcyI6WyJsb2FkQ29ycHVzU3RhdGlzdGljcyIsImNhbGN1bGF0ZUJNMjVTY29yZSIsImNvbWJpbmVTY29yZXMiLCJnZXRTaW1pbGFySXRlbXMiLCJ0b2tlbml6ZSIsImZzIiwicGF0aCIsIkRFRkFVTFRfRU5IQU5DRURfUkVUUklFVkFMX0NPTkZJRyIsImJtMjVXZWlnaHQiLCJtaW5CTTI1U2NvcmUiLCJtaW5WZWN0b3JTY29yZSIsIm5vcm1hbGl6ZVNjb3JlcyIsIm1heFJlc3VsdHMiLCJkZWJ1ZyIsIkVuaGFuY2VkUmV0cmlldmFsIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJ2ZWN0b3JTdG9yZSIsImNvcnB1c1N0YXRzIiwiaXNJbml0aWFsaXplZCIsImxvYWRWZWN0b3JTdG9yZSIsImZpbGVQYXRoIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJmaWxlRGF0YSIsInJlYWRGaWxlIiwicGFyc2VkRGF0YSIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW1zIiwiZXJyb3IiLCJjb25zb2xlIiwiaW5pdGlhbGl6ZSIsImxvZyIsIk9iamVjdCIsImtleXMiLCJkb2N1bWVudEZyZXF1ZW5jeSIsImxlbmd0aCIsIkVycm9yIiwiZmluZFNpbWlsYXJJdGVtcyIsInF1ZXJ5Iiwib3B0aW9ucyIsInJlc3VsdHMiLCJmaWxsIiwibWFwIiwiTWF0aCIsInJhbmRvbSIsInJlc3VsdCIsIml0ZW0iLCJzY29yZSIsImZpbmRTaW1pbGFyRG9jdW1lbnRzIiwidmVjdG9yUmVzdWx0cyIsIm1pblNpbWlsYXJpdHkiLCJibTI1U2NvcmUiLCJ2ZWN0b3JTY29yZSIsImNvbWJpbmVkU2NvcmUiLCJzbGljZSIsImVuaGFuY2VkUmVzdWx0cyIsImRvY3VtZW50IiwiaWQiLCJtZXRhZGF0YSIsInNvdXJjZSIsInRleHQiLCJub3JtYWxpemVkQk0yNSIsIm5vcm1hbGl6ZWRWZWN0b3IiLCJwdXNoIiwic29ydCIsImEiLCJiIiwiZmluYWxSZXN1bHRzIiwiZm9yRWFjaCIsImkiLCJ0b0ZpeGVkIiwiZ2V0Q29udGV4dEZyb21SZXN1bHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/enhancedRetrieval.ts\n");

/***/ }),

/***/ "(api)/./utils/errorHandling.ts":
/*!********************************!*\
  !*** ./utils/errorHandling.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIModelError: () => (/* binding */ AIModelError),\n/* harmony export */   DocumentProcessingError: () => (/* binding */ DocumentProcessingError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   QueryProcessingError: () => (/* binding */ QueryProcessingError),\n/* harmony export */   VectorStoreError: () => (/* binding */ VectorStoreError),\n/* harmony export */   createError: () => (/* binding */ createError),\n/* harmony export */   createFallbackResponse: () => (/* binding */ createFallbackResponse),\n/* harmony export */   formatValidationError: () => (/* binding */ formatValidationError),\n/* harmony export */   handleError: () => (/* binding */ handleError),\n/* harmony export */   handleOpenAIError: () => (/* binding */ handleOpenAIError),\n/* harmony export */   logError: () => (/* binding */ logError),\n/* harmony export */   safeExecute: () => (/* binding */ safeExecute),\n/* harmony export */   standardizeApiErrorResponse: () => (/* binding */ standardizeApiErrorResponse)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"openai\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([openai__WEBPACK_IMPORTED_MODULE_0__]);\nopenai__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n// Custom error classes for better error identification\nclass DocumentProcessingError extends Error {\n    constructor(message, originalError){\n        super(message);\n        this.originalError = originalError;\n        this.name = \"DocumentProcessingError\";\n    }\n}\nclass AIModelError extends Error {\n    constructor(message, originalError){\n        super(message);\n        this.originalError = originalError;\n        this.name = \"AIModelError\";\n    }\n}\nclass VectorStoreError extends Error {\n    constructor(message, originalError){\n        super(message);\n        this.originalError = originalError;\n        this.name = \"VectorStoreError\";\n    }\n}\nclass NetworkError extends Error {\n    constructor(message, originalError){\n        super(message);\n        this.originalError = originalError;\n        this.name = \"NetworkError\";\n    }\n}\nclass QueryProcessingError extends Error {\n    constructor(message, originalError){\n        super(message);\n        this.originalError = originalError;\n        this.name = \"QueryProcessingError\";\n    }\n}\n// Error handler for OpenAI API errors\nfunction handleOpenAIError(error) {\n    if (error instanceof openai__WEBPACK_IMPORTED_MODULE_0__.OpenAI.APIError) {\n        if (error.status === 400) {\n            return new AIModelError(`Invalid request to OpenAI: ${error.message}`, error);\n        } else if (error.status === 401) {\n            return new AIModelError(\"Authentication error with OpenAI API. Check your API key.\", error);\n        } else if (error.status === 429) {\n            return new AIModelError(\"Rate limit exceeded with OpenAI API. Please try again later.\", error);\n        } else if (error.status >= 500) {\n            return new AIModelError(\"OpenAI service is currently unavailable. Please try again later.\", error);\n        }\n    }\n    return new AIModelError(`Unexpected error with OpenAI: ${error instanceof Error ? error.message : String(error)}`, error instanceof Error ? error : undefined);\n}\n// General purpose error handler\nfunction handleError(error, context) {\n    // Log the error for debugging\n    console.error(`Error in ${context}:`, error);\n    // Specific handling based on error type\n    if (error instanceof openai__WEBPACK_IMPORTED_MODULE_0__.OpenAI.APIError) {\n        return handleOpenAIError(error);\n    }\n    if (error instanceof DocumentProcessingError || error instanceof AIModelError || error instanceof VectorStoreError || error instanceof NetworkError || error instanceof QueryProcessingError) {\n        return error; // Already a custom error, return as is\n    }\n    // Generic error handling\n    const message = error instanceof Error ? error.message : String(error);\n    return new Error(`Error in ${context}: ${message}`);\n}\n// Helper for fallback response creation\nfunction createFallbackResponse(defaultValue) {\n    return defaultValue;\n}\n// Type-safe try/catch wrapper for async functions\nasync function safeExecute(operation, context, fallback) {\n    try {\n        return await operation();\n    } catch (error) {\n        handleError(error, context);\n        return fallback;\n    }\n}\n/**\n * Standardize error responses for API endpoints\n * This ensures consistent error formatting across the application\n */ function standardizeApiErrorResponse(error) {\n    console.error(\"Error details:\", error);\n    // Handle OpenAI API errors\n    if (error.name === \"OpenAIError\" || error.response && error.response.headers && error.response.headers.get(\"x-request-id\")) {\n        return {\n            error: {\n                message: \"Error processing your request with the language model\",\n                code: \"OPENAI_API_ERROR\",\n                details:  true ? {\n                    message: error.message,\n                    type: error.type,\n                    statusCode: error.status || error.statusCode\n                } : 0\n            }\n        };\n    }\n    // Handle vector store errors\n    if (error.message && error.message.includes(\"vector store\")) {\n        return {\n            error: {\n                message: \"Error retrieving information from knowledge base\",\n                code: \"VECTOR_STORE_ERROR\",\n                details:  true ? {\n                    message: error.message\n                } : 0\n            }\n        };\n    }\n    // Handle timeout errors\n    if (error.name === \"AbortError\" || error.code === \"ETIMEDOUT\" || error.message?.includes(\"timeout\")) {\n        return {\n            error: {\n                message: \"Request timed out. Please try again.\",\n                code: \"TIMEOUT_ERROR\",\n                details:  true ? {\n                    message: error.message\n                } : 0\n            }\n        };\n    }\n    // Default error response\n    return {\n        error: {\n            message: \"An unexpected error occurred\",\n            code: \"INTERNAL_SERVER_ERROR\",\n            details:  true ? {\n                message: error.message || \"Unknown error\"\n            } : 0\n        }\n    };\n}\n/**\n * Format validation errors consistently\n */ function formatValidationError(message, fieldErrors) {\n    return {\n        error: {\n            message: message || \"Validation error\",\n            code: \"VALIDATION_ERROR\",\n            details: fieldErrors\n        }\n    };\n}\n/**\n * Log error with standardized format for easier debugging\n */ function logError(error, context) {\n    const timestamp = new Date().toISOString();\n    const contextInfo = context ? `[${context}] ` : \"\";\n    console.error(`${timestamp} ${contextInfo}Error: ${error.message}`);\n    if (error.stack && \"development\" !== \"production\") {\n        console.error(`Stack trace: ${error.stack}`);\n    }\n    // Log additional details if available\n    if (error.response) {\n        console.error(\"Response data:\", error.response.data);\n        console.error(\"Response status:\", error.response.status);\n    }\n}\n/**\n * Create a simple error with additional context\n */ function createError(message, code, additionalDetails) {\n    const error = new Error(message);\n    if (code) error.code = code;\n    if (additionalDetails) error.details = additionalDetails;\n    return error;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9lcnJvckhhbmRsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBRWhDLHVEQUF1RDtBQUNoRCxNQUFNQyxnQ0FBZ0NDO0lBQzNDQyxZQUFZQyxPQUFlLEVBQUUsYUFBcUMsQ0FBRTtRQUNsRSxLQUFLLENBQUNBO2FBRHFDQyxnQkFBQUE7UUFFM0MsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRU8sTUFBTUMscUJBQXFCTDtJQUNoQ0MsWUFBWUMsT0FBZSxFQUFFLGFBQXFDLENBQUU7UUFDbEUsS0FBSyxDQUFDQTthQURxQ0MsZ0JBQUFBO1FBRTNDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVPLE1BQU1FLHlCQUF5Qk47SUFDcENDLFlBQVlDLE9BQWUsRUFBRSxhQUFxQyxDQUFFO1FBQ2xFLEtBQUssQ0FBQ0E7YUFEcUNDLGdCQUFBQTtRQUUzQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFTyxNQUFNRyxxQkFBcUJQO0lBQ2hDQyxZQUFZQyxPQUFlLEVBQUUsYUFBcUMsQ0FBRTtRQUNsRSxLQUFLLENBQUNBO2FBRHFDQyxnQkFBQUE7UUFFM0MsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRU8sTUFBTUksNkJBQTZCUjtJQUN4Q0MsWUFBWUMsT0FBZSxFQUFFLGFBQXFDLENBQUU7UUFDbEUsS0FBSyxDQUFDQTthQURxQ0MsZ0JBQUFBO1FBRTNDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLHNDQUFzQztBQUMvQixTQUFTSyxrQkFBa0JDLEtBQWM7SUFDOUMsSUFBSUEsaUJBQWlCWiwwQ0FBTUEsQ0FBQ2EsUUFBUSxFQUFFO1FBQ3BDLElBQUlELE1BQU1FLE1BQU0sS0FBSyxLQUFLO1lBQ3hCLE9BQU8sSUFBSVAsYUFBYSxDQUFDLDJCQUEyQixFQUFFSyxNQUFNUixPQUFPLENBQUMsQ0FBQyxFQUFFUTtRQUN6RSxPQUFPLElBQUlBLE1BQU1FLE1BQU0sS0FBSyxLQUFLO1lBQy9CLE9BQU8sSUFBSVAsYUFBYSw2REFBNkRLO1FBQ3ZGLE9BQU8sSUFBSUEsTUFBTUUsTUFBTSxLQUFLLEtBQUs7WUFDL0IsT0FBTyxJQUFJUCxhQUFhLGdFQUFnRUs7UUFDMUYsT0FBTyxJQUFJQSxNQUFNRSxNQUFNLElBQUksS0FBSztZQUM5QixPQUFPLElBQUlQLGFBQWEsb0VBQW9FSztRQUM5RjtJQUNGO0lBRUEsT0FBTyxJQUFJTCxhQUFhLENBQUMsOEJBQThCLEVBQUVLLGlCQUFpQlYsUUFBUVUsTUFBTVIsT0FBTyxHQUFHVyxPQUFPSCxPQUFPLENBQUMsRUFDL0dBLGlCQUFpQlYsUUFBUVUsUUFBUUk7QUFDckM7QUFFQSxnQ0FBZ0M7QUFDekIsU0FBU0MsWUFBWUwsS0FBYyxFQUFFTSxPQUFlO0lBQ3pELDhCQUE4QjtJQUM5QkMsUUFBUVAsS0FBSyxDQUFDLENBQUMsU0FBUyxFQUFFTSxRQUFRLENBQUMsQ0FBQyxFQUFFTjtJQUV0Qyx3Q0FBd0M7SUFDeEMsSUFBSUEsaUJBQWlCWiwwQ0FBTUEsQ0FBQ2EsUUFBUSxFQUFFO1FBQ3BDLE9BQU9GLGtCQUFrQkM7SUFDM0I7SUFFQSxJQUFJQSxpQkFBaUJYLDJCQUNqQlcsaUJBQWlCTCxnQkFDakJLLGlCQUFpQkosb0JBQ2pCSSxpQkFBaUJILGdCQUNqQkcsaUJBQWlCRixzQkFBc0I7UUFDekMsT0FBT0UsT0FBTyx1Q0FBdUM7SUFDdkQ7SUFFQSx5QkFBeUI7SUFDekIsTUFBTVIsVUFBVVEsaUJBQWlCVixRQUFRVSxNQUFNUixPQUFPLEdBQUdXLE9BQU9IO0lBQ2hFLE9BQU8sSUFBSVYsTUFBTSxDQUFDLFNBQVMsRUFBRWdCLFFBQVEsRUFBRSxFQUFFZCxRQUFRLENBQUM7QUFDcEQ7QUFFQSx3Q0FBd0M7QUFDakMsU0FBU2dCLHVCQUEwQkMsWUFBZTtJQUN2RCxPQUFPQTtBQUNUO0FBRUEsa0RBQWtEO0FBQzNDLGVBQWVDLFlBQ3BCQyxTQUEyQixFQUMzQkwsT0FBZSxFQUNmTSxRQUFXO0lBRVgsSUFBSTtRQUNGLE9BQU8sTUFBTUQ7SUFDZixFQUFFLE9BQU9YLE9BQU87UUFDZEssWUFBWUwsT0FBT007UUFDbkIsT0FBT007SUFDVDtBQUNGO0FBYUE7OztDQUdDLEdBQ00sU0FBU0MsNEJBQTRCYixLQUFVO0lBQ3BETyxRQUFRUCxLQUFLLENBQUMsa0JBQWtCQTtJQUVoQywyQkFBMkI7SUFDM0IsSUFBSUEsTUFBTU4sSUFBSSxLQUFLLGlCQUFrQk0sTUFBTWMsUUFBUSxJQUFJZCxNQUFNYyxRQUFRLENBQUNDLE9BQU8sSUFBSWYsTUFBTWMsUUFBUSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxpQkFBa0I7UUFDNUgsT0FBTztZQUNMaEIsT0FBTztnQkFDTFIsU0FBUztnQkFDVHlCLE1BQU07Z0JBQ05DLFNBQVNDLEtBQXlCLEdBQWU7b0JBQy9DM0IsU0FBU1EsTUFBTVIsT0FBTztvQkFDdEI0QixNQUFNcEIsTUFBTW9CLElBQUk7b0JBQ2hCQyxZQUFZckIsTUFBTUUsTUFBTSxJQUFJRixNQUFNcUIsVUFBVTtnQkFDOUMsSUFBSWpCLENBQVNBO1lBQ2Y7UUFDRjtJQUNGO0lBRUEsNkJBQTZCO0lBQzdCLElBQUlKLE1BQU1SLE9BQU8sSUFBSVEsTUFBTVIsT0FBTyxDQUFDOEIsUUFBUSxDQUFDLGlCQUFpQjtRQUMzRCxPQUFPO1lBQ0x0QixPQUFPO2dCQUNMUixTQUFTO2dCQUNUeUIsTUFBTTtnQkFDTkMsU0FBU0MsS0FBeUIsR0FBZTtvQkFDL0MzQixTQUFTUSxNQUFNUixPQUFPO2dCQUN4QixJQUFJWSxDQUFTQTtZQUNmO1FBQ0Y7SUFDRjtJQUVBLHdCQUF3QjtJQUN4QixJQUFJSixNQUFNTixJQUFJLEtBQUssZ0JBQWdCTSxNQUFNaUIsSUFBSSxLQUFLLGVBQWVqQixNQUFNUixPQUFPLEVBQUU4QixTQUFTLFlBQVk7UUFDbkcsT0FBTztZQUNMdEIsT0FBTztnQkFDTFIsU0FBUztnQkFDVHlCLE1BQU07Z0JBQ05DLFNBQVNDLEtBQXlCLEdBQWU7b0JBQy9DM0IsU0FBU1EsTUFBTVIsT0FBTztnQkFDeEIsSUFBSVksQ0FBU0E7WUFDZjtRQUNGO0lBQ0Y7SUFFQSx5QkFBeUI7SUFDekIsT0FBTztRQUNMSixPQUFPO1lBQ0xSLFNBQVM7WUFDVHlCLE1BQU07WUFDTkMsU0FBU0MsS0FBeUIsR0FBZTtnQkFDL0MzQixTQUFTUSxNQUFNUixPQUFPLElBQUk7WUFDNUIsSUFBSVksQ0FBU0E7UUFDZjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNtQixzQkFBc0IvQixPQUFlLEVBQUVnQyxXQUFvQztJQUN6RixPQUFPO1FBQ0x4QixPQUFPO1lBQ0xSLFNBQVNBLFdBQVc7WUFDcEJ5QixNQUFNO1lBQ05DLFNBQVNNO1FBQ1g7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxTQUFTekIsS0FBVSxFQUFFTSxPQUFnQjtJQUNuRCxNQUFNb0IsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQ3hDLE1BQU1DLGNBQWN2QixVQUFVLENBQUMsQ0FBQyxFQUFFQSxRQUFRLEVBQUUsQ0FBQyxHQUFHO0lBRWhEQyxRQUFRUCxLQUFLLENBQUMsQ0FBQyxFQUFFMEIsVUFBVSxDQUFDLEVBQUVHLFlBQVksT0FBTyxFQUFFN0IsTUFBTVIsT0FBTyxDQUFDLENBQUM7SUFFbEUsSUFBSVEsTUFBTThCLEtBQUssSUFBSVgsa0JBQXlCLGNBQWM7UUFDeERaLFFBQVFQLEtBQUssQ0FBQyxDQUFDLGFBQWEsRUFBRUEsTUFBTThCLEtBQUssQ0FBQyxDQUFDO0lBQzdDO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUk5QixNQUFNYyxRQUFRLEVBQUU7UUFDbEJQLFFBQVFQLEtBQUssQ0FBQyxrQkFBa0JBLE1BQU1jLFFBQVEsQ0FBQ2lCLElBQUk7UUFDbkR4QixRQUFRUCxLQUFLLENBQUMsb0JBQW9CQSxNQUFNYyxRQUFRLENBQUNaLE1BQU07SUFDekQ7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBUzhCLFlBQVl4QyxPQUFlLEVBQUV5QixJQUFhLEVBQUVnQixpQkFBdUI7SUFDakYsTUFBTWpDLFFBQWEsSUFBSVYsTUFBTUU7SUFDN0IsSUFBSXlCLE1BQU1qQixNQUFNaUIsSUFBSSxHQUFHQTtJQUN2QixJQUFJZ0IsbUJBQW1CakMsTUFBTWtCLE9BQU8sR0FBR2U7SUFDdkMsT0FBT2pDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWxlcy1jaGF0LW9wZW5haS1yYWcvLi91dGlscy9lcnJvckhhbmRsaW5nLnRzPzdiZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3BlbkFJIH0gZnJvbSAnb3BlbmFpJztcblxuLy8gQ3VzdG9tIGVycm9yIGNsYXNzZXMgZm9yIGJldHRlciBlcnJvciBpZGVudGlmaWNhdGlvblxuZXhwb3J0IGNsYXNzIERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbEVycm9yPzogRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBSU1vZGVsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcHVibGljIHJlYWRvbmx5IG9yaWdpbmFsRXJyb3I/OiBFcnJvcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdBSU1vZGVsRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbEVycm9yPzogRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnVmVjdG9yU3RvcmVFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgb3JpZ2luYWxFcnJvcj86IEVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ05ldHdvcmtFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFF1ZXJ5UHJvY2Vzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbEVycm9yPzogRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnUXVlcnlQcm9jZXNzaW5nRXJyb3InO1xuICB9XG59XG5cbi8vIEVycm9yIGhhbmRsZXIgZm9yIE9wZW5BSSBBUEkgZXJyb3JzXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlT3BlbkFJRXJyb3IoZXJyb3I6IHVua25vd24pOiBBSU1vZGVsRXJyb3Ige1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUkuQVBJRXJyb3IpIHtcbiAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDApIHtcbiAgICAgIHJldHVybiBuZXcgQUlNb2RlbEVycm9yKGBJbnZhbGlkIHJlcXVlc3QgdG8gT3BlbkFJOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIHJldHVybiBuZXcgQUlNb2RlbEVycm9yKCdBdXRoZW50aWNhdGlvbiBlcnJvciB3aXRoIE9wZW5BSSBBUEkuIENoZWNrIHlvdXIgQVBJIGtleS4nLCBlcnJvcik7XG4gICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgcmV0dXJuIG5ldyBBSU1vZGVsRXJyb3IoJ1JhdGUgbGltaXQgZXhjZWVkZWQgd2l0aCBPcGVuQUkgQVBJLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgIHJldHVybiBuZXcgQUlNb2RlbEVycm9yKCdPcGVuQUkgc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJywgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIG5ldyBBSU1vZGVsRXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3Igd2l0aCBPcGVuQUk6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsIFxuICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IHVuZGVmaW5lZCk7XG59XG5cbi8vIEdlbmVyYWwgcHVycG9zZSBlcnJvciBoYW5kbGVyXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3I6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IEVycm9yIHtcbiAgLy8gTG9nIHRoZSBlcnJvciBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluICR7Y29udGV4dH06YCwgZXJyb3IpO1xuICBcbiAgLy8gU3BlY2lmaWMgaGFuZGxpbmcgYmFzZWQgb24gZXJyb3IgdHlwZVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUkuQVBJRXJyb3IpIHtcbiAgICByZXR1cm4gaGFuZGxlT3BlbkFJRXJyb3IoZXJyb3IpO1xuICB9XG4gIFxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBEb2N1bWVudFByb2Nlc3NpbmdFcnJvciB8fCBcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgQUlNb2RlbEVycm9yIHx8IFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBWZWN0b3JTdG9yZUVycm9yIHx8XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvciB8fFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBRdWVyeVByb2Nlc3NpbmdFcnJvcikge1xuICAgIHJldHVybiBlcnJvcjsgLy8gQWxyZWFkeSBhIGN1c3RvbSBlcnJvciwgcmV0dXJuIGFzIGlzXG4gIH1cbiAgXG4gIC8vIEdlbmVyaWMgZXJyb3IgaGFuZGxpbmdcbiAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgcmV0dXJuIG5ldyBFcnJvcihgRXJyb3IgaW4gJHtjb250ZXh0fTogJHttZXNzYWdlfWApO1xufVxuXG4vLyBIZWxwZXIgZm9yIGZhbGxiYWNrIHJlc3BvbnNlIGNyZWF0aW9uXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tSZXNwb25zZTxUPihkZWZhdWx0VmFsdWU6IFQpOiBUIHtcbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuLy8gVHlwZS1zYWZlIHRyeS9jYXRjaCB3cmFwcGVyIGZvciBhc3luYyBmdW5jdGlvbnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYWZlRXhlY3V0ZTxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBjb250ZXh0OiBzdHJpbmcsXG4gIGZhbGxiYWNrOiBUXG4pOiBQcm9taXNlPFQ+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgb3BlcmF0aW9uKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIGNvbnRleHQpO1xuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxufVxuXG4vKipcbiAqIFN0YW5kYXJkIEFQSSBlcnJvciByZXNwb25zZSBmb3JtYXRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlFcnJvclJlc3BvbnNlIHtcbiAgZXJyb3I6IHtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nO1xuICAgIGRldGFpbHM/OiBhbnk7XG4gIH07XG59XG5cbi8qKlxuICogU3RhbmRhcmRpemUgZXJyb3IgcmVzcG9uc2VzIGZvciBBUEkgZW5kcG9pbnRzXG4gKiBUaGlzIGVuc3VyZXMgY29uc2lzdGVudCBlcnJvciBmb3JtYXR0aW5nIGFjcm9zcyB0aGUgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YW5kYXJkaXplQXBpRXJyb3JSZXNwb25zZShlcnJvcjogYW55KTogQXBpRXJyb3JSZXNwb25zZSB7XG4gIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICBcbiAgLy8gSGFuZGxlIE9wZW5BSSBBUEkgZXJyb3JzXG4gIGlmIChlcnJvci5uYW1lID09PSAnT3BlbkFJRXJyb3InIHx8IChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5oZWFkZXJzICYmIGVycm9yLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlcXVlc3QtaWQnKSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIHByb2Nlc3NpbmcgeW91ciByZXF1ZXN0IHdpdGggdGhlIGxhbmd1YWdlIG1vZGVsJyxcbiAgICAgICAgY29kZTogJ09QRU5BSV9BUElfRVJST1InLFxuICAgICAgICBkZXRhaWxzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgdHlwZTogZXJyb3IudHlwZSxcbiAgICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMgfHwgZXJyb3Iuc3RhdHVzQ29kZVxuICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgLy8gSGFuZGxlIHZlY3RvciBzdG9yZSBlcnJvcnNcbiAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndmVjdG9yIHN0b3JlJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIHJldHJpZXZpbmcgaW5mb3JtYXRpb24gZnJvbSBrbm93bGVkZ2UgYmFzZScsXG4gICAgICAgIGNvZGU6ICdWRUNUT1JfU1RPUkVfRVJST1InLFxuICAgICAgICBkZXRhaWxzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gIC8vIEhhbmRsZSB0aW1lb3V0IGVycm9yc1xuICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVycm9yLmNvZGUgPT09ICdFVElNRURPVVQnIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgdGltZWQgb3V0LiBQbGVhc2UgdHJ5IGFnYWluLicsXG4gICAgICAgIGNvZGU6ICdUSU1FT1VUX0VSUk9SJyxcbiAgICAgICAgZGV0YWlsczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFxuICAvLyBEZWZhdWx0IGVycm9yIHJlc3BvbnNlXG4gIHJldHVybiB7XG4gICAgZXJyb3I6IHtcbiAgICAgIG1lc3NhZ2U6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkJyxcbiAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgZGV0YWlsczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcidcbiAgICAgIH0gOiB1bmRlZmluZWRcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRm9ybWF0IHZhbGlkYXRpb24gZXJyb3JzIGNvbnNpc3RlbnRseVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VmFsaWRhdGlvbkVycm9yKG1lc3NhZ2U6IHN0cmluZywgZmllbGRFcnJvcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogQXBpRXJyb3JSZXNwb25zZSB7XG4gIHJldHVybiB7XG4gICAgZXJyb3I6IHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgJ1ZhbGlkYXRpb24gZXJyb3InLFxuICAgICAgY29kZTogJ1ZBTElEQVRJT05fRVJST1InLFxuICAgICAgZGV0YWlsczogZmllbGRFcnJvcnNcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogTG9nIGVycm9yIHdpdGggc3RhbmRhcmRpemVkIGZvcm1hdCBmb3IgZWFzaWVyIGRlYnVnZ2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nRXJyb3IoZXJyb3I6IGFueSwgY29udGV4dD86IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IGNvbnRleHRJbmZvID0gY29udGV4dCA/IGBbJHtjb250ZXh0fV0gYCA6ICcnO1xuICBcbiAgY29uc29sZS5lcnJvcihgJHt0aW1lc3RhbXB9ICR7Y29udGV4dEluZm99RXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgXG4gIGlmIChlcnJvci5zdGFjayAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihgU3RhY2sgdHJhY2U6ICR7ZXJyb3Iuc3RhY2t9YCk7XG4gIH1cbiAgXG4gIC8vIExvZyBhZGRpdGlvbmFsIGRldGFpbHMgaWYgYXZhaWxhYmxlXG4gIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Jlc3BvbnNlIGRhdGE6JywgZXJyb3IucmVzcG9uc2UuZGF0YSk7XG4gICAgY29uc29sZS5lcnJvcignUmVzcG9uc2Ugc3RhdHVzOicsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaW1wbGUgZXJyb3Igd2l0aCBhZGRpdGlvbmFsIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2U6IHN0cmluZywgY29kZT86IHN0cmluZywgYWRkaXRpb25hbERldGFpbHM/OiBhbnkpOiBFcnJvciB7XG4gIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGlmIChjb2RlKSBlcnJvci5jb2RlID0gY29kZTtcbiAgaWYgKGFkZGl0aW9uYWxEZXRhaWxzKSBlcnJvci5kZXRhaWxzID0gYWRkaXRpb25hbERldGFpbHM7XG4gIHJldHVybiBlcnJvcjtcbn0gIl0sIm5hbWVzIjpbIk9wZW5BSSIsIkRvY3VtZW50UHJvY2Vzc2luZ0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcmlnaW5hbEVycm9yIiwibmFtZSIsIkFJTW9kZWxFcnJvciIsIlZlY3RvclN0b3JlRXJyb3IiLCJOZXR3b3JrRXJyb3IiLCJRdWVyeVByb2Nlc3NpbmdFcnJvciIsImhhbmRsZU9wZW5BSUVycm9yIiwiZXJyb3IiLCJBUElFcnJvciIsInN0YXR1cyIsIlN0cmluZyIsInVuZGVmaW5lZCIsImhhbmRsZUVycm9yIiwiY29udGV4dCIsImNvbnNvbGUiLCJjcmVhdGVGYWxsYmFja1Jlc3BvbnNlIiwiZGVmYXVsdFZhbHVlIiwic2FmZUV4ZWN1dGUiLCJvcGVyYXRpb24iLCJmYWxsYmFjayIsInN0YW5kYXJkaXplQXBpRXJyb3JSZXNwb25zZSIsInJlc3BvbnNlIiwiaGVhZGVycyIsImdldCIsImNvZGUiLCJkZXRhaWxzIiwicHJvY2VzcyIsInR5cGUiLCJzdGF0dXNDb2RlIiwiaW5jbHVkZXMiLCJmb3JtYXRWYWxpZGF0aW9uRXJyb3IiLCJmaWVsZEVycm9ycyIsImxvZ0Vycm9yIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29udGV4dEluZm8iLCJzdGFjayIsImRhdGEiLCJjcmVhdGVFcnJvciIsImFkZGl0aW9uYWxEZXRhaWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/errorHandling.ts\n");

/***/ }),

/***/ "(api)/./utils/modelConfig.ts":
/*!******************************!*\
  !*** ./utils/modelConfig.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_SETTINGS: () => (/* binding */ AI_SETTINGS),\n/* harmony export */   SYSTEM_PROMPTS: () => (/* binding */ SYSTEM_PROMPTS),\n/* harmony export */   getSystemPromptForQuery: () => (/* binding */ getSystemPromptForQuery)\n/* harmony export */ });\n/**\n * AI model configuration settings for the RAG system\n * This provides centralized configuration for all AI model settings\n */ /**\n * Interface for model settings\n */ /**\n * Application AI settings\n */ const AI_SETTINGS = {\n    // Default model for standard operations\n    defaultModel: process.env.DEFAULT_LLM_MODEL || \"gpt-4\",\n    // Fallback model when primary is unavailable or for less critical operations\n    fallbackModel: process.env.FALLBACK_LLM_MODEL || \"gpt-3.5-turbo-1106\",\n    // Embedding model for vector operations\n    embeddingModel: process.env.EMBEDDING_MODEL || \"text-embedding-ada-002\",\n    // Default max tokens for generation\n    maxTokens: 1000,\n    // Default temperature for most operations\n    temperature: 0.7,\n    // Default system prompt for RAG queries\n    systemPrompt: `You are an AI assistant for the sales team. \nAnswer the question based ONLY on the context provided. \nIf the answer cannot be determined from the context, say \"I don't have enough information to answer this question.\"\nDo not make up or infer information that is not in the context.\nProvide concise, accurate responses with all relevant details from the context.`\n};\n/**\n * Different preset system prompts for various use cases\n */ const SYSTEM_PROMPTS = {\n    standard: AI_SETTINGS.systemPrompt,\n    technical: `You are an AI assistant for the sales team specializing in technical questions.\nAnswer the question based ONLY on the context provided.\nUse technical language and be precise in your explanations.\nIf the answer cannot be determined from the context, say \"I don't have enough information to answer this question.\"\nDo not make up or infer information that is not in the context.`,\n    sales: `You are an AI assistant for the sales team specializing in sales queries.\nAnswer the question based ONLY on the context provided.\nFocus on value propositions, competitive advantages, and addressing customer pain points.\nIf the answer cannot be determined from the context, say \"I don't have enough information to answer this question.\"\nDo not make up or infer information that is not in the context.`,\n    pricing: `You are an AI assistant for the sales team specializing in pricing questions.\nAnswer the question based ONLY on the context provided.\nBe very precise about pricing details, plans, and subscription options.\nIf the answer cannot be determined from the context, say \"I don't have enough information to answer this question.\"\nDo not make up or infer information that is not in the context.`\n};\n/**\n * Get system prompt based on query type\n */ function getSystemPromptForQuery(query) {\n    const lowerQuery = query.toLowerCase();\n    if (lowerQuery.includes(\"price\") || lowerQuery.includes(\"cost\") || lowerQuery.includes(\"subscription\") || lowerQuery.includes(\"plan\")) {\n        return SYSTEM_PROMPTS.pricing;\n    }\n    if (lowerQuery.includes(\"technical\") || lowerQuery.includes(\"architecture\") || lowerQuery.includes(\"infrastructure\") || lowerQuery.includes(\"integration\")) {\n        return SYSTEM_PROMPTS.technical;\n    }\n    if (lowerQuery.includes(\"competitor\") || lowerQuery.includes(\"comparison\") || lowerQuery.includes(\"vs\") || lowerQuery.includes(\"pitch\") || lowerQuery.includes(\"sell\")) {\n        return SYSTEM_PROMPTS.sales;\n    }\n    return SYSTEM_PROMPTS.standard;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9tb2RlbENvbmZpZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FFRDs7Q0FFQyxHQVVEOztDQUVDLEdBQ00sTUFBTUEsY0FBNkI7SUFDeEMsd0NBQXdDO0lBQ3hDQyxjQUFjQyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixJQUFJO0lBRS9DLDZFQUE2RTtJQUM3RUMsZUFBZUgsUUFBUUMsR0FBRyxDQUFDRyxrQkFBa0IsSUFBSTtJQUVqRCx3Q0FBd0M7SUFDeENDLGdCQUFnQkwsUUFBUUMsR0FBRyxDQUFDSyxlQUFlLElBQUk7SUFFL0Msb0NBQW9DO0lBQ3BDQyxXQUFXO0lBRVgsMENBQTBDO0lBQzFDQyxhQUFhO0lBRWIsd0NBQXdDO0lBQ3hDQyxjQUFjLENBQUM7Ozs7K0VBSThELENBQUM7QUFDaEYsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTUMsaUJBQWlCO0lBQzVCQyxVQUFVYixZQUFZVyxZQUFZO0lBRWxDRyxXQUFXLENBQUM7Ozs7K0RBSWlELENBQUM7SUFFOURDLE9BQU8sQ0FBQzs7OzsrREFJcUQsQ0FBQztJQUU5REMsU0FBUyxDQUFDOzs7OytEQUltRCxDQUFDO0FBQ2hFLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLFNBQVNDLHdCQUF3QkMsS0FBYTtJQUNuRCxNQUFNQyxhQUFhRCxNQUFNRSxXQUFXO0lBRXBDLElBQUlELFdBQVdFLFFBQVEsQ0FBQyxZQUNwQkYsV0FBV0UsUUFBUSxDQUFDLFdBQ3BCRixXQUFXRSxRQUFRLENBQUMsbUJBQ3BCRixXQUFXRSxRQUFRLENBQUMsU0FBUztRQUMvQixPQUFPVCxlQUFlSSxPQUFPO0lBQy9CO0lBRUEsSUFBSUcsV0FBV0UsUUFBUSxDQUFDLGdCQUNwQkYsV0FBV0UsUUFBUSxDQUFDLG1CQUNwQkYsV0FBV0UsUUFBUSxDQUFDLHFCQUNwQkYsV0FBV0UsUUFBUSxDQUFDLGdCQUFnQjtRQUN0QyxPQUFPVCxlQUFlRSxTQUFTO0lBQ2pDO0lBRUEsSUFBSUssV0FBV0UsUUFBUSxDQUFDLGlCQUNwQkYsV0FBV0UsUUFBUSxDQUFDLGlCQUNwQkYsV0FBV0UsUUFBUSxDQUFDLFNBQ3BCRixXQUFXRSxRQUFRLENBQUMsWUFDcEJGLFdBQVdFLFFBQVEsQ0FBQyxTQUFTO1FBQy9CLE9BQU9ULGVBQWVHLEtBQUs7SUFDN0I7SUFFQSxPQUFPSCxlQUFlQyxRQUFRO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtY2hhdC1vcGVuYWktcmFnLy4vdXRpbHMvbW9kZWxDb25maWcudHM/MjY4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFJIG1vZGVsIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIHRoZSBSQUcgc3lzdGVtXG4gKiBUaGlzIHByb3ZpZGVzIGNlbnRyYWxpemVkIGNvbmZpZ3VyYXRpb24gZm9yIGFsbCBBSSBtb2RlbCBzZXR0aW5nc1xuICovXG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBtb2RlbCBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsU2V0dGluZ3Mge1xuICBkZWZhdWx0TW9kZWw6IHN0cmluZzsgICAgICAvLyBEZWZhdWx0IG1vZGVsIHRvIHVzZSBmb3IgbW9zdCBvcGVyYXRpb25zXG4gIGZhbGxiYWNrTW9kZWw6IHN0cmluZzsgICAgIC8vIEZhbGxiYWNrIG1vZGVsIGlmIHRoZSBkZWZhdWx0IGlzIHVuYXZhaWxhYmxlXG4gIGVtYmVkZGluZ01vZGVsOiBzdHJpbmc7ICAgIC8vIE1vZGVsIHRvIHVzZSBmb3IgdGV4dCBlbWJlZGRpbmdzXG4gIG1heFRva2VuczogbnVtYmVyOyAgICAgICAgIC8vIE1heGltdW0gdG9rZW5zIHRvIGdlbmVyYXRlIGluIHJlc3BvbnNlc1xuICB0ZW1wZXJhdHVyZTogbnVtYmVyOyAgICAgICAvLyBEZWZhdWx0IHRlbXBlcmF0dXJlIGZvciBnZW5lcmF0aW9uXG4gIHN5c3RlbVByb21wdDogc3RyaW5nOyAgICAgIC8vIERlZmF1bHQgc3lzdGVtIHByb21wdCBmb3IgUkFHIHF1ZXJpZXNcbn1cblxuLyoqXG4gKiBBcHBsaWNhdGlvbiBBSSBzZXR0aW5nc1xuICovXG5leHBvcnQgY29uc3QgQUlfU0VUVElOR1M6IE1vZGVsU2V0dGluZ3MgPSB7XG4gIC8vIERlZmF1bHQgbW9kZWwgZm9yIHN0YW5kYXJkIG9wZXJhdGlvbnNcbiAgZGVmYXVsdE1vZGVsOiBwcm9jZXNzLmVudi5ERUZBVUxUX0xMTV9NT0RFTCB8fCAnZ3B0LTQnLFxuICBcbiAgLy8gRmFsbGJhY2sgbW9kZWwgd2hlbiBwcmltYXJ5IGlzIHVuYXZhaWxhYmxlIG9yIGZvciBsZXNzIGNyaXRpY2FsIG9wZXJhdGlvbnNcbiAgZmFsbGJhY2tNb2RlbDogcHJvY2Vzcy5lbnYuRkFMTEJBQ0tfTExNX01PREVMIHx8ICdncHQtMy41LXR1cmJvLTExMDYnLFxuICBcbiAgLy8gRW1iZWRkaW5nIG1vZGVsIGZvciB2ZWN0b3Igb3BlcmF0aW9uc1xuICBlbWJlZGRpbmdNb2RlbDogcHJvY2Vzcy5lbnYuRU1CRURESU5HX01PREVMIHx8ICd0ZXh0LWVtYmVkZGluZy1hZGEtMDAyJyxcbiAgXG4gIC8vIERlZmF1bHQgbWF4IHRva2VucyBmb3IgZ2VuZXJhdGlvblxuICBtYXhUb2tlbnM6IDEwMDAsXG4gIFxuICAvLyBEZWZhdWx0IHRlbXBlcmF0dXJlIGZvciBtb3N0IG9wZXJhdGlvbnNcbiAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgXG4gIC8vIERlZmF1bHQgc3lzdGVtIHByb21wdCBmb3IgUkFHIHF1ZXJpZXNcbiAgc3lzdGVtUHJvbXB0OiBgWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgZm9yIHRoZSBzYWxlcyB0ZWFtLiBcbkFuc3dlciB0aGUgcXVlc3Rpb24gYmFzZWQgT05MWSBvbiB0aGUgY29udGV4dCBwcm92aWRlZC4gXG5JZiB0aGUgYW5zd2VyIGNhbm5vdCBiZSBkZXRlcm1pbmVkIGZyb20gdGhlIGNvbnRleHQsIHNheSBcIkkgZG9uJ3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gYW5zd2VyIHRoaXMgcXVlc3Rpb24uXCJcbkRvIG5vdCBtYWtlIHVwIG9yIGluZmVyIGluZm9ybWF0aW9uIHRoYXQgaXMgbm90IGluIHRoZSBjb250ZXh0LlxuUHJvdmlkZSBjb25jaXNlLCBhY2N1cmF0ZSByZXNwb25zZXMgd2l0aCBhbGwgcmVsZXZhbnQgZGV0YWlscyBmcm9tIHRoZSBjb250ZXh0LmBcbn07XG5cbi8qKlxuICogRGlmZmVyZW50IHByZXNldCBzeXN0ZW0gcHJvbXB0cyBmb3IgdmFyaW91cyB1c2UgY2FzZXNcbiAqL1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9QUk9NUFRTID0ge1xuICBzdGFuZGFyZDogQUlfU0VUVElOR1Muc3lzdGVtUHJvbXB0LFxuICBcbiAgdGVjaG5pY2FsOiBgWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgZm9yIHRoZSBzYWxlcyB0ZWFtIHNwZWNpYWxpemluZyBpbiB0ZWNobmljYWwgcXVlc3Rpb25zLlxuQW5zd2VyIHRoZSBxdWVzdGlvbiBiYXNlZCBPTkxZIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVkLlxuVXNlIHRlY2huaWNhbCBsYW5ndWFnZSBhbmQgYmUgcHJlY2lzZSBpbiB5b3VyIGV4cGxhbmF0aW9ucy5cbklmIHRoZSBhbnN3ZXIgY2Fubm90IGJlIGRldGVybWluZWQgZnJvbSB0aGUgY29udGV4dCwgc2F5IFwiSSBkb24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBhbnN3ZXIgdGhpcyBxdWVzdGlvbi5cIlxuRG8gbm90IG1ha2UgdXAgb3IgaW5mZXIgaW5mb3JtYXRpb24gdGhhdCBpcyBub3QgaW4gdGhlIGNvbnRleHQuYCxcbiAgXG4gIHNhbGVzOiBgWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgZm9yIHRoZSBzYWxlcyB0ZWFtIHNwZWNpYWxpemluZyBpbiBzYWxlcyBxdWVyaWVzLlxuQW5zd2VyIHRoZSBxdWVzdGlvbiBiYXNlZCBPTkxZIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVkLlxuRm9jdXMgb24gdmFsdWUgcHJvcG9zaXRpb25zLCBjb21wZXRpdGl2ZSBhZHZhbnRhZ2VzLCBhbmQgYWRkcmVzc2luZyBjdXN0b21lciBwYWluIHBvaW50cy5cbklmIHRoZSBhbnN3ZXIgY2Fubm90IGJlIGRldGVybWluZWQgZnJvbSB0aGUgY29udGV4dCwgc2F5IFwiSSBkb24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBhbnN3ZXIgdGhpcyBxdWVzdGlvbi5cIlxuRG8gbm90IG1ha2UgdXAgb3IgaW5mZXIgaW5mb3JtYXRpb24gdGhhdCBpcyBub3QgaW4gdGhlIGNvbnRleHQuYCxcbiAgXG4gIHByaWNpbmc6IGBZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCBmb3IgdGhlIHNhbGVzIHRlYW0gc3BlY2lhbGl6aW5nIGluIHByaWNpbmcgcXVlc3Rpb25zLlxuQW5zd2VyIHRoZSBxdWVzdGlvbiBiYXNlZCBPTkxZIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVkLlxuQmUgdmVyeSBwcmVjaXNlIGFib3V0IHByaWNpbmcgZGV0YWlscywgcGxhbnMsIGFuZCBzdWJzY3JpcHRpb24gb3B0aW9ucy5cbklmIHRoZSBhbnN3ZXIgY2Fubm90IGJlIGRldGVybWluZWQgZnJvbSB0aGUgY29udGV4dCwgc2F5IFwiSSBkb24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBhbnN3ZXIgdGhpcyBxdWVzdGlvbi5cIlxuRG8gbm90IG1ha2UgdXAgb3IgaW5mZXIgaW5mb3JtYXRpb24gdGhhdCBpcyBub3QgaW4gdGhlIGNvbnRleHQuYFxufTtcblxuLyoqXG4gKiBHZXQgc3lzdGVtIHByb21wdCBiYXNlZCBvbiBxdWVyeSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTeXN0ZW1Qcm9tcHRGb3JRdWVyeShxdWVyeTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbG93ZXJRdWVyeSA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gIFxuICBpZiAobG93ZXJRdWVyeS5pbmNsdWRlcygncHJpY2UnKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ2Nvc3QnKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3N1YnNjcmlwdGlvbicpIHx8XG4gICAgICBsb3dlclF1ZXJ5LmluY2x1ZGVzKCdwbGFuJykpIHtcbiAgICByZXR1cm4gU1lTVEVNX1BST01QVFMucHJpY2luZztcbiAgfVxuICBcbiAgaWYgKGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3RlY2huaWNhbCcpIHx8IFxuICAgICAgbG93ZXJRdWVyeS5pbmNsdWRlcygnYXJjaGl0ZWN0dXJlJykgfHwgXG4gICAgICBsb3dlclF1ZXJ5LmluY2x1ZGVzKCdpbmZyYXN0cnVjdHVyZScpIHx8XG4gICAgICBsb3dlclF1ZXJ5LmluY2x1ZGVzKCdpbnRlZ3JhdGlvbicpKSB7XG4gICAgcmV0dXJuIFNZU1RFTV9QUk9NUFRTLnRlY2huaWNhbDtcbiAgfVxuICBcbiAgaWYgKGxvd2VyUXVlcnkuaW5jbHVkZXMoJ2NvbXBldGl0b3InKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ2NvbXBhcmlzb24nKSB8fCBcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3ZzJykgfHxcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3BpdGNoJykgfHxcbiAgICAgIGxvd2VyUXVlcnkuaW5jbHVkZXMoJ3NlbGwnKSkge1xuICAgIHJldHVybiBTWVNURU1fUFJPTVBUUy5zYWxlcztcbiAgfVxuICBcbiAgcmV0dXJuIFNZU1RFTV9QUk9NUFRTLnN0YW5kYXJkO1xufSAiXSwibmFtZXMiOlsiQUlfU0VUVElOR1MiLCJkZWZhdWx0TW9kZWwiLCJwcm9jZXNzIiwiZW52IiwiREVGQVVMVF9MTE1fTU9ERUwiLCJmYWxsYmFja01vZGVsIiwiRkFMTEJBQ0tfTExNX01PREVMIiwiZW1iZWRkaW5nTW9kZWwiLCJFTUJFRERJTkdfTU9ERUwiLCJtYXhUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInN5c3RlbVByb21wdCIsIlNZU1RFTV9QUk9NUFRTIiwic3RhbmRhcmQiLCJ0ZWNobmljYWwiLCJzYWxlcyIsInByaWNpbmciLCJnZXRTeXN0ZW1Qcm9tcHRGb3JRdWVyeSIsInF1ZXJ5IiwibG93ZXJRdWVyeSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./utils/modelConfig.ts\n");

/***/ }),

/***/ "(api)/./utils/openaiClient.ts":
/*!*******************************!*\
  !*** ./utils/openaiClient.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchProcessPrompts: () => (/* binding */ batchProcessPrompts),\n/* harmony export */   embedText: () => (/* binding */ embedText),\n/* harmony export */   generateChatCompletion: () => (/* binding */ generateChatCompletion),\n/* harmony export */   generateStructuredResponse: () => (/* binding */ generateStructuredResponse),\n/* harmony export */   openai: () => (/* binding */ openai),\n/* harmony export */   rankTextsForQuery: () => (/* binding */ rankTextsForQuery)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"openai\");\n/* harmony import */ var _modelConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modelConfig */ \"(api)/./utils/modelConfig.ts\");\n/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errorHandling */ \"(api)/./utils/errorHandling.ts\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dotenv */ \"dotenv\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_3__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([openai__WEBPACK_IMPORTED_MODULE_0__, _errorHandling__WEBPACK_IMPORTED_MODULE_2__]);\n([openai__WEBPACK_IMPORTED_MODULE_0__, _errorHandling__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * OpenAI client utility for the RAG system\n * Handles API interactions with OpenAI including embeddings and chat completions\n */ \n\n\n\n// Load environment variables\ndotenv__WEBPACK_IMPORTED_MODULE_3__.config();\n// Initialize OpenAI client\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_0__.OpenAI({\n    apiKey: process.env.OPENAI_API_KEY\n});\n/**\n * Generate embeddings for text using OpenAI\n * Used for vector similarity search\n */ async function embedText(text) {\n    try {\n        // Clean and prepare text\n        const cleanedText = text.trim().replace(/\\n+/g, \" \");\n        // Get embedding from OpenAI\n        const response = await openai.embeddings.create({\n            model: _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.embeddingModel,\n            input: cleanedText\n        });\n        // Return the embedding vector\n        return response.data[0].embedding;\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(error, \"embedText\");\n        // In case of error, return a zero vector as fallback\n        // This should be handled by the calling function\n        console.error(\"Error generating embedding:\", error);\n        return Array(1536).fill(0);\n    }\n}\n/**\n * Generate a chat completion using OpenAI\n */ async function generateChatCompletion(systemPrompt, userPrompt, model = _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.defaultModel, jsonMode = false) {\n    try {\n        const messages = [\n            {\n                role: \"system\",\n                content: systemPrompt\n            },\n            {\n                role: \"user\",\n                content: userPrompt\n            }\n        ];\n        // If model isn't specified, use default\n        const modelToUse = model || _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.defaultModel;\n        // Only include response_format if jsonMode is true and we're using a compatible model (GPT-4 and above)\n        const supportsJsonMode = modelToUse.includes(\"gpt-4\") || modelToUse.includes(\"gpt-3.5-turbo-16k\") || modelToUse.includes(\"gpt-3.5-turbo-1106\");\n        // Call OpenAI API\n        const response = await openai.chat.completions.create({\n            model: modelToUse,\n            messages,\n            temperature: _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.temperature,\n            max_tokens: _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.maxTokens,\n            response_format: jsonMode && supportsJsonMode ? {\n                type: \"json_object\"\n            } : undefined\n        });\n        // Extract and return the response text\n        return response.choices[0].message.content || \"\";\n    } catch (error) {\n        console.error(\"Error generating chat completion:\", error);\n        // Try fallback model if primary fails\n        if (model === _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.defaultModel) {\n            console.log(\"Attempting with fallback model...\");\n            return generateChatCompletion(systemPrompt, userPrompt, _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.fallbackModel, jsonMode);\n        }\n        // If fallback also fails, return error message\n        return \"I apologize, but I encountered an issue processing your request. Please try again later.\";\n    }\n}\n/**\n * Generate a structured response with JSON output\n */ async function generateStructuredResponse(systemPrompt, userPrompt, responseSchema, model = _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.defaultModel) {\n    try {\n        // Append schema information to system prompt\n        const schemaPrompt = `${systemPrompt}\n    \nReturn your response in the following JSON format:\n${JSON.stringify(responseSchema, null, 2)}\n\nYour response MUST be a valid JSON object with no additional text, explanations, or formatting.`;\n        // Generate completion with JSON mode enabled if the model supports it\n        const response = await generateChatCompletion(schemaPrompt, userPrompt, model, true);\n        try {\n            // Try to parse JSON response\n            return JSON.parse(response);\n        } catch (jsonError) {\n            // If JSON parsing fails, try to extract JSON from the response\n            // This can happen with models that don't support jsonMode\n            const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                return JSON.parse(jsonMatch[0]);\n            }\n            console.error(\"Failed to parse JSON response:\", jsonError);\n            return null;\n        }\n    } catch (error) {\n        console.error(\"Error generating structured response:\", error);\n        return null;\n    }\n}\n/**\n * Batch process multiple prompts with a single API call \n * Useful for re-ranking to save on API calls\n */ async function batchProcessPrompts(systemPrompt, userPrompts, model = _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.defaultModel, options = {}) {\n    // Set a timeout\n    const timeoutMs = options.timeoutMs || 10000;\n    try {\n        // Create a Promise for the API call\n        const apiPromise = Promise.all(userPrompts.map((userPrompt)=>generateChatCompletion(systemPrompt, userPrompt, model, options.jsonMode || false)));\n        // Create a timeout Promise\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(`Batch processing timed out after ${timeoutMs}ms`));\n            }, timeoutMs);\n        });\n        // Race the API call against the timeout\n        return await Promise.race([\n            apiPromise,\n            timeoutPromise\n        ]);\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(error, \"batchProcessPrompts\");\n        // Return empty results on error\n        return userPrompts.map(()=>\"\");\n    }\n}\n/**\n * Process a batch of texts with an LLM for re-ranking\n * Specialized function for re-ranking that processes multiple documents\n * with a single API call for efficiency\n */ async function rankTextsForQuery(query, texts, model = _modelConfig__WEBPACK_IMPORTED_MODULE_1__.AI_SETTINGS.fallbackModel, options = {}) {\n    try {\n        // Create the system prompt for re-ranking\n        const systemPrompt = `You are a document relevance judge. Rate how relevant each document is to the query on a scale of 0-10 where:\n- 10: Perfect match with specific details answering the query\n- 7-9: Highly relevant with key information related to the query\n- 4-6: Somewhat relevant but lacks specific details\n- 1-3: Only tangentially related to the query\n- 0: Not relevant at all\n\nReturn a JSON object with only scores in this format:\n{\"scores\": [score1, score2, ...]}\n\nYour response MUST be a valid JSON object with no additional text, explanations, or formatting.`;\n        // Create a single user prompt with all texts\n        const userPrompt = `Query: ${query}\n\n${texts.map((text, i)=>`DOCUMENT ${i + 1}:\n${text.substring(0, 600)}${text.length > 600 ? \"...\" : \"\"}`).join(\"\\n\\n\")}\n\nProvide a relevance score from 0-10 for each document based on how well it answers the query.`;\n        // Generate the ranking with a timeout\n        const timeoutMs = options.timeoutMs || 15000;\n        const rankingPromise = generateStructuredResponse(systemPrompt, userPrompt, {\n            scores: []\n        }, model);\n        // Create a timeout Promise\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(`Re-ranking timed out after ${timeoutMs}ms`));\n            }, timeoutMs);\n        });\n        // Race the API call against the timeout\n        const response = await Promise.race([\n            rankingPromise,\n            timeoutPromise\n        ]);\n        // Return scores\n        if (response && Array.isArray(response.scores)) {\n            return response.scores;\n        } else {\n            console.warn(\"Invalid scores format received, using default scores\");\n            return texts.map(()=>5); // Default to middle score if failed\n        }\n    } catch (error) {\n        console.error(\"Error in rankTextsForQuery:\", error);\n        return texts.map(()=>5); // Default score on error\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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THpELFFBQVEyRCxJQUFJLENBQUM7WUFDYixPQUFPUixNQUFNVCxHQUFHLENBQUMsSUFBTSxJQUFJLG9DQUFvQztRQUNqRTtJQUNGLEVBQUUsT0FBTzNDLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsT0FBT29ELE1BQU1ULEdBQUcsQ0FBQyxJQUFNLElBQUkseUJBQXlCO0lBQ3REO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWxlcy1jaGF0LW9wZW5haS1yYWcvLi91dGlscy9vcGVuYWlDbGllbnQudHM/YTA0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9wZW5BSSBjbGllbnQgdXRpbGl0eSBmb3IgdGhlIFJBRyBzeXN0ZW1cbiAqIEhhbmRsZXMgQVBJIGludGVyYWN0aW9ucyB3aXRoIE9wZW5BSSBpbmNsdWRpbmcgZW1iZWRkaW5ncyBhbmQgY2hhdCBjb21wbGV0aW9uc1xuICovXG5cbmltcG9ydCB7IE9wZW5BSSB9IGZyb20gJ29wZW5haSc7XG5pbXBvcnQgeyBBSV9TRVRUSU5HUyB9IGZyb20gJy4vbW9kZWxDb25maWcnO1xuaW1wb3J0IHsgbG9nRXJyb3IgfSBmcm9tICcuL2Vycm9ySGFuZGxpbmcnO1xuaW1wb3J0ICogYXMgZG90ZW52IGZyb20gJ2RvdGVudic7XG5cbi8vIExvYWQgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5kb3RlbnYuY29uZmlnKCk7XG5cbi8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudFxuZXhwb3J0IGNvbnN0IG9wZW5haSA9IG5ldyBPcGVuQUkoe1xuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZLFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgdGV4dCB1c2luZyBPcGVuQUlcbiAqIFVzZWQgZm9yIHZlY3RvciBzaW1pbGFyaXR5IHNlYXJjaFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW1iZWRUZXh0KHRleHQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyW10+IHtcbiAgdHJ5IHtcbiAgICAvLyBDbGVhbiBhbmQgcHJlcGFyZSB0ZXh0XG4gICAgY29uc3QgY2xlYW5lZFRleHQgPSB0ZXh0LnRyaW0oKS5yZXBsYWNlKC9cXG4rL2csICcgJyk7XG4gICAgXG4gICAgLy8gR2V0IGVtYmVkZGluZyBmcm9tIE9wZW5BSVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmVtYmVkZGluZ3MuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiBBSV9TRVRUSU5HUy5lbWJlZGRpbmdNb2RlbCxcbiAgICAgIGlucHV0OiBjbGVhbmVkVGV4dCxcbiAgICB9KTtcbiAgICBcbiAgICAvLyBSZXR1cm4gdGhlIGVtYmVkZGluZyB2ZWN0b3JcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVswXS5lbWJlZGRpbmc7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nRXJyb3IoZXJyb3IsICdlbWJlZFRleHQnKTtcbiAgICBcbiAgICAvLyBJbiBjYXNlIG9mIGVycm9yLCByZXR1cm4gYSB6ZXJvIHZlY3RvciBhcyBmYWxsYmFja1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIGNhbGxpbmcgZnVuY3Rpb25cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIEFycmF5KDE1MzYpLmZpbGwoMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGNoYXQgbWVzc2FnZSBmb3JtYXRcbiAqL1xuaW50ZXJmYWNlIENoYXRNZXNzYWdlIHtcbiAgcm9sZTogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JztcbiAgY29udGVudDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgY2hhdCBjb21wbGV0aW9uIHVzaW5nIE9wZW5BSVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDaGF0Q29tcGxldGlvbihcbiAgc3lzdGVtUHJvbXB0OiBzdHJpbmcsXG4gIHVzZXJQcm9tcHQ6IHN0cmluZyxcbiAgbW9kZWw6IHN0cmluZyA9IEFJX1NFVFRJTkdTLmRlZmF1bHRNb2RlbCxcbiAganNvbk1vZGU6IGJvb2xlYW4gPSBmYWxzZVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgIGNvbnRlbnQ6IHN5c3RlbVByb21wdCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogdXNlclByb21wdCxcbiAgICAgIH0sXG4gICAgXTtcbiAgICBcbiAgICAvLyBJZiBtb2RlbCBpc24ndCBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IG1vZGVsIHx8IEFJX1NFVFRJTkdTLmRlZmF1bHRNb2RlbDtcbiAgICBcbiAgICAvLyBPbmx5IGluY2x1ZGUgcmVzcG9uc2VfZm9ybWF0IGlmIGpzb25Nb2RlIGlzIHRydWUgYW5kIHdlJ3JlIHVzaW5nIGEgY29tcGF0aWJsZSBtb2RlbCAoR1BULTQgYW5kIGFib3ZlKVxuICAgIGNvbnN0IHN1cHBvcnRzSnNvbk1vZGUgPSBtb2RlbFRvVXNlLmluY2x1ZGVzKCdncHQtNCcpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UuaW5jbHVkZXMoJ2dwdC0zLjUtdHVyYm8tMTZrJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZS5pbmNsdWRlcygnZ3B0LTMuNS10dXJiby0xMTA2Jyk7XG4gICAgXG4gICAgLy8gQ2FsbCBPcGVuQUkgQVBJXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IG1vZGVsVG9Vc2UsXG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHRlbXBlcmF0dXJlOiBBSV9TRVRUSU5HUy50ZW1wZXJhdHVyZSxcbiAgICAgIG1heF90b2tlbnM6IEFJX1NFVFRJTkdTLm1heFRva2VucyxcbiAgICAgIHJlc3BvbnNlX2Zvcm1hdDoganNvbk1vZGUgJiYgc3VwcG9ydHNKc29uTW9kZSA/IHsgdHlwZTogJ2pzb25fb2JqZWN0JyB9IDogdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgYW5kIHJldHVybiB0aGUgcmVzcG9uc2UgdGV4dFxuICAgIHJldHVybiByZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudCB8fCAnJztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGNoYXQgY29tcGxldGlvbjonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gVHJ5IGZhbGxiYWNrIG1vZGVsIGlmIHByaW1hcnkgZmFpbHNcbiAgICBpZiAobW9kZWwgPT09IEFJX1NFVFRJTkdTLmRlZmF1bHRNb2RlbCkge1xuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgd2l0aCBmYWxsYmFjayBtb2RlbC4uLicpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICAgIHN5c3RlbVByb21wdCxcbiAgICAgICAgdXNlclByb21wdCxcbiAgICAgICAgQUlfU0VUVElOR1MuZmFsbGJhY2tNb2RlbCxcbiAgICAgICAganNvbk1vZGVcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIGZhbGxiYWNrIGFsc28gZmFpbHMsIHJldHVybiBlcnJvciBtZXNzYWdlXG4gICAgcmV0dXJuICdJIGFwb2xvZ2l6ZSwgYnV0IEkgZW5jb3VudGVyZWQgYW4gaXNzdWUgcHJvY2Vzc2luZyB5b3VyIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RydWN0dXJlZCByZXNwb25zZSB3aXRoIEpTT04gb3V0cHV0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVN0cnVjdHVyZWRSZXNwb25zZShcbiAgc3lzdGVtUHJvbXB0OiBzdHJpbmcsXG4gIHVzZXJQcm9tcHQ6IHN0cmluZyxcbiAgcmVzcG9uc2VTY2hlbWE6IGFueSxcbiAgbW9kZWw6IHN0cmluZyA9IEFJX1NFVFRJTkdTLmRlZmF1bHRNb2RlbFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICAvLyBBcHBlbmQgc2NoZW1hIGluZm9ybWF0aW9uIHRvIHN5c3RlbSBwcm9tcHRcbiAgICBjb25zdCBzY2hlbWFQcm9tcHQgPSBgJHtzeXN0ZW1Qcm9tcHR9XG4gICAgXG5SZXR1cm4geW91ciByZXNwb25zZSBpbiB0aGUgZm9sbG93aW5nIEpTT04gZm9ybWF0OlxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZVNjaGVtYSwgbnVsbCwgMil9XG5cbllvdXIgcmVzcG9uc2UgTVVTVCBiZSBhIHZhbGlkIEpTT04gb2JqZWN0IHdpdGggbm8gYWRkaXRpb25hbCB0ZXh0LCBleHBsYW5hdGlvbnMsIG9yIGZvcm1hdHRpbmcuYDtcblxuICAgIC8vIEdlbmVyYXRlIGNvbXBsZXRpb24gd2l0aCBKU09OIG1vZGUgZW5hYmxlZCBpZiB0aGUgbW9kZWwgc3VwcG9ydHMgaXRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdlbmVyYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICBzY2hlbWFQcm9tcHQsXG4gICAgICB1c2VyUHJvbXB0LFxuICAgICAgbW9kZWwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChqc29uRXJyb3IpIHtcbiAgICAgIC8vIElmIEpTT04gcGFyc2luZyBmYWlscywgdHJ5IHRvIGV4dHJhY3QgSlNPTiBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdpdGggbW9kZWxzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBqc29uTW9kZVxuICAgICAgY29uc3QganNvbk1hdGNoID0gcmVzcG9uc2UubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2U6JywganNvbkVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIHN0cnVjdHVyZWQgcmVzcG9uc2U6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQmF0Y2ggcHJvY2VzcyBtdWx0aXBsZSBwcm9tcHRzIHdpdGggYSBzaW5nbGUgQVBJIGNhbGwgXG4gKiBVc2VmdWwgZm9yIHJlLXJhbmtpbmcgdG8gc2F2ZSBvbiBBUEkgY2FsbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhdGNoUHJvY2Vzc1Byb21wdHMoXG4gIHN5c3RlbVByb21wdDogc3RyaW5nLFxuICB1c2VyUHJvbXB0czogc3RyaW5nW10sXG4gIG1vZGVsOiBzdHJpbmcgPSBBSV9TRVRUSU5HUy5kZWZhdWx0TW9kZWwsXG4gIG9wdGlvbnM6IHtcbiAgICB0aW1lb3V0TXM/OiBudW1iZXI7XG4gICAganNvbk1vZGU/OiBib29sZWFuO1xuICB9ID0ge31cbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgLy8gU2V0IGEgdGltZW91dFxuICBjb25zdCB0aW1lb3V0TXMgPSBvcHRpb25zLnRpbWVvdXRNcyB8fCAxMDAwMDtcbiAgXG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIGEgUHJvbWlzZSBmb3IgdGhlIEFQSSBjYWxsXG4gICAgY29uc3QgYXBpUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgICAgdXNlclByb21wdHMubWFwKHVzZXJQcm9tcHQgPT4gXG4gICAgICAgIGdlbmVyYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICAgICAgc3lzdGVtUHJvbXB0LFxuICAgICAgICAgIHVzZXJQcm9tcHQsXG4gICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgb3B0aW9ucy5qc29uTW9kZSB8fCBmYWxzZVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSB0aW1lb3V0IFByb21pc2VcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZ1tdPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQmF0Y2ggcHJvY2Vzc2luZyB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFJhY2UgdGhlIEFQSSBjYWxsIGFnYWluc3QgdGhlIHRpbWVvdXRcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKFthcGlQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ0Vycm9yKGVycm9yLCAnYmF0Y2hQcm9jZXNzUHJvbXB0cycpO1xuICAgIFxuICAgIC8vIFJldHVybiBlbXB0eSByZXN1bHRzIG9uIGVycm9yXG4gICAgcmV0dXJuIHVzZXJQcm9tcHRzLm1hcCgoKSA9PiBcIlwiKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBiYXRjaCBvZiB0ZXh0cyB3aXRoIGFuIExMTSBmb3IgcmUtcmFua2luZ1xuICogU3BlY2lhbGl6ZWQgZnVuY3Rpb24gZm9yIHJlLXJhbmtpbmcgdGhhdCBwcm9jZXNzZXMgbXVsdGlwbGUgZG9jdW1lbnRzXG4gKiB3aXRoIGEgc2luZ2xlIEFQSSBjYWxsIGZvciBlZmZpY2llbmN5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYW5rVGV4dHNGb3JRdWVyeShcbiAgcXVlcnk6IHN0cmluZyxcbiAgdGV4dHM6IHN0cmluZ1tdLFxuICBtb2RlbDogc3RyaW5nID0gQUlfU0VUVElOR1MuZmFsbGJhY2tNb2RlbCxcbiAgb3B0aW9uczoge1xuICAgIHJldHVyblNjb3Jlc09ubHk/OiBib29sZWFuO1xuICAgIHRpbWVvdXRNcz86IG51bWJlcjtcbiAgfSA9IHt9XG4pOiBQcm9taXNlPG51bWJlcltdPiB7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBzeXN0ZW0gcHJvbXB0IGZvciByZS1yYW5raW5nXG4gICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gYFlvdSBhcmUgYSBkb2N1bWVudCByZWxldmFuY2UganVkZ2UuIFJhdGUgaG93IHJlbGV2YW50IGVhY2ggZG9jdW1lbnQgaXMgdG8gdGhlIHF1ZXJ5IG9uIGEgc2NhbGUgb2YgMC0xMCB3aGVyZTpcbi0gMTA6IFBlcmZlY3QgbWF0Y2ggd2l0aCBzcGVjaWZpYyBkZXRhaWxzIGFuc3dlcmluZyB0aGUgcXVlcnlcbi0gNy05OiBIaWdobHkgcmVsZXZhbnQgd2l0aCBrZXkgaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgcXVlcnlcbi0gNC02OiBTb21ld2hhdCByZWxldmFudCBidXQgbGFja3Mgc3BlY2lmaWMgZGV0YWlsc1xuLSAxLTM6IE9ubHkgdGFuZ2VudGlhbGx5IHJlbGF0ZWQgdG8gdGhlIHF1ZXJ5XG4tIDA6IE5vdCByZWxldmFudCBhdCBhbGxcblxuUmV0dXJuIGEgSlNPTiBvYmplY3Qgd2l0aCBvbmx5IHNjb3JlcyBpbiB0aGlzIGZvcm1hdDpcbntcInNjb3Jlc1wiOiBbc2NvcmUxLCBzY29yZTIsIC4uLl19XG5cbllvdXIgcmVzcG9uc2UgTVVTVCBiZSBhIHZhbGlkIEpTT04gb2JqZWN0IHdpdGggbm8gYWRkaXRpb25hbCB0ZXh0LCBleHBsYW5hdGlvbnMsIG9yIGZvcm1hdHRpbmcuYDtcblxuICAgIC8vIENyZWF0ZSBhIHNpbmdsZSB1c2VyIHByb21wdCB3aXRoIGFsbCB0ZXh0c1xuICAgIGNvbnN0IHVzZXJQcm9tcHQgPSBgUXVlcnk6ICR7cXVlcnl9XG5cbiR7dGV4dHMubWFwKCh0ZXh0LCBpKSA9PiBgRE9DVU1FTlQgJHtpKzF9OlxuJHt0ZXh0LnN1YnN0cmluZygwLCA2MDApfSR7dGV4dC5sZW5ndGggPiA2MDAgPyAnLi4uJyA6ICcnfWApLmpvaW4oJ1xcblxcbicpfVxuXG5Qcm92aWRlIGEgcmVsZXZhbmNlIHNjb3JlIGZyb20gMC0xMCBmb3IgZWFjaCBkb2N1bWVudCBiYXNlZCBvbiBob3cgd2VsbCBpdCBhbnN3ZXJzIHRoZSBxdWVyeS5gO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIHJhbmtpbmcgd2l0aCBhIHRpbWVvdXRcbiAgICBjb25zdCB0aW1lb3V0TXMgPSBvcHRpb25zLnRpbWVvdXRNcyB8fCAxNTAwMDtcbiAgICBjb25zdCByYW5raW5nUHJvbWlzZSA9IGdlbmVyYXRlU3RydWN0dXJlZFJlc3BvbnNlKFxuICAgICAgc3lzdGVtUHJvbXB0LFxuICAgICAgdXNlclByb21wdCxcbiAgICAgIHsgc2NvcmVzOiBbXSB9LFxuICAgICAgbW9kZWxcbiAgICApO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHRpbWVvdXQgUHJvbWlzZVxuICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2U8YW55PigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUmUtcmFua2luZyB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFJhY2UgdGhlIEFQSSBjYWxsIGFnYWluc3QgdGhlIHRpbWVvdXRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZShbcmFua2luZ1Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgXG4gICAgLy8gUmV0dXJuIHNjb3Jlc1xuICAgIGlmIChyZXNwb25zZSAmJiBBcnJheS5pc0FycmF5KHJlc3BvbnNlLnNjb3JlcykpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5zY29yZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBzY29yZXMgZm9ybWF0IHJlY2VpdmVkLCB1c2luZyBkZWZhdWx0IHNjb3JlcycpO1xuICAgICAgcmV0dXJuIHRleHRzLm1hcCgoKSA9PiA1KTsgLy8gRGVmYXVsdCB0byBtaWRkbGUgc2NvcmUgaWYgZmFpbGVkXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJhbmtUZXh0c0ZvclF1ZXJ5OicsIGVycm9yKTtcbiAgICByZXR1cm4gdGV4dHMubWFwKCgpID0+IDUpOyAvLyBEZWZhdWx0IHNjb3JlIG9uIGVycm9yXG4gIH1cbn0gIl0sIm5hbWVzIjpbIk9wZW5BSSIsIkFJX1NFVFRJTkdTIiwibG9nRXJyb3IiLCJkb3RlbnYiLCJjb25maWciLCJvcGVuYWkiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiT1BFTkFJX0FQSV9LRVkiLCJlbWJlZFRleHQiLCJ0ZXh0IiwiY2xlYW5lZFRleHQiLCJ0cmltIiwicmVwbGFjZSIsInJlc3BvbnNlIiwiZW1iZWRkaW5ncyIsImNyZWF0ZSIsIm1vZGVsIiwiZW1iZWRkaW5nTW9kZWwiLCJpbnB1dCIsImRhdGEiLCJlbWJlZGRpbmciLCJlcnJvciIsImNvbnNvbGUiLCJBcnJheSIsImZpbGwiLCJnZW5lcmF0ZUNoYXRDb21wbGV0aW9uIiwic3lzdGVtUHJvbXB0IiwidXNlclByb21wdCIsImRlZmF1bHRNb2RlbCIsImpzb25Nb2RlIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsIm1vZGVsVG9Vc2UiLCJzdXBwb3J0c0pzb25Nb2RlIiwiaW5jbHVkZXMiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJtYXhUb2tlbnMiLCJyZXNwb25zZV9mb3JtYXQiLCJ0eXBlIiwidW5kZWZpbmVkIiwiY2hvaWNlcyIsIm1lc3NhZ2UiLCJsb2ciLCJmYWxsYmFja01vZGVsIiwiZ2VuZXJhdGVTdHJ1Y3R1cmVkUmVzcG9uc2UiLCJyZXNwb25zZVNjaGVtYSIsInNjaGVtYVByb21wdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsImpzb25FcnJvciIsImpzb25NYXRjaCIsIm1hdGNoIiwiYmF0Y2hQcm9jZXNzUHJvbXB0cyIsInVzZXJQcm9tcHRzIiwib3B0aW9ucyIsInRpbWVvdXRNcyIsImFwaVByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsIkVycm9yIiwicmFjZSIsInJhbmtUZXh0c0ZvclF1ZXJ5IiwicXVlcnkiLCJ0ZXh0cyIsImkiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJqb2luIiwicmFua2luZ1Byb21pc2UiLCJzY29yZXMiLCJpc0FycmF5Iiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/openaiClient.ts\n");

/***/ }),

/***/ "(api)/./utils/queryExpansion.ts":
/*!*********************************!*\
  !*** ./utils/queryExpansion.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_EXPANSION_OPTIONS: () => (/* binding */ DEFAULT_EXPANSION_OPTIONS),\n/* harmony export */   analyzeQuery: () => (/* binding */ analyzeQuery),\n/* harmony export */   expandQuery: () => (/* binding */ expandQuery),\n/* harmony export */   keywordQueryExpansion: () => (/* binding */ keywordQueryExpansion),\n/* harmony export */   semanticQueryExpansion: () => (/* binding */ semanticQueryExpansion)\n/* harmony export */ });\n/* harmony import */ var _openaiClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./openaiClient */ \"(api)/./utils/openaiClient.ts\");\n/* harmony import */ var _tokenization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenization */ \"(api)/./utils/tokenization.ts\");\n/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errorHandling */ \"(api)/./utils/errorHandling.ts\");\n/* harmony import */ var _caching__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./caching */ \"(api)/./utils/caching.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_openaiClient__WEBPACK_IMPORTED_MODULE_0__, _errorHandling__WEBPACK_IMPORTED_MODULE_2__]);\n([_openaiClient__WEBPACK_IMPORTED_MODULE_0__, _errorHandling__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Query Expansion Module\n * \n * This module provides functionality to expand user queries with related terms\n * to improve retrieval performance, especially for complex or ambiguous queries.\n */ \n\n\n\n/**\n * Default options for query expansion\n */ const DEFAULT_EXPANSION_OPTIONS = {\n    maxExpandedTerms: 4,\n    model: \"gpt-3.5-turbo\",\n    useSemanticExpansion: true,\n    useKeywordExpansion: true,\n    semanticWeight: 0.7,\n    includeMetadata: true,\n    timeoutMs: 2000,\n    enableCaching: true,\n    cacheTtlSeconds: 86400,\n    debug: false\n};\n/**\n * Expand a query using semantic techniques (LLM-based)\n * \n * This approach uses language models to understand query intent\n * and generate related terms.\n */ async function semanticQueryExpansion(query, options = {}) {\n    const config = {\n        ...DEFAULT_EXPANSION_OPTIONS,\n        ...options\n    };\n    const startTime = Date.now();\n    // Try to get cached result if caching is enabled\n    if (config.enableCaching) {\n        const cacheKey = `semantic_expansion:${query}`;\n        const cachedResult = await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.getCachedResult)(cacheKey);\n        if (cachedResult) {\n            if (config.debug) {\n                console.log(`Cache hit for semantic expansion of query: \"${query}\"`);\n            }\n            return cachedResult;\n        }\n    }\n    try {\n        // Create system prompt for semantic expansion\n        // More targeted prompt based on query type to improve relevance\n        const systemPrompt = `You are an expert in information retrieval helping to improve search quality.\nYour task is to expand the user's query with related terms to improve search results.\nFocus on adding precise, targeted phrases that might appear in relevant documents.\nThe phrases should be concise (2-5 words) and directly related to the original query.\nDo NOT change the original meaning or intent of the query.\nReturn ONLY a JSON array of additional search terms (no explanations).\nLimit your response to the most effective expansion terms.`;\n        // Create user prompt - using better instruction for more focused expansion\n        const userPrompt = `Original Query: ${query}\n    \nPlease provide up to ${config.maxExpandedTerms} additional phrases that would be effective for retrieving relevant documents.\nConsider:\n- Alternative terminology experts might use\n- Specific phrases likely to appear in authoritative sources\n- Terms that clarify ambiguous aspects of the query\n- Focus on precision over recall\n\nReturn as a JSON array of strings.`;\n        // Set up timeout for semantic expansion\n        const expansionPromise = (0,_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateStructuredResponse)(systemPrompt, userPrompt, [], config.model);\n        // Add timeout using AbortController instead of Promise.race for cleaner cancellation\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), config.timeoutMs);\n        try {\n            // Try structured response first (most reliable)\n            const result = await expansionPromise;\n            clearTimeout(timeoutId);\n            if (Array.isArray(result)) {\n                const validTerms = result.filter((term)=>typeof term === \"string\" && term.length > 0 && term.length < 60 && // Reasonable length limit\n                    !query.toLowerCase().includes(term.toLowerCase())).slice(0, config.maxExpandedTerms);\n                // Cache the result if caching is enabled\n                if (config.enableCaching && validTerms.length > 0) {\n                    const cacheKey = `semantic_expansion:${query}`;\n                    await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.cacheResult)(cacheKey, validTerms, config.cacheTtlSeconds);\n                }\n                return validTerms;\n            }\n        } catch (structuredError) {\n            // If structured response fails, try fallback\n            if (config.debug) {\n                console.log(`Structured expansion failed for \"${query}\". Using fallback.`);\n            }\n        }\n        // Fallback to simpler expansion if structured response fails\n        try {\n            const fallbackResponse = await (0,_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateChatCompletion)(\"You are a search query expansion expert. Provide only related search terms, no explanations.\", `Generate ${config.maxExpandedTerms} search terms related to: \"${query}\"\\nReturn one term per line, no numbering or bullets.`, config.model, false);\n            // Parse the response to extract terms (one per line)\n            const terms = fallbackResponse.split(\"\\n\").map((line)=>line.trim().replace(/^[â€¢\\-\\d.\\s]+/, \"\")) // Remove bullets, numbers\n            .filter((line)=>line && !line.startsWith(\"-\") && line.length > 2 && line.length < 60 && !query.toLowerCase().includes(line.toLowerCase())).slice(0, config.maxExpandedTerms);\n            // Cache the result if caching is enabled\n            if (config.enableCaching && terms.length > 0) {\n                const cacheKey = `semantic_expansion:${query}`;\n                await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.cacheResult)(cacheKey, terms, config.cacheTtlSeconds);\n            }\n            return terms;\n        } catch (fallbackError) {\n            (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(fallbackError, \"semanticQueryExpansion:fallback\");\n            return []; // Return empty array if all methods fail\n        }\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(error, \"semanticQueryExpansion\");\n        return []; // Return empty array on error\n    } finally{\n        if (config.debug) {\n            const duration = Date.now() - startTime;\n            console.log(`Semantic expansion took ${duration}ms for query: \"${query}\"`);\n        }\n    }\n}\n/**\n * Expand a query using keyword-based techniques\n * \n * This simpler approach uses word forms, common synonyms, and\n * domain-specific transformations.\n */ function keywordQueryExpansion(query, options = {}) {\n    const config = {\n        ...DEFAULT_EXPANSION_OPTIONS,\n        ...options\n    };\n    const startTime = Date.now();\n    // Try to get cached result if caching is enabled\n    if (config.enableCaching) {\n        const cacheKey = `keyword_expansion:${query}`;\n        const cachedResult = (0,_caching__WEBPACK_IMPORTED_MODULE_3__.getCachedResult)(cacheKey);\n        if (cachedResult && Array.isArray(cachedResult)) {\n            if (config.debug) {\n                console.log(`Cache hit for keyword expansion of query: \"${query}\"`);\n            }\n            return cachedResult;\n        }\n    }\n    try {\n        // Tokenize the query\n        const tokens = (0,_tokenization__WEBPACK_IMPORTED_MODULE_1__.tokenize)(query);\n        const expandedTerms = [];\n        const queryLower = query.toLowerCase();\n        // Common business terms synonyms/related terms - expanded with more relevant terms\n        const synonymMap = {\n            \"price\": [\n                \"cost\",\n                \"pricing\",\n                \"fee\",\n                \"subscription\",\n                \"pricing plans\"\n            ],\n            \"pricing\": [\n                \"price\",\n                \"cost\",\n                \"fee\",\n                \"subscription\",\n                \"rate card\"\n            ],\n            \"cost\": [\n                \"price\",\n                \"pricing\",\n                \"expense\",\n                \"fee\",\n                \"budget\"\n            ],\n            \"discount\": [\n                \"offer\",\n                \"deal\",\n                \"promotion\",\n                \"reduced\",\n                \"savings\",\n                \"special offer\"\n            ],\n            \"feature\": [\n                \"capability\",\n                \"functionality\",\n                \"option\",\n                \"service\",\n                \"tool\"\n            ],\n            \"security\": [\n                \"protection\",\n                \"privacy\",\n                \"secure\",\n                \"encryption\",\n                \"data protection\"\n            ],\n            \"support\": [\n                \"help\",\n                \"assistance\",\n                \"service\",\n                \"customer service\",\n                \"technical support\"\n            ],\n            \"compare\": [\n                \"comparison\",\n                \"versus\",\n                \"vs\",\n                \"difference\",\n                \"competitive analysis\"\n            ],\n            \"competitor\": [\n                \"competition\",\n                \"alternative\",\n                \"rival\",\n                \"industry peer\",\n                \"market competitor\"\n            ],\n            \"enterprise\": [\n                \"business\",\n                \"corporate\",\n                \"company\",\n                \"organization\",\n                \"large company\"\n            ],\n            \"plan\": [\n                \"package\",\n                \"tier\",\n                \"subscription\",\n                \"offering\",\n                \"service level\"\n            ],\n            \"basic\": [\n                \"starter\",\n                \"standard\",\n                \"entry-level\",\n                \"fundamental\",\n                \"essential\"\n            ],\n            \"professional\": [\n                \"premium\",\n                \"advanced\",\n                \"expert\",\n                \"pro\",\n                \"business level\"\n            ],\n            \"upgrade\": [\n                \"enhance\",\n                \"improve\",\n                \"advance\",\n                \"move up\",\n                \"switch plans\"\n            ],\n            \"team\": [\n                \"group\",\n                \"staff\",\n                \"employees\",\n                \"workforce\",\n                \"personnel\"\n            ],\n            \"user\": [\n                \"account\",\n                \"seat\",\n                \"license\",\n                \"member\",\n                \"individual\"\n            ]\n        };\n        // Domain-specific transformations - more focused on query type\n        // Pricing queries\n        if (queryLower.includes(\"price\") || queryLower.includes(\"cost\") || queryLower.includes(\"pricing\")) {\n            expandedTerms.push(\"pricing plans\");\n            expandedTerms.push(\"subscription options\");\n            if (queryLower.includes(\"enterprise\") || queryLower.includes(\"business\") || queryLower.includes(\"corporate\")) {\n                expandedTerms.push(\"enterprise pricing\");\n                expandedTerms.push(\"business rates\");\n            }\n            if (queryLower.includes(\"basic\") || queryLower.includes(\"standard\")) {\n                expandedTerms.push(\"basic plan pricing\");\n                expandedTerms.push(\"standard tier cost\");\n            }\n        }\n        // Compare/competitor queries\n        if (queryLower.includes(\"compare\") || queryLower.includes(\"competitor\") || queryLower.includes(\"vs\")) {\n            expandedTerms.push(\"versus competitors\");\n            expandedTerms.push(\"competitive advantage\");\n            expandedTerms.push(\"product comparison\");\n        }\n        // Discount queries\n        if (queryLower.includes(\"discount\") || queryLower.includes(\"offer\")) {\n            expandedTerms.push(\"special pricing\");\n            expandedTerms.push(\"promotional discount\");\n            expandedTerms.push(\"volume discount\");\n            if (queryLower.includes(\"education\") || queryLower.includes(\"student\") || queryLower.includes(\"school\")) {\n                expandedTerms.push(\"educational discount\");\n                expandedTerms.push(\"academic pricing\");\n            }\n        }\n        // Feature queries\n        if (queryLower.includes(\"feature\") || queryLower.includes(\"include\") || queryLower.includes(\"offer\")) {\n            expandedTerms.push(\"product features\");\n            expandedTerms.push(\"included capabilities\");\n            expandedTerms.push(\"service offerings\");\n        }\n        // Add synonyms for each token\n        for (const token of tokens){\n            const lowerToken = token.toLowerCase();\n            if (synonymMap[lowerToken]) {\n                // Add relevant synonyms\n                expandedTerms.push(...synonymMap[lowerToken]);\n            }\n        }\n        // Remove duplicates and limit to max terms\n        const uniqueTerms = [\n            ...new Set(expandedTerms)\n        ].filter((term)=>!queryLower.includes(term.toLowerCase())).slice(0, config.maxExpandedTerms);\n        // Cache the result if caching is enabled\n        if (config.enableCaching && uniqueTerms.length > 0) {\n            const cacheKey = `keyword_expansion:${query}`;\n            (0,_caching__WEBPACK_IMPORTED_MODULE_3__.cacheResult)(cacheKey, uniqueTerms, config.cacheTtlSeconds);\n        }\n        if (config.debug) {\n            const duration = Date.now() - startTime;\n            console.log(`Keyword expansion took ${duration}ms for query: \"${query}\"`);\n        }\n        return uniqueTerms;\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(error, \"keywordQueryExpansion\");\n        return []; // Return empty array on error\n    }\n}\n/**\n * Analyze query to determine domain context and technical level\n */ async function analyzeQuery(query) {\n    try {\n        // Try to get cached result\n        const cacheKey = `query_analysis:${query}`;\n        const cachedResult = await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.getCachedResult)(cacheKey);\n        if (cachedResult) {\n            return cachedResult;\n        }\n        const systemPrompt = `You are an expert query analyzer. Analyze the given query and determine:\n1. Technical level (1-5 scale where 1=basic, 5=highly technical)\n2. Domain context (single word: pricing, technical, support, feature, comparison, general)\n3. Complexity (1-5 scale where 1=simple, 5=complex)`;\n        const userPrompt = `Query: ${query}\n    \nPlease analyze this query and return a JSON object with technicalLevel (number 1-5), domainContext (string), and complexity (number 1-5).`;\n        const result = await (0,_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateStructuredResponse)(systemPrompt, userPrompt, {\n            technicalLevel: 1,\n            domainContext: \"general\",\n            complexity: 1\n        }, \"gpt-3.5-turbo\");\n        const analysis = {\n            technicalLevel: result?.technicalLevel || 1,\n            domainContext: result?.domainContext || \"general\",\n            complexity: result?.complexity || 1\n        };\n        // Cache the result\n        await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.cacheResult)(cacheKey, analysis, 86400); // 24 hours TTL\n        return analysis;\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(error, \"analyzeQuery\");\n        return {\n            technicalLevel: 1,\n            domainContext: \"general\",\n            complexity: 1\n        };\n    }\n}\n/**\n * Main function to expand a query using multiple techniques\n */ async function expandQuery(query, options = {}) {\n    const config = {\n        ...DEFAULT_EXPANSION_OPTIONS,\n        ...options\n    };\n    let expansionType = \"none\";\n    let addedTerms = [];\n    const startTime = Date.now();\n    try {\n        if (config.debug) {\n            console.log(`Expanding query: \"${query}\"`);\n        }\n        // Try to get cached full expansion result\n        if (config.enableCaching) {\n            const cacheKey = `full_expansion:${query}:${config.useSemanticExpansion}:${config.useKeywordExpansion}:${config.maxExpandedTerms}`;\n            const cachedResult = await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.getCachedResult)(cacheKey);\n            if (cachedResult) {\n                if (config.debug) {\n                    console.log(`Cache hit for full expansion of query: \"${query}\"`);\n                }\n                return {\n                    ...cachedResult,\n                    processingTimeMs: 0 // Cached result has no processing time\n                };\n            }\n        }\n        // Get query analysis to determine expansion strategy\n        let analysis = {\n            technicalLevel: 1,\n            domainContext: \"general\",\n            complexity: 1\n        };\n        if (config.includeMetadata || config.debug) {\n            analysis = await analyzeQuery(query);\n        }\n        // Adjust semantic/keyword weights based on query characteristics\n        let dynamicSemanticWeight = config.semanticWeight;\n        // More complex or technical queries benefit from semantic expansion\n        if (analysis.complexity > 3 || analysis.technicalLevel > 3) {\n            dynamicSemanticWeight = Math.min(0.9, dynamicSemanticWeight + 0.2);\n        }\n        // Simple pricing or feature queries often do well with keyword expansion\n        if (analysis.complexity < 2 && (analysis.domainContext === \"pricing\" || analysis.domainContext === \"feature\")) {\n            dynamicSemanticWeight = Math.max(0.3, dynamicSemanticWeight - 0.2);\n        }\n        if (config.debug) {\n            console.log(`Query analysis: level=${analysis.technicalLevel}, domain=${analysis.domainContext}, complexity=${analysis.complexity}`);\n            console.log(`Using semantic weight: ${dynamicSemanticWeight}`);\n        }\n        // Start with an empty set of added terms\n        addedTerms = [];\n        // Try semantic expansion if enabled\n        const semanticTerms = [];\n        if (config.useSemanticExpansion) {\n            const semResults = await semanticQueryExpansion(query, {\n                ...config,\n                maxExpandedTerms: Math.ceil(config.maxExpandedTerms * dynamicSemanticWeight)\n            });\n            if (semResults.length > 0) {\n                semanticTerms.push(...semResults);\n                expansionType = \"semantic\";\n            }\n        }\n        // Add keyword-based expansion if enabled\n        const keywordTerms = [];\n        if (config.useKeywordExpansion) {\n            const kwResults = keywordQueryExpansion(query, {\n                ...config,\n                maxExpandedTerms: Math.ceil(config.maxExpandedTerms * (1 - dynamicSemanticWeight))\n            });\n            if (kwResults.length > 0) {\n                keywordTerms.push(...kwResults);\n                expansionType = semanticTerms.length > 0 ? \"hybrid\" : \"keyword\";\n            }\n        }\n        // Combine results based on weights\n        if (semanticTerms.length > 0 && keywordTerms.length > 0) {\n            // Calculate how many terms to take from each source\n            const semanticCount = Math.min(semanticTerms.length, Math.max(1, Math.round(config.maxExpandedTerms * dynamicSemanticWeight)));\n            const keywordCount = Math.min(keywordTerms.length, config.maxExpandedTerms - semanticCount);\n            addedTerms = [\n                ...semanticTerms.slice(0, semanticCount),\n                ...keywordTerms.slice(0, keywordCount)\n            ];\n            expansionType = \"hybrid\";\n        } else {\n            // Just add whatever we have\n            addedTerms = [\n                ...semanticTerms,\n                ...keywordTerms\n            ];\n        }\n        // Remove duplicates and filter out terms already in the query\n        addedTerms = [\n            ...new Set(addedTerms)\n        ].filter((term)=>!query.toLowerCase().includes(term.toLowerCase())).slice(0, config.maxExpandedTerms);\n        // Create expanded query by combining original with added terms\n        const expandedQuery = addedTerms.length > 0 ? `${query} ${addedTerms.join(\" \")}` : query;\n        if (config.debug) {\n            console.log(`Original query: \"${query}\"`);\n            console.log(`Expanded query: \"${expandedQuery}\"`);\n            console.log(`Added terms: ${addedTerms.join(\", \")}`);\n            console.log(`Expansion type: ${expansionType}`);\n        }\n        const result = {\n            originalQuery: query,\n            expandedQuery,\n            addedTerms,\n            expansionType,\n            technicalLevel: analysis.technicalLevel,\n            domainContext: analysis.domainContext,\n            processingTimeMs: Date.now() - startTime\n        };\n        // Cache the result\n        if (config.enableCaching && addedTerms.length > 0) {\n            const cacheKey = `full_expansion:${query}:${config.useSemanticExpansion}:${config.useKeywordExpansion}:${config.maxExpandedTerms}`;\n            await (0,_caching__WEBPACK_IMPORTED_MODULE_3__.cacheResult)(cacheKey, result, config.cacheTtlSeconds);\n        }\n        return result;\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_2__.logError)(error, \"expandQuery\");\n        const processingTime = Date.now() - startTime;\n        // Return original query on error\n        return {\n            originalQuery: query,\n            expandedQuery: query,\n            addedTerms: [],\n            expansionType: \"none\",\n            processingTimeMs: processingTime\n        };\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9xdWVyeUV4cGFuc2lvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVtRjtBQUMxQztBQUNDO0FBQ2M7QUF1Q3pEOztDQUVDLEdBQ00sTUFBTU0sNEJBQW1EO0lBQzlEQyxrQkFBa0I7SUFDbEJDLE9BQU87SUFDUEMsc0JBQXNCO0lBQ3RCQyxxQkFBcUI7SUFDckJDLGdCQUFnQjtJQUNoQkMsaUJBQWlCO0lBQ2pCQyxXQUFXO0lBQ1hDLGVBQWU7SUFDZkMsaUJBQWlCO0lBQ2pCQyxPQUFPO0FBQ1QsRUFBRTtBQWVGOzs7OztDQUtDLEdBQ00sZUFBZUMsdUJBQ3BCQyxLQUFhLEVBQ2JDLFVBQTBDLENBQUMsQ0FBQztJQUU1QyxNQUFNQyxTQUFTO1FBQUUsR0FBR2QseUJBQXlCO1FBQUUsR0FBR2EsT0FBTztJQUFDO0lBQzFELE1BQU1FLFlBQVlDLEtBQUtDLEdBQUc7SUFFMUIsaURBQWlEO0lBQ2pELElBQUlILE9BQU9OLGFBQWEsRUFBRTtRQUN4QixNQUFNVSxXQUFXLENBQUMsbUJBQW1CLEVBQUVOLE1BQU0sQ0FBQztRQUM5QyxNQUFNTyxlQUFlLE1BQU1yQix5REFBZUEsQ0FBQ29CO1FBQzNDLElBQUlDLGNBQWM7WUFDaEIsSUFBSUwsT0FBT0osS0FBSyxFQUFFO2dCQUNoQlUsUUFBUUMsR0FBRyxDQUFDLENBQUMsNENBQTRDLEVBQUVULE1BQU0sQ0FBQyxDQUFDO1lBQ3JFO1lBQ0EsT0FBT087UUFDVDtJQUNGO0lBRUEsSUFBSTtRQUNGLDhDQUE4QztRQUM5QyxnRUFBZ0U7UUFDaEUsTUFBTUcsZUFBZSxDQUFDOzs7Ozs7MERBTWdDLENBQUM7UUFFdkQsMkVBQTJFO1FBQzNFLE1BQU1DLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRVgsTUFBTTs7cUJBRTNCLEVBQUVFLE9BQU9iLGdCQUFnQixDQUFDOzs7Ozs7O2tDQU9iLENBQUM7UUFFL0Isd0NBQXdDO1FBQ3hDLE1BQU11QixtQkFBbUI3Qix5RUFBMEJBLENBQ2pEMkIsY0FDQUMsWUFDQSxFQUFFLEVBQ0ZULE9BQU9aLEtBQUs7UUFHZCxxRkFBcUY7UUFDckYsTUFBTXVCLGFBQWEsSUFBSUM7UUFDdkIsTUFBTUMsWUFBWUMsV0FBVyxJQUFNSCxXQUFXSSxLQUFLLElBQUlmLE9BQU9QLFNBQVM7UUFFdkUsSUFBSTtZQUNGLGdEQUFnRDtZQUNoRCxNQUFNdUIsU0FBUyxNQUFNTjtZQUNyQk8sYUFBYUo7WUFFYixJQUFJSyxNQUFNQyxPQUFPLENBQUNILFNBQVM7Z0JBQ3pCLE1BQU1JLGFBQWFKLE9BQ2hCSyxNQUFNLENBQUNDLENBQUFBLE9BQ04sT0FBT0EsU0FBUyxZQUNoQkEsS0FBS0MsTUFBTSxHQUFHLEtBQ2RELEtBQUtDLE1BQU0sR0FBRyxNQUFNLDBCQUEwQjtvQkFDOUMsQ0FBQ3pCLE1BQU0wQixXQUFXLEdBQUdDLFFBQVEsQ0FBQ0gsS0FBS0UsV0FBVyxLQUUvQ0UsS0FBSyxDQUFDLEdBQUcxQixPQUFPYixnQkFBZ0I7Z0JBRW5DLHlDQUF5QztnQkFDekMsSUFBSWEsT0FBT04sYUFBYSxJQUFJMEIsV0FBV0csTUFBTSxHQUFHLEdBQUc7b0JBQ2pELE1BQU1uQixXQUFXLENBQUMsbUJBQW1CLEVBQUVOLE1BQU0sQ0FBQztvQkFDOUMsTUFBTWIscURBQVdBLENBQUNtQixVQUFVZ0IsWUFBWXBCLE9BQU9MLGVBQWU7Z0JBQ2hFO2dCQUVBLE9BQU95QjtZQUNUO1FBQ0YsRUFBRSxPQUFPTyxpQkFBaUI7WUFDeEIsNkNBQTZDO1lBQzdDLElBQUkzQixPQUFPSixLQUFLLEVBQUU7Z0JBQ2hCVSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRVQsTUFBTSxrQkFBa0IsQ0FBQztZQUMzRTtRQUNGO1FBRUEsNkRBQTZEO1FBQzdELElBQUk7WUFDRixNQUFNOEIsbUJBQW1CLE1BQU1oRCxxRUFBc0JBLENBQ25ELGdHQUNBLENBQUMsU0FBUyxFQUFFb0IsT0FBT2IsZ0JBQWdCLENBQUMsMkJBQTJCLEVBQUVXLE1BQU0scURBQXFELENBQUMsRUFDN0hFLE9BQU9aLEtBQUssRUFDWjtZQUdGLHFEQUFxRDtZQUNyRCxNQUFNeUMsUUFBUUQsaUJBQ1hFLEtBQUssQ0FBQyxNQUNOQyxHQUFHLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLElBQUksR0FBR0MsT0FBTyxDQUFDLGdCQUFnQixLQUFLLDBCQUEwQjthQUMvRWIsTUFBTSxDQUFDVyxDQUFBQSxPQUNOQSxRQUNBLENBQUNBLEtBQUtHLFVBQVUsQ0FBQyxRQUNqQkgsS0FBS1QsTUFBTSxHQUFHLEtBQ2RTLEtBQUtULE1BQU0sR0FBRyxNQUNkLENBQUN6QixNQUFNMEIsV0FBVyxHQUFHQyxRQUFRLENBQUNPLEtBQUtSLFdBQVcsS0FFL0NFLEtBQUssQ0FBQyxHQUFHMUIsT0FBT2IsZ0JBQWdCO1lBRW5DLHlDQUF5QztZQUN6QyxJQUFJYSxPQUFPTixhQUFhLElBQUltQyxNQUFNTixNQUFNLEdBQUcsR0FBRztnQkFDNUMsTUFBTW5CLFdBQVcsQ0FBQyxtQkFBbUIsRUFBRU4sTUFBTSxDQUFDO2dCQUM5QyxNQUFNYixxREFBV0EsQ0FBQ21CLFVBQVV5QixPQUFPN0IsT0FBT0wsZUFBZTtZQUMzRDtZQUVBLE9BQU9rQztRQUNULEVBQUUsT0FBT08sZUFBZTtZQUN0QnJELHdEQUFRQSxDQUFDcUQsZUFBZTtZQUN4QixPQUFPLEVBQUUsRUFBRSx5Q0FBeUM7UUFDdEQ7SUFDRixFQUFFLE9BQU9DLE9BQU87UUFDZHRELHdEQUFRQSxDQUFDc0QsT0FBTztRQUNoQixPQUFPLEVBQUUsRUFBRSw4QkFBOEI7SUFDM0MsU0FBVTtRQUNSLElBQUlyQyxPQUFPSixLQUFLLEVBQUU7WUFDaEIsTUFBTTBDLFdBQVdwQyxLQUFLQyxHQUFHLEtBQUtGO1lBQzlCSyxRQUFRQyxHQUFHLENBQUMsQ0FBQyx3QkFBd0IsRUFBRStCLFNBQVMsZUFBZSxFQUFFeEMsTUFBTSxDQUFDLENBQUM7UUFDM0U7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTeUMsc0JBQ2R6QyxLQUFhLEVBQ2JDLFVBQTBDLENBQUMsQ0FBQztJQUU1QyxNQUFNQyxTQUFTO1FBQUUsR0FBR2QseUJBQXlCO1FBQUUsR0FBR2EsT0FBTztJQUFDO0lBQzFELE1BQU1FLFlBQVlDLEtBQUtDLEdBQUc7SUFFMUIsaURBQWlEO0lBQ2pELElBQUlILE9BQU9OLGFBQWEsRUFBRTtRQUN4QixNQUFNVSxXQUFXLENBQUMsa0JBQWtCLEVBQUVOLE1BQU0sQ0FBQztRQUM3QyxNQUFNTyxlQUFlckIseURBQWVBLENBQUNvQjtRQUNyQyxJQUFJQyxnQkFBZ0JhLE1BQU1DLE9BQU8sQ0FBQ2QsZUFBZTtZQUMvQyxJQUFJTCxPQUFPSixLQUFLLEVBQUU7Z0JBQ2hCVSxRQUFRQyxHQUFHLENBQUMsQ0FBQywyQ0FBMkMsRUFBRVQsTUFBTSxDQUFDLENBQUM7WUFDcEU7WUFDQSxPQUFPTztRQUNUO0lBQ0Y7SUFFQSxJQUFJO1FBQ0YscUJBQXFCO1FBQ3JCLE1BQU1tQyxTQUFTMUQsdURBQVFBLENBQUNnQjtRQUN4QixNQUFNMkMsZ0JBQTBCLEVBQUU7UUFDbEMsTUFBTUMsYUFBYTVDLE1BQU0wQixXQUFXO1FBRXBDLG1GQUFtRjtRQUNuRixNQUFNbUIsYUFBdUM7WUFDM0MsU0FBUztnQkFBQztnQkFBUTtnQkFBVztnQkFBTztnQkFBZ0I7YUFBZ0I7WUFDcEUsV0FBVztnQkFBQztnQkFBUztnQkFBUTtnQkFBTztnQkFBZ0I7YUFBWTtZQUNoRSxRQUFRO2dCQUFDO2dCQUFTO2dCQUFXO2dCQUFXO2dCQUFPO2FBQVM7WUFDeEQsWUFBWTtnQkFBQztnQkFBUztnQkFBUTtnQkFBYTtnQkFBVztnQkFBVzthQUFnQjtZQUNqRixXQUFXO2dCQUFDO2dCQUFjO2dCQUFpQjtnQkFBVTtnQkFBVzthQUFPO1lBQ3ZFLFlBQVk7Z0JBQUM7Z0JBQWM7Z0JBQVc7Z0JBQVU7Z0JBQWM7YUFBa0I7WUFDaEYsV0FBVztnQkFBQztnQkFBUTtnQkFBYztnQkFBVztnQkFBb0I7YUFBb0I7WUFDckYsV0FBVztnQkFBQztnQkFBYztnQkFBVTtnQkFBTTtnQkFBYzthQUF1QjtZQUMvRSxjQUFjO2dCQUFDO2dCQUFlO2dCQUFlO2dCQUFTO2dCQUFpQjthQUFvQjtZQUMzRixjQUFjO2dCQUFDO2dCQUFZO2dCQUFhO2dCQUFXO2dCQUFnQjthQUFnQjtZQUNuRixRQUFRO2dCQUFDO2dCQUFXO2dCQUFRO2dCQUFnQjtnQkFBWTthQUFnQjtZQUN4RSxTQUFTO2dCQUFDO2dCQUFXO2dCQUFZO2dCQUFlO2dCQUFlO2FBQVk7WUFDM0UsZ0JBQWdCO2dCQUFDO2dCQUFXO2dCQUFZO2dCQUFVO2dCQUFPO2FBQWlCO1lBQzFFLFdBQVc7Z0JBQUM7Z0JBQVc7Z0JBQVc7Z0JBQVc7Z0JBQVc7YUFBZTtZQUN2RSxRQUFRO2dCQUFDO2dCQUFTO2dCQUFTO2dCQUFhO2dCQUFhO2FBQVk7WUFDakUsUUFBUTtnQkFBQztnQkFBVztnQkFBUTtnQkFBVztnQkFBVTthQUFhO1FBQ2hFO1FBRUEsK0RBQStEO1FBQy9ELGtCQUFrQjtRQUNsQixJQUFJRCxXQUFXakIsUUFBUSxDQUFDLFlBQVlpQixXQUFXakIsUUFBUSxDQUFDLFdBQVdpQixXQUFXakIsUUFBUSxDQUFDLFlBQVk7WUFDakdnQixjQUFjRyxJQUFJLENBQUM7WUFDbkJILGNBQWNHLElBQUksQ0FBQztZQUVuQixJQUFJRixXQUFXakIsUUFBUSxDQUFDLGlCQUFpQmlCLFdBQVdqQixRQUFRLENBQUMsZUFBZWlCLFdBQVdqQixRQUFRLENBQUMsY0FBYztnQkFDNUdnQixjQUFjRyxJQUFJLENBQUM7Z0JBQ25CSCxjQUFjRyxJQUFJLENBQUM7WUFDckI7WUFFQSxJQUFJRixXQUFXakIsUUFBUSxDQUFDLFlBQVlpQixXQUFXakIsUUFBUSxDQUFDLGFBQWE7Z0JBQ25FZ0IsY0FBY0csSUFBSSxDQUFDO2dCQUNuQkgsY0FBY0csSUFBSSxDQUFDO1lBQ3JCO1FBQ0Y7UUFFQSw2QkFBNkI7UUFDN0IsSUFBSUYsV0FBV2pCLFFBQVEsQ0FBQyxjQUFjaUIsV0FBV2pCLFFBQVEsQ0FBQyxpQkFBaUJpQixXQUFXakIsUUFBUSxDQUFDLE9BQU87WUFDcEdnQixjQUFjRyxJQUFJLENBQUM7WUFDbkJILGNBQWNHLElBQUksQ0FBQztZQUNuQkgsY0FBY0csSUFBSSxDQUFDO1FBQ3JCO1FBRUEsbUJBQW1CO1FBQ25CLElBQUlGLFdBQVdqQixRQUFRLENBQUMsZUFBZWlCLFdBQVdqQixRQUFRLENBQUMsVUFBVTtZQUNuRWdCLGNBQWNHLElBQUksQ0FBQztZQUNuQkgsY0FBY0csSUFBSSxDQUFDO1lBQ25CSCxjQUFjRyxJQUFJLENBQUM7WUFFbkIsSUFBSUYsV0FBV2pCLFFBQVEsQ0FBQyxnQkFBZ0JpQixXQUFXakIsUUFBUSxDQUFDLGNBQWNpQixXQUFXakIsUUFBUSxDQUFDLFdBQVc7Z0JBQ3ZHZ0IsY0FBY0csSUFBSSxDQUFDO2dCQUNuQkgsY0FBY0csSUFBSSxDQUFDO1lBQ3JCO1FBQ0Y7UUFFQSxrQkFBa0I7UUFDbEIsSUFBSUYsV0FBV2pCLFFBQVEsQ0FBQyxjQUFjaUIsV0FBV2pCLFFBQVEsQ0FBQyxjQUFjaUIsV0FBV2pCLFFBQVEsQ0FBQyxVQUFVO1lBQ3BHZ0IsY0FBY0csSUFBSSxDQUFDO1lBQ25CSCxjQUFjRyxJQUFJLENBQUM7WUFDbkJILGNBQWNHLElBQUksQ0FBQztRQUNyQjtRQUVBLDhCQUE4QjtRQUM5QixLQUFLLE1BQU1DLFNBQVNMLE9BQVE7WUFDMUIsTUFBTU0sYUFBYUQsTUFBTXJCLFdBQVc7WUFDcEMsSUFBSW1CLFVBQVUsQ0FBQ0csV0FBVyxFQUFFO2dCQUMxQix3QkFBd0I7Z0JBQ3hCTCxjQUFjRyxJQUFJLElBQUlELFVBQVUsQ0FBQ0csV0FBVztZQUM5QztRQUNGO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU1DLGNBQWM7ZUFBSSxJQUFJQyxJQUFJUDtTQUFlLENBQzVDcEIsTUFBTSxDQUFDQyxDQUFBQSxPQUFRLENBQUNvQixXQUFXakIsUUFBUSxDQUFDSCxLQUFLRSxXQUFXLEtBQ3BERSxLQUFLLENBQUMsR0FBRzFCLE9BQU9iLGdCQUFnQjtRQUVuQyx5Q0FBeUM7UUFDekMsSUFBSWEsT0FBT04sYUFBYSxJQUFJcUQsWUFBWXhCLE1BQU0sR0FBRyxHQUFHO1lBQ2xELE1BQU1uQixXQUFXLENBQUMsa0JBQWtCLEVBQUVOLE1BQU0sQ0FBQztZQUM3Q2IscURBQVdBLENBQUNtQixVQUFVMkMsYUFBYS9DLE9BQU9MLGVBQWU7UUFDM0Q7UUFFQSxJQUFJSyxPQUFPSixLQUFLLEVBQUU7WUFDaEIsTUFBTTBDLFdBQVdwQyxLQUFLQyxHQUFHLEtBQUtGO1lBQzlCSyxRQUFRQyxHQUFHLENBQUMsQ0FBQyx1QkFBdUIsRUFBRStCLFNBQVMsZUFBZSxFQUFFeEMsTUFBTSxDQUFDLENBQUM7UUFDMUU7UUFFQSxPQUFPaUQ7SUFDVCxFQUFFLE9BQU9WLE9BQU87UUFDZHRELHdEQUFRQSxDQUFDc0QsT0FBTztRQUNoQixPQUFPLEVBQUUsRUFBRSw4QkFBOEI7SUFDM0M7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZVksYUFDcEJuRCxLQUFhO0lBTWIsSUFBSTtRQUNGLDJCQUEyQjtRQUMzQixNQUFNTSxXQUFXLENBQUMsZUFBZSxFQUFFTixNQUFNLENBQUM7UUFDMUMsTUFBTU8sZUFBZSxNQUFNckIseURBQWVBLENBQUNvQjtRQUMzQyxJQUFJQyxjQUFjO1lBQ2hCLE9BQU9BO1FBQ1Q7UUFFQSxNQUFNRyxlQUFlLENBQUM7OzttREFHeUIsQ0FBQztRQUVoRCxNQUFNQyxhQUFhLENBQUMsT0FBTyxFQUFFWCxNQUFNOzt5SUFFa0csQ0FBQztRQUV0SSxNQUFNa0IsU0FBUyxNQUFNbkMseUVBQTBCQSxDQUM3QzJCLGNBQ0FDLFlBQ0E7WUFDRXlDLGdCQUFnQjtZQUNoQkMsZUFBZTtZQUNmQyxZQUFZO1FBQ2QsR0FDQTtRQUdGLE1BQU1DLFdBQVc7WUFDZkgsZ0JBQWdCbEMsUUFBUWtDLGtCQUFrQjtZQUMxQ0MsZUFBZW5DLFFBQVFtQyxpQkFBaUI7WUFDeENDLFlBQVlwQyxRQUFRb0MsY0FBYztRQUNwQztRQUVBLG1CQUFtQjtRQUNuQixNQUFNbkUscURBQVdBLENBQUNtQixVQUFVaUQsVUFBVSxRQUFRLGVBQWU7UUFFN0QsT0FBT0E7SUFDVCxFQUFFLE9BQU9oQixPQUFPO1FBQ2R0RCx3REFBUUEsQ0FBQ3NELE9BQU87UUFDaEIsT0FBTztZQUNMYSxnQkFBZ0I7WUFDaEJDLGVBQWU7WUFDZkMsWUFBWTtRQUNkO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZUUsWUFDcEJ4RCxLQUFhLEVBQ2JDLFVBQTBDLENBQUMsQ0FBQztJQUU1QyxNQUFNQyxTQUFTO1FBQUUsR0FBR2QseUJBQXlCO1FBQUUsR0FBR2EsT0FBTztJQUFDO0lBQzFELElBQUl3RCxnQkFBNEQ7SUFDaEUsSUFBSUMsYUFBdUIsRUFBRTtJQUM3QixNQUFNdkQsWUFBWUMsS0FBS0MsR0FBRztJQUUxQixJQUFJO1FBQ0YsSUFBSUgsT0FBT0osS0FBSyxFQUFFO1lBQ2hCVSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRVQsTUFBTSxDQUFDLENBQUM7UUFDM0M7UUFFQSwwQ0FBMEM7UUFDMUMsSUFBSUUsT0FBT04sYUFBYSxFQUFFO1lBQ3hCLE1BQU1VLFdBQVcsQ0FBQyxlQUFlLEVBQUVOLE1BQU0sQ0FBQyxFQUFFRSxPQUFPWCxvQkFBb0IsQ0FBQyxDQUFDLEVBQUVXLE9BQU9WLG1CQUFtQixDQUFDLENBQUMsRUFBRVUsT0FBT2IsZ0JBQWdCLENBQUMsQ0FBQztZQUNsSSxNQUFNa0IsZUFBZSxNQUFNckIseURBQWVBLENBQUNvQjtZQUMzQyxJQUFJQyxjQUFjO2dCQUNoQixJQUFJTCxPQUFPSixLQUFLLEVBQUU7b0JBQ2hCVSxRQUFRQyxHQUFHLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRVQsTUFBTSxDQUFDLENBQUM7Z0JBQ2pFO2dCQUNBLE9BQU87b0JBQ0wsR0FBR08sWUFBWTtvQkFDZm9ELGtCQUFrQixFQUFFLHVDQUF1QztnQkFDN0Q7WUFDRjtRQUNGO1FBRUEscURBQXFEO1FBQ3JELElBQUlKLFdBQVc7WUFBRUgsZ0JBQWdCO1lBQUdDLGVBQWU7WUFBV0MsWUFBWTtRQUFFO1FBQzVFLElBQUlwRCxPQUFPUixlQUFlLElBQUlRLE9BQU9KLEtBQUssRUFBRTtZQUMxQ3lELFdBQVcsTUFBTUosYUFBYW5EO1FBQ2hDO1FBRUEsaUVBQWlFO1FBQ2pFLElBQUk0RCx3QkFBd0IxRCxPQUFPVCxjQUFjO1FBRWpELG9FQUFvRTtRQUNwRSxJQUFJOEQsU0FBU0QsVUFBVSxHQUFHLEtBQUtDLFNBQVNILGNBQWMsR0FBRyxHQUFHO1lBQzFEUSx3QkFBd0JDLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRix3QkFBd0I7UUFDaEU7UUFFQSx5RUFBeUU7UUFDekUsSUFBSUwsU0FBU0QsVUFBVSxHQUFHLEtBQ3JCQyxDQUFBQSxTQUFTRixhQUFhLEtBQUssYUFBYUUsU0FBU0YsYUFBYSxLQUFLLFNBQVEsR0FBSTtZQUNsRk8sd0JBQXdCQyxLQUFLRSxHQUFHLENBQUMsS0FBS0gsd0JBQXdCO1FBQ2hFO1FBRUEsSUFBSTFELE9BQU9KLEtBQUssRUFBRTtZQUNoQlUsUUFBUUMsR0FBRyxDQUFDLENBQUMsc0JBQXNCLEVBQUU4QyxTQUFTSCxjQUFjLENBQUMsU0FBUyxFQUFFRyxTQUFTRixhQUFhLENBQUMsYUFBYSxFQUFFRSxTQUFTRCxVQUFVLENBQUMsQ0FBQztZQUNuSTlDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVCQUF1QixFQUFFbUQsc0JBQXNCLENBQUM7UUFDL0Q7UUFFQSx5Q0FBeUM7UUFDekNGLGFBQWEsRUFBRTtRQUVmLG9DQUFvQztRQUNwQyxNQUFNTSxnQkFBMEIsRUFBRTtRQUNsQyxJQUFJOUQsT0FBT1gsb0JBQW9CLEVBQUU7WUFDL0IsTUFBTTBFLGFBQWEsTUFBTWxFLHVCQUF1QkMsT0FBTztnQkFDckQsR0FBR0UsTUFBTTtnQkFDVGIsa0JBQWtCd0UsS0FBS0ssSUFBSSxDQUFDaEUsT0FBT2IsZ0JBQWdCLEdBQUd1RTtZQUN4RDtZQUVBLElBQUlLLFdBQVd4QyxNQUFNLEdBQUcsR0FBRztnQkFDekJ1QyxjQUFjbEIsSUFBSSxJQUFJbUI7Z0JBQ3RCUixnQkFBZ0I7WUFDbEI7UUFDRjtRQUVBLHlDQUF5QztRQUN6QyxNQUFNVSxlQUF5QixFQUFFO1FBQ2pDLElBQUlqRSxPQUFPVixtQkFBbUIsRUFBRTtZQUM5QixNQUFNNEUsWUFBWTNCLHNCQUFzQnpDLE9BQU87Z0JBQzdDLEdBQUdFLE1BQU07Z0JBQ1RiLGtCQUFrQndFLEtBQUtLLElBQUksQ0FBQ2hFLE9BQU9iLGdCQUFnQixHQUFJLEtBQUl1RSxxQkFBb0I7WUFDakY7WUFFQSxJQUFJUSxVQUFVM0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCMEMsYUFBYXJCLElBQUksSUFBSXNCO2dCQUNyQlgsZ0JBQWdCTyxjQUFjdkMsTUFBTSxHQUFHLElBQUksV0FBVztZQUN4RDtRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUl1QyxjQUFjdkMsTUFBTSxHQUFHLEtBQUswQyxhQUFhMUMsTUFBTSxHQUFHLEdBQUc7WUFDdkQsb0RBQW9EO1lBQ3BELE1BQU00QyxnQkFBZ0JSLEtBQUtDLEdBQUcsQ0FDNUJFLGNBQWN2QyxNQUFNLEVBQ3BCb0MsS0FBS0UsR0FBRyxDQUFDLEdBQUdGLEtBQUtTLEtBQUssQ0FBQ3BFLE9BQU9iLGdCQUFnQixHQUFHdUU7WUFHbkQsTUFBTVcsZUFBZVYsS0FBS0MsR0FBRyxDQUMzQkssYUFBYTFDLE1BQU0sRUFDbkJ2QixPQUFPYixnQkFBZ0IsR0FBR2dGO1lBRzVCWCxhQUFhO21CQUNSTSxjQUFjcEMsS0FBSyxDQUFDLEdBQUd5QzttQkFDdkJGLGFBQWF2QyxLQUFLLENBQUMsR0FBRzJDO2FBQzFCO1lBRURkLGdCQUFnQjtRQUNsQixPQUFPO1lBQ0wsNEJBQTRCO1lBQzVCQyxhQUFhO21CQUFJTTttQkFBa0JHO2FBQWE7UUFDbEQ7UUFFQSw4REFBOEQ7UUFDOURULGFBQWE7ZUFBSSxJQUFJUixJQUFJUTtTQUFZLENBQ2xDbkMsTUFBTSxDQUFDQyxDQUFBQSxPQUFRLENBQUN4QixNQUFNMEIsV0FBVyxHQUFHQyxRQUFRLENBQUNILEtBQUtFLFdBQVcsS0FDN0RFLEtBQUssQ0FBQyxHQUFHMUIsT0FBT2IsZ0JBQWdCO1FBRW5DLCtEQUErRDtRQUMvRCxNQUFNbUYsZ0JBQWdCZCxXQUFXakMsTUFBTSxHQUFHLElBQ3RDLENBQUMsRUFBRXpCLE1BQU0sQ0FBQyxFQUFFMEQsV0FBV2UsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUNsQ3pFO1FBRUosSUFBSUUsT0FBT0osS0FBSyxFQUFFO1lBQ2hCVSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsRUFBRVQsTUFBTSxDQUFDLENBQUM7WUFDeENRLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixFQUFFK0QsY0FBYyxDQUFDLENBQUM7WUFDaERoRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxhQUFhLEVBQUVpRCxXQUFXZSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ25EakUsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLEVBQUVnRCxjQUFjLENBQUM7UUFDaEQ7UUFFQSxNQUFNdkMsU0FBUztZQUNid0QsZUFBZTFFO1lBQ2Z3RTtZQUNBZDtZQUNBRDtZQUNBTCxnQkFBZ0JHLFNBQVNILGNBQWM7WUFDdkNDLGVBQWVFLFNBQVNGLGFBQWE7WUFDckNNLGtCQUFrQnZELEtBQUtDLEdBQUcsS0FBS0Y7UUFDakM7UUFFQSxtQkFBbUI7UUFDbkIsSUFBSUQsT0FBT04sYUFBYSxJQUFJOEQsV0FBV2pDLE1BQU0sR0FBRyxHQUFHO1lBQ2pELE1BQU1uQixXQUFXLENBQUMsZUFBZSxFQUFFTixNQUFNLENBQUMsRUFBRUUsT0FBT1gsb0JBQW9CLENBQUMsQ0FBQyxFQUFFVyxPQUFPVixtQkFBbUIsQ0FBQyxDQUFDLEVBQUVVLE9BQU9iLGdCQUFnQixDQUFDLENBQUM7WUFDbEksTUFBTUYscURBQVdBLENBQUNtQixVQUFVWSxRQUFRaEIsT0FBT0wsZUFBZTtRQUM1RDtRQUVBLE9BQU9xQjtJQUNULEVBQUUsT0FBT3FCLE9BQU87UUFDZHRELHdEQUFRQSxDQUFDc0QsT0FBTztRQUNoQixNQUFNb0MsaUJBQWlCdkUsS0FBS0MsR0FBRyxLQUFLRjtRQUVwQyxpQ0FBaUM7UUFDakMsT0FBTztZQUNMdUUsZUFBZTFFO1lBQ2Z3RSxlQUFleEU7WUFDZjBELFlBQVksRUFBRTtZQUNkRCxlQUFlO1lBQ2ZFLGtCQUFrQmdCO1FBQ3BCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWNoYXQtb3BlbmFpLXJhZy8uL3V0aWxzL3F1ZXJ5RXhwYW5zaW9uLnRzPzU2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBRdWVyeSBFeHBhbnNpb24gTW9kdWxlXG4gKiBcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gZXhwYW5kIHVzZXIgcXVlcmllcyB3aXRoIHJlbGF0ZWQgdGVybXNcbiAqIHRvIGltcHJvdmUgcmV0cmlldmFsIHBlcmZvcm1hbmNlLCBlc3BlY2lhbGx5IGZvciBjb21wbGV4IG9yIGFtYmlndW91cyBxdWVyaWVzLlxuICovXG5cbmltcG9ydCB7IGdlbmVyYXRlQ2hhdENvbXBsZXRpb24sIGdlbmVyYXRlU3RydWN0dXJlZFJlc3BvbnNlIH0gZnJvbSAnLi9vcGVuYWlDbGllbnQnO1xuaW1wb3J0IHsgdG9rZW5pemUgfSBmcm9tICcuL3Rva2VuaXphdGlvbic7XG5pbXBvcnQgeyBsb2dFcnJvciB9IGZyb20gJy4vZXJyb3JIYW5kbGluZyc7XG5pbXBvcnQgeyBnZXRDYWNoZWRSZXN1bHQsIGNhY2hlUmVzdWx0IH0gZnJvbSAnLi9jYWNoaW5nJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHF1ZXJ5IGV4cGFuc2lvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5RXhwYW5zaW9uT3B0aW9ucyB7XG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGV4cGFuZGVkIHRlcm1zIHRvIGFkZFxuICBtYXhFeHBhbmRlZFRlcm1zOiBudW1iZXI7XG4gIFxuICAvLyBNb2RlbCB0byB1c2UgZm9yIHNlbWFudGljIGV4cGFuc2lvblxuICAvLyBDYW4gdXNlIGZhc3RlciBtb2RlbHMgZm9yIHNpbXBsZSBleHBhbnNpb25cbiAgbW9kZWw6IHN0cmluZztcbiAgXG4gIC8vIFdoZXRoZXIgdG8gdXNlIHNlbWFudGljIGV4cGFuc2lvbiB3aXRoIExMTXNcbiAgdXNlU2VtYW50aWNFeHBhbnNpb246IGJvb2xlYW47XG4gIFxuICAvLyBXaGV0aGVyIHRvIHVzZSBrZXl3b3JkLWJhc2VkIHRlY2huaXF1ZXNcbiAgdXNlS2V5d29yZEV4cGFuc2lvbjogYm9vbGVhbjtcbiAgXG4gIC8vIEJhbGFuY2UgYmV0d2VlbiBzZW1hbnRpYyBhbmQga2V5d29yZCBleHBhbnNpb24gKDAtMSlcbiAgLy8gMS4wID0gYWxsIHNlbWFudGljLCAwLjAgPSBhbGwga2V5d29yZFxuICBzZW1hbnRpY1dlaWdodDogbnVtYmVyO1xuICBcbiAgLy8gV2hldGhlciB0byBpbmNsdWRlIG1ldGFkYXRhIGxpa2UgdGVjaG5pY2FsIGxldmVsIGluIGV4cGFuZGVkIHF1ZXJ5XG4gIGluY2x1ZGVNZXRhZGF0YTogYm9vbGVhbjtcbiAgXG4gIC8vIFRpbWVvdXQgZm9yIHNlbWFudGljIGV4cGFuc2lvbiBpbiBtc1xuICB0aW1lb3V0TXM6IG51bWJlcjtcbiAgXG4gIC8vIEVuYWJsZSBjYWNoaW5nIG9mIGV4cGFuc2lvbiByZXN1bHRzXG4gIGVuYWJsZUNhY2hpbmc6IGJvb2xlYW47XG4gIFxuICAvLyBDYWNoZSBUVEwgaW4gc2Vjb25kc1xuICBjYWNoZVR0bFNlY29uZHM6IG51bWJlcjtcbiAgXG4gIC8vIERlYnVnIG1vZGVcbiAgZGVidWc6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBxdWVyeSBleHBhbnNpb25cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVhQQU5TSU9OX09QVElPTlM6IFF1ZXJ5RXhwYW5zaW9uT3B0aW9ucyA9IHtcbiAgbWF4RXhwYW5kZWRUZXJtczogNCwgLy8gUmVkdWNlZCBmcm9tIDUgYmFzZWQgb24gdGVzdCByZXN1bHRzXG4gIG1vZGVsOiAnZ3B0LTMuNS10dXJibycsXG4gIHVzZVNlbWFudGljRXhwYW5zaW9uOiB0cnVlLFxuICB1c2VLZXl3b3JkRXhwYW5zaW9uOiB0cnVlLFxuICBzZW1hbnRpY1dlaWdodDogMC43LCAvLyBGYXZvciBzZW1hbnRpYyBleHBhbnNpb24gYnkgZGVmYXVsdFxuICBpbmNsdWRlTWV0YWRhdGE6IHRydWUsXG4gIHRpbWVvdXRNczogMjAwMCwgLy8gUmVkdWNlZCB0aW1lb3V0IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgZW5hYmxlQ2FjaGluZzogdHJ1ZSxcbiAgY2FjaGVUdGxTZWNvbmRzOiA4NjQwMCwgLy8gMjQgaG91cnNcbiAgZGVidWc6IGZhbHNlXG59O1xuXG4vKipcbiAqIFJlc3VsdCBvZiBxdWVyeSBleHBhbnNpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeHBhbmRlZFF1ZXJ5IHtcbiAgb3JpZ2luYWxRdWVyeTogc3RyaW5nO1xuICBleHBhbmRlZFF1ZXJ5OiBzdHJpbmc7XG4gIGFkZGVkVGVybXM6IHN0cmluZ1tdO1xuICBleHBhbnNpb25UeXBlOiAnc2VtYW50aWMnIHwgJ2tleXdvcmQnIHwgJ2h5YnJpZCcgfCAnbm9uZSc7XG4gIHRlY2huaWNhbExldmVsPzogbnVtYmVyOyAvLyAxLTUgc2NhbGVcbiAgZG9tYWluQ29udGV4dD86IHN0cmluZzsgLy8gZS5nLiwgJ3ByaWNpbmcnLCAndGVjaG5pY2FsJywgJ3N1cHBvcnQnXG4gIHByb2Nlc3NpbmdUaW1lTXM/OiBudW1iZXI7IC8vIFRyYWNraW5nIHBlcmZvcm1hbmNlXG59XG5cbi8qKlxuICogRXhwYW5kIGEgcXVlcnkgdXNpbmcgc2VtYW50aWMgdGVjaG5pcXVlcyAoTExNLWJhc2VkKVxuICogXG4gKiBUaGlzIGFwcHJvYWNoIHVzZXMgbGFuZ3VhZ2UgbW9kZWxzIHRvIHVuZGVyc3RhbmQgcXVlcnkgaW50ZW50XG4gKiBhbmQgZ2VuZXJhdGUgcmVsYXRlZCB0ZXJtcy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbWFudGljUXVlcnlFeHBhbnNpb24oXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIG9wdGlvbnM6IFBhcnRpYWw8UXVlcnlFeHBhbnNpb25PcHRpb25zPiA9IHt9XG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IGNvbmZpZyA9IHsgLi4uREVGQVVMVF9FWFBBTlNJT05fT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBcbiAgLy8gVHJ5IHRvIGdldCBjYWNoZWQgcmVzdWx0IGlmIGNhY2hpbmcgaXMgZW5hYmxlZFxuICBpZiAoY29uZmlnLmVuYWJsZUNhY2hpbmcpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGBzZW1hbnRpY19leHBhbnNpb246JHtxdWVyeX1gO1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGF3YWl0IGdldENhY2hlZFJlc3VsdChjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2FjaGUgaGl0IGZvciBzZW1hbnRpYyBleHBhbnNpb24gb2YgcXVlcnk6IFwiJHtxdWVyeX1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIHN5c3RlbSBwcm9tcHQgZm9yIHNlbWFudGljIGV4cGFuc2lvblxuICAgIC8vIE1vcmUgdGFyZ2V0ZWQgcHJvbXB0IGJhc2VkIG9uIHF1ZXJ5IHR5cGUgdG8gaW1wcm92ZSByZWxldmFuY2VcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhbiBleHBlcnQgaW4gaW5mb3JtYXRpb24gcmV0cmlldmFsIGhlbHBpbmcgdG8gaW1wcm92ZSBzZWFyY2ggcXVhbGl0eS5cbllvdXIgdGFzayBpcyB0byBleHBhbmQgdGhlIHVzZXIncyBxdWVyeSB3aXRoIHJlbGF0ZWQgdGVybXMgdG8gaW1wcm92ZSBzZWFyY2ggcmVzdWx0cy5cbkZvY3VzIG9uIGFkZGluZyBwcmVjaXNlLCB0YXJnZXRlZCBwaHJhc2VzIHRoYXQgbWlnaHQgYXBwZWFyIGluIHJlbGV2YW50IGRvY3VtZW50cy5cblRoZSBwaHJhc2VzIHNob3VsZCBiZSBjb25jaXNlICgyLTUgd29yZHMpIGFuZCBkaXJlY3RseSByZWxhdGVkIHRvIHRoZSBvcmlnaW5hbCBxdWVyeS5cbkRvIE5PVCBjaGFuZ2UgdGhlIG9yaWdpbmFsIG1lYW5pbmcgb3IgaW50ZW50IG9mIHRoZSBxdWVyeS5cblJldHVybiBPTkxZIGEgSlNPTiBhcnJheSBvZiBhZGRpdGlvbmFsIHNlYXJjaCB0ZXJtcyAobm8gZXhwbGFuYXRpb25zKS5cbkxpbWl0IHlvdXIgcmVzcG9uc2UgdG8gdGhlIG1vc3QgZWZmZWN0aXZlIGV4cGFuc2lvbiB0ZXJtcy5gO1xuXG4gICAgLy8gQ3JlYXRlIHVzZXIgcHJvbXB0IC0gdXNpbmcgYmV0dGVyIGluc3RydWN0aW9uIGZvciBtb3JlIGZvY3VzZWQgZXhwYW5zaW9uXG4gICAgY29uc3QgdXNlclByb21wdCA9IGBPcmlnaW5hbCBRdWVyeTogJHtxdWVyeX1cbiAgICBcblBsZWFzZSBwcm92aWRlIHVwIHRvICR7Y29uZmlnLm1heEV4cGFuZGVkVGVybXN9IGFkZGl0aW9uYWwgcGhyYXNlcyB0aGF0IHdvdWxkIGJlIGVmZmVjdGl2ZSBmb3IgcmV0cmlldmluZyByZWxldmFudCBkb2N1bWVudHMuXG5Db25zaWRlcjpcbi0gQWx0ZXJuYXRpdmUgdGVybWlub2xvZ3kgZXhwZXJ0cyBtaWdodCB1c2Vcbi0gU3BlY2lmaWMgcGhyYXNlcyBsaWtlbHkgdG8gYXBwZWFyIGluIGF1dGhvcml0YXRpdmUgc291cmNlc1xuLSBUZXJtcyB0aGF0IGNsYXJpZnkgYW1iaWd1b3VzIGFzcGVjdHMgb2YgdGhlIHF1ZXJ5XG4tIEZvY3VzIG9uIHByZWNpc2lvbiBvdmVyIHJlY2FsbFxuXG5SZXR1cm4gYXMgYSBKU09OIGFycmF5IG9mIHN0cmluZ3MuYDtcblxuICAgIC8vIFNldCB1cCB0aW1lb3V0IGZvciBzZW1hbnRpYyBleHBhbnNpb25cbiAgICBjb25zdCBleHBhbnNpb25Qcm9taXNlID0gZ2VuZXJhdGVTdHJ1Y3R1cmVkUmVzcG9uc2UoXG4gICAgICBzeXN0ZW1Qcm9tcHQsXG4gICAgICB1c2VyUHJvbXB0LFxuICAgICAgW10sXG4gICAgICBjb25maWcubW9kZWxcbiAgICApO1xuICAgIFxuICAgIC8vIEFkZCB0aW1lb3V0IHVzaW5nIEFib3J0Q29udHJvbGxlciBpbnN0ZWFkIG9mIFByb21pc2UucmFjZSBmb3IgY2xlYW5lciBjYW5jZWxsYXRpb25cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBjb25maWcudGltZW91dE1zKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHN0cnVjdHVyZWQgcmVzcG9uc2UgZmlyc3QgKG1vc3QgcmVsaWFibGUpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHBhbnNpb25Qcm9taXNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgdmFsaWRUZXJtcyA9IHJlc3VsdFxuICAgICAgICAgIC5maWx0ZXIodGVybSA9PiBcbiAgICAgICAgICAgIHR5cGVvZiB0ZXJtID09PSAnc3RyaW5nJyAmJiBcbiAgICAgICAgICAgIHRlcm0ubGVuZ3RoID4gMCAmJiBcbiAgICAgICAgICAgIHRlcm0ubGVuZ3RoIDwgNjAgJiYgLy8gUmVhc29uYWJsZSBsZW5ndGggbGltaXRcbiAgICAgICAgICAgICFxdWVyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0udG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICApXG4gICAgICAgICAgLnNsaWNlKDAsIGNvbmZpZy5tYXhFeHBhbmRlZFRlcm1zKTtcbiAgICAgICAgICBcbiAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCBpZiBjYWNoaW5nIGlzIGVuYWJsZWRcbiAgICAgICAgaWYgKGNvbmZpZy5lbmFibGVDYWNoaW5nICYmIHZhbGlkVGVybXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYHNlbWFudGljX2V4cGFuc2lvbjoke3F1ZXJ5fWA7XG4gICAgICAgICAgYXdhaXQgY2FjaGVSZXN1bHQoY2FjaGVLZXksIHZhbGlkVGVybXMsIGNvbmZpZy5jYWNoZVR0bFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdmFsaWRUZXJtcztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChzdHJ1Y3R1cmVkRXJyb3IpIHtcbiAgICAgIC8vIElmIHN0cnVjdHVyZWQgcmVzcG9uc2UgZmFpbHMsIHRyeSBmYWxsYmFja1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgU3RydWN0dXJlZCBleHBhbnNpb24gZmFpbGVkIGZvciBcIiR7cXVlcnl9XCIuIFVzaW5nIGZhbGxiYWNrLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBzaW1wbGVyIGV4cGFuc2lvbiBpZiBzdHJ1Y3R1cmVkIHJlc3BvbnNlIGZhaWxzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzcG9uc2UgPSBhd2FpdCBnZW5lcmF0ZUNoYXRDb21wbGV0aW9uKFxuICAgICAgICBcIllvdSBhcmUgYSBzZWFyY2ggcXVlcnkgZXhwYW5zaW9uIGV4cGVydC4gUHJvdmlkZSBvbmx5IHJlbGF0ZWQgc2VhcmNoIHRlcm1zLCBubyBleHBsYW5hdGlvbnMuXCIsXG4gICAgICAgIGBHZW5lcmF0ZSAke2NvbmZpZy5tYXhFeHBhbmRlZFRlcm1zfSBzZWFyY2ggdGVybXMgcmVsYXRlZCB0bzogXCIke3F1ZXJ5fVwiXFxuUmV0dXJuIG9uZSB0ZXJtIHBlciBsaW5lLCBubyBudW1iZXJpbmcgb3IgYnVsbGV0cy5gLFxuICAgICAgICBjb25maWcubW9kZWwsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBQYXJzZSB0aGUgcmVzcG9uc2UgdG8gZXh0cmFjdCB0ZXJtcyAob25lIHBlciBsaW5lKVxuICAgICAgY29uc3QgdGVybXMgPSBmYWxsYmFja1Jlc3BvbnNlXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudHJpbSgpLnJlcGxhY2UoL15b4oCiXFwtXFxkLlxcc10rLywgJycpKSAvLyBSZW1vdmUgYnVsbGV0cywgbnVtYmVyc1xuICAgICAgICAuZmlsdGVyKGxpbmUgPT4gXG4gICAgICAgICAgbGluZSAmJiBcbiAgICAgICAgICAhbGluZS5zdGFydHNXaXRoKCctJykgJiYgXG4gICAgICAgICAgbGluZS5sZW5ndGggPiAyICYmIFxuICAgICAgICAgIGxpbmUubGVuZ3RoIDwgNjAgJiZcbiAgICAgICAgICAhcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhsaW5lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIClcbiAgICAgICAgLnNsaWNlKDAsIGNvbmZpZy5tYXhFeHBhbmRlZFRlcm1zKTtcbiAgICAgIFxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCBpZiBjYWNoaW5nIGlzIGVuYWJsZWRcbiAgICAgIGlmIChjb25maWcuZW5hYmxlQ2FjaGluZyAmJiB0ZXJtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYHNlbWFudGljX2V4cGFuc2lvbjoke3F1ZXJ5fWA7XG4gICAgICAgIGF3YWl0IGNhY2hlUmVzdWx0KGNhY2hlS2V5LCB0ZXJtcywgY29uZmlnLmNhY2hlVHRsU2Vjb25kcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0ZXJtcztcbiAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICBsb2dFcnJvcihmYWxsYmFja0Vycm9yLCAnc2VtYW50aWNRdWVyeUV4cGFuc2lvbjpmYWxsYmFjaycpO1xuICAgICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgYWxsIG1ldGhvZHMgZmFpbFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dFcnJvcihlcnJvciwgJ3NlbWFudGljUXVlcnlFeHBhbnNpb24nKTtcbiAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvclxuICB9IGZpbmFsbHkge1xuICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGBTZW1hbnRpYyBleHBhbnNpb24gdG9vayAke2R1cmF0aW9ufW1zIGZvciBxdWVyeTogXCIke3F1ZXJ5fVwiYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwYW5kIGEgcXVlcnkgdXNpbmcga2V5d29yZC1iYXNlZCB0ZWNobmlxdWVzXG4gKiBcbiAqIFRoaXMgc2ltcGxlciBhcHByb2FjaCB1c2VzIHdvcmQgZm9ybXMsIGNvbW1vbiBzeW5vbnltcywgYW5kXG4gKiBkb21haW4tc3BlY2lmaWMgdHJhbnNmb3JtYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2V5d29yZFF1ZXJ5RXhwYW5zaW9uKFxuICBxdWVyeTogc3RyaW5nLFxuICBvcHRpb25zOiBQYXJ0aWFsPFF1ZXJ5RXhwYW5zaW9uT3B0aW9ucz4gPSB7fVxuKTogc3RyaW5nW10ge1xuICBjb25zdCBjb25maWcgPSB7IC4uLkRFRkFVTFRfRVhQQU5TSU9OX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIC8vIFRyeSB0byBnZXQgY2FjaGVkIHJlc3VsdCBpZiBjYWNoaW5nIGlzIGVuYWJsZWRcbiAgaWYgKGNvbmZpZy5lbmFibGVDYWNoaW5nKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBga2V5d29yZF9leHBhbnNpb246JHtxdWVyeX1gO1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGdldENhY2hlZFJlc3VsdChjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCAmJiBBcnJheS5pc0FycmF5KGNhY2hlZFJlc3VsdCkpIHtcbiAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYENhY2hlIGhpdCBmb3Iga2V5d29yZCBleHBhbnNpb24gb2YgcXVlcnk6IFwiJHtxdWVyeX1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgLy8gVG9rZW5pemUgdGhlIHF1ZXJ5XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUocXVlcnkpO1xuICAgIGNvbnN0IGV4cGFuZGVkVGVybXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgcXVlcnlMb3dlciA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgLy8gQ29tbW9uIGJ1c2luZXNzIHRlcm1zIHN5bm9ueW1zL3JlbGF0ZWQgdGVybXMgLSBleHBhbmRlZCB3aXRoIG1vcmUgcmVsZXZhbnQgdGVybXNcbiAgICBjb25zdCBzeW5vbnltTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gICAgICAncHJpY2UnOiBbJ2Nvc3QnLCAncHJpY2luZycsICdmZWUnLCAnc3Vic2NyaXB0aW9uJywgJ3ByaWNpbmcgcGxhbnMnXSxcbiAgICAgICdwcmljaW5nJzogWydwcmljZScsICdjb3N0JywgJ2ZlZScsICdzdWJzY3JpcHRpb24nLCAncmF0ZSBjYXJkJ10sXG4gICAgICAnY29zdCc6IFsncHJpY2UnLCAncHJpY2luZycsICdleHBlbnNlJywgJ2ZlZScsICdidWRnZXQnXSxcbiAgICAgICdkaXNjb3VudCc6IFsnb2ZmZXInLCAnZGVhbCcsICdwcm9tb3Rpb24nLCAncmVkdWNlZCcsICdzYXZpbmdzJywgJ3NwZWNpYWwgb2ZmZXInXSxcbiAgICAgICdmZWF0dXJlJzogWydjYXBhYmlsaXR5JywgJ2Z1bmN0aW9uYWxpdHknLCAnb3B0aW9uJywgJ3NlcnZpY2UnLCAndG9vbCddLFxuICAgICAgJ3NlY3VyaXR5JzogWydwcm90ZWN0aW9uJywgJ3ByaXZhY3knLCAnc2VjdXJlJywgJ2VuY3J5cHRpb24nLCAnZGF0YSBwcm90ZWN0aW9uJ10sXG4gICAgICAnc3VwcG9ydCc6IFsnaGVscCcsICdhc3Npc3RhbmNlJywgJ3NlcnZpY2UnLCAnY3VzdG9tZXIgc2VydmljZScsICd0ZWNobmljYWwgc3VwcG9ydCddLFxuICAgICAgJ2NvbXBhcmUnOiBbJ2NvbXBhcmlzb24nLCAndmVyc3VzJywgJ3ZzJywgJ2RpZmZlcmVuY2UnLCAnY29tcGV0aXRpdmUgYW5hbHlzaXMnXSxcbiAgICAgICdjb21wZXRpdG9yJzogWydjb21wZXRpdGlvbicsICdhbHRlcm5hdGl2ZScsICdyaXZhbCcsICdpbmR1c3RyeSBwZWVyJywgJ21hcmtldCBjb21wZXRpdG9yJ10sXG4gICAgICAnZW50ZXJwcmlzZSc6IFsnYnVzaW5lc3MnLCAnY29ycG9yYXRlJywgJ2NvbXBhbnknLCAnb3JnYW5pemF0aW9uJywgJ2xhcmdlIGNvbXBhbnknXSxcbiAgICAgICdwbGFuJzogWydwYWNrYWdlJywgJ3RpZXInLCAnc3Vic2NyaXB0aW9uJywgJ29mZmVyaW5nJywgJ3NlcnZpY2UgbGV2ZWwnXSxcbiAgICAgICdiYXNpYyc6IFsnc3RhcnRlcicsICdzdGFuZGFyZCcsICdlbnRyeS1sZXZlbCcsICdmdW5kYW1lbnRhbCcsICdlc3NlbnRpYWwnXSxcbiAgICAgICdwcm9mZXNzaW9uYWwnOiBbJ3ByZW1pdW0nLCAnYWR2YW5jZWQnLCAnZXhwZXJ0JywgJ3BybycsICdidXNpbmVzcyBsZXZlbCddLFxuICAgICAgJ3VwZ3JhZGUnOiBbJ2VuaGFuY2UnLCAnaW1wcm92ZScsICdhZHZhbmNlJywgJ21vdmUgdXAnLCAnc3dpdGNoIHBsYW5zJ10sXG4gICAgICAndGVhbSc6IFsnZ3JvdXAnLCAnc3RhZmYnLCAnZW1wbG95ZWVzJywgJ3dvcmtmb3JjZScsICdwZXJzb25uZWwnXSxcbiAgICAgICd1c2VyJzogWydhY2NvdW50JywgJ3NlYXQnLCAnbGljZW5zZScsICdtZW1iZXInLCAnaW5kaXZpZHVhbCddXG4gICAgfTtcbiAgICBcbiAgICAvLyBEb21haW4tc3BlY2lmaWMgdHJhbnNmb3JtYXRpb25zIC0gbW9yZSBmb2N1c2VkIG9uIHF1ZXJ5IHR5cGVcbiAgICAvLyBQcmljaW5nIHF1ZXJpZXNcbiAgICBpZiAocXVlcnlMb3dlci5pbmNsdWRlcygncHJpY2UnKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCdjb3N0JykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygncHJpY2luZycpKSB7XG4gICAgICBleHBhbmRlZFRlcm1zLnB1c2goJ3ByaWNpbmcgcGxhbnMnKTtcbiAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgnc3Vic2NyaXB0aW9uIG9wdGlvbnMnKTtcbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2VudGVycHJpc2UnKSB8fCBxdWVyeUxvd2VyLmluY2x1ZGVzKCdidXNpbmVzcycpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2NvcnBvcmF0ZScpKSB7XG4gICAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgnZW50ZXJwcmlzZSBwcmljaW5nJyk7XG4gICAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgnYnVzaW5lc3MgcmF0ZXMnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2Jhc2ljJykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygnc3RhbmRhcmQnKSkge1xuICAgICAgICBleHBhbmRlZFRlcm1zLnB1c2goJ2Jhc2ljIHBsYW4gcHJpY2luZycpO1xuICAgICAgICBleHBhbmRlZFRlcm1zLnB1c2goJ3N0YW5kYXJkIHRpZXIgY29zdCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDb21wYXJlL2NvbXBldGl0b3IgcXVlcmllc1xuICAgIGlmIChxdWVyeUxvd2VyLmluY2x1ZGVzKCdjb21wYXJlJykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygnY29tcGV0aXRvcicpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3ZzJykpIHtcbiAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgndmVyc3VzIGNvbXBldGl0b3JzJyk7XG4gICAgICBleHBhbmRlZFRlcm1zLnB1c2goJ2NvbXBldGl0aXZlIGFkdmFudGFnZScpO1xuICAgICAgZXhwYW5kZWRUZXJtcy5wdXNoKCdwcm9kdWN0IGNvbXBhcmlzb24nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGlzY291bnQgcXVlcmllc1xuICAgIGlmIChxdWVyeUxvd2VyLmluY2x1ZGVzKCdkaXNjb3VudCcpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ29mZmVyJykpIHtcbiAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgnc3BlY2lhbCBwcmljaW5nJyk7XG4gICAgICBleHBhbmRlZFRlcm1zLnB1c2goJ3Byb21vdGlvbmFsIGRpc2NvdW50Jyk7XG4gICAgICBleHBhbmRlZFRlcm1zLnB1c2goJ3ZvbHVtZSBkaXNjb3VudCcpO1xuICAgICAgXG4gICAgICBpZiAocXVlcnlMb3dlci5pbmNsdWRlcygnZWR1Y2F0aW9uJykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygnc3R1ZGVudCcpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3NjaG9vbCcpKSB7XG4gICAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgnZWR1Y2F0aW9uYWwgZGlzY291bnQnKTtcbiAgICAgICAgZXhwYW5kZWRUZXJtcy5wdXNoKCdhY2FkZW1pYyBwcmljaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEZlYXR1cmUgcXVlcmllc1xuICAgIGlmIChxdWVyeUxvd2VyLmluY2x1ZGVzKCdmZWF0dXJlJykgfHwgcXVlcnlMb3dlci5pbmNsdWRlcygnaW5jbHVkZScpIHx8IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ29mZmVyJykpIHtcbiAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgncHJvZHVjdCBmZWF0dXJlcycpO1xuICAgICAgZXhwYW5kZWRUZXJtcy5wdXNoKCdpbmNsdWRlZCBjYXBhYmlsaXRpZXMnKTtcbiAgICAgIGV4cGFuZGVkVGVybXMucHVzaCgnc2VydmljZSBvZmZlcmluZ3MnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHN5bm9ueW1zIGZvciBlYWNoIHRva2VuXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIGNvbnN0IGxvd2VyVG9rZW4gPSB0b2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHN5bm9ueW1NYXBbbG93ZXJUb2tlbl0pIHtcbiAgICAgICAgLy8gQWRkIHJlbGV2YW50IHN5bm9ueW1zXG4gICAgICAgIGV4cGFuZGVkVGVybXMucHVzaCguLi5zeW5vbnltTWFwW2xvd2VyVG9rZW5dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIGxpbWl0IHRvIG1heCB0ZXJtc1xuICAgIGNvbnN0IHVuaXF1ZVRlcm1zID0gWy4uLm5ldyBTZXQoZXhwYW5kZWRUZXJtcyldXG4gICAgICAuZmlsdGVyKHRlcm0gPT4gIXF1ZXJ5TG93ZXIuaW5jbHVkZXModGVybS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgIC5zbGljZSgwLCBjb25maWcubWF4RXhwYW5kZWRUZXJtcyk7XG4gICAgXG4gICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCBpZiBjYWNoaW5nIGlzIGVuYWJsZWRcbiAgICBpZiAoY29uZmlnLmVuYWJsZUNhY2hpbmcgJiYgdW5pcXVlVGVybXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBga2V5d29yZF9leHBhbnNpb246JHtxdWVyeX1gO1xuICAgICAgY2FjaGVSZXN1bHQoY2FjaGVLZXksIHVuaXF1ZVRlcm1zLCBjb25maWcuY2FjaGVUdGxTZWNvbmRzKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYEtleXdvcmQgZXhwYW5zaW9uIHRvb2sgJHtkdXJhdGlvbn1tcyBmb3IgcXVlcnk6IFwiJHtxdWVyeX1cImApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdW5pcXVlVGVybXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nRXJyb3IoZXJyb3IsICdrZXl3b3JkUXVlcnlFeHBhbnNpb24nKTtcbiAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvclxuICB9XG59XG5cbi8qKlxuICogQW5hbHl6ZSBxdWVyeSB0byBkZXRlcm1pbmUgZG9tYWluIGNvbnRleHQgYW5kIHRlY2huaWNhbCBsZXZlbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYW5hbHl6ZVF1ZXJ5KFxuICBxdWVyeTogc3RyaW5nXG4pOiBQcm9taXNlPHtcbiAgdGVjaG5pY2FsTGV2ZWw6IG51bWJlcjtcbiAgZG9tYWluQ29udGV4dDogc3RyaW5nO1xuICBjb21wbGV4aXR5OiBudW1iZXI7XG59PiB7XG4gIHRyeSB7XG4gICAgLy8gVHJ5IHRvIGdldCBjYWNoZWQgcmVzdWx0XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgcXVlcnlfYW5hbHlzaXM6JHtxdWVyeX1gO1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGF3YWl0IGdldENhY2hlZFJlc3VsdChjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gYFlvdSBhcmUgYW4gZXhwZXJ0IHF1ZXJ5IGFuYWx5emVyLiBBbmFseXplIHRoZSBnaXZlbiBxdWVyeSBhbmQgZGV0ZXJtaW5lOlxuMS4gVGVjaG5pY2FsIGxldmVsICgxLTUgc2NhbGUgd2hlcmUgMT1iYXNpYywgNT1oaWdobHkgdGVjaG5pY2FsKVxuMi4gRG9tYWluIGNvbnRleHQgKHNpbmdsZSB3b3JkOiBwcmljaW5nLCB0ZWNobmljYWwsIHN1cHBvcnQsIGZlYXR1cmUsIGNvbXBhcmlzb24sIGdlbmVyYWwpXG4zLiBDb21wbGV4aXR5ICgxLTUgc2NhbGUgd2hlcmUgMT1zaW1wbGUsIDU9Y29tcGxleClgO1xuXG4gICAgY29uc3QgdXNlclByb21wdCA9IGBRdWVyeTogJHtxdWVyeX1cbiAgICBcblBsZWFzZSBhbmFseXplIHRoaXMgcXVlcnkgYW5kIHJldHVybiBhIEpTT04gb2JqZWN0IHdpdGggdGVjaG5pY2FsTGV2ZWwgKG51bWJlciAxLTUpLCBkb21haW5Db250ZXh0IChzdHJpbmcpLCBhbmQgY29tcGxleGl0eSAobnVtYmVyIDEtNSkuYDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlU3RydWN0dXJlZFJlc3BvbnNlKFxuICAgICAgc3lzdGVtUHJvbXB0LFxuICAgICAgdXNlclByb21wdCxcbiAgICAgIHtcbiAgICAgICAgdGVjaG5pY2FsTGV2ZWw6IDEsXG4gICAgICAgIGRvbWFpbkNvbnRleHQ6IFwiZ2VuZXJhbFwiLFxuICAgICAgICBjb21wbGV4aXR5OiAxXG4gICAgICB9LFxuICAgICAgJ2dwdC0zLjUtdHVyYm8nXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcbiAgICAgIHRlY2huaWNhbExldmVsOiByZXN1bHQ/LnRlY2huaWNhbExldmVsIHx8IDEsXG4gICAgICBkb21haW5Db250ZXh0OiByZXN1bHQ/LmRvbWFpbkNvbnRleHQgfHwgJ2dlbmVyYWwnLFxuICAgICAgY29tcGxleGl0eTogcmVzdWx0Py5jb21wbGV4aXR5IHx8IDFcbiAgICB9O1xuICAgIFxuICAgIC8vIENhY2hlIHRoZSByZXN1bHRcbiAgICBhd2FpdCBjYWNoZVJlc3VsdChjYWNoZUtleSwgYW5hbHlzaXMsIDg2NDAwKTsgLy8gMjQgaG91cnMgVFRMXG4gICAgXG4gICAgcmV0dXJuIGFuYWx5c2lzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ0Vycm9yKGVycm9yLCAnYW5hbHl6ZVF1ZXJ5Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlY2huaWNhbExldmVsOiAxLFxuICAgICAgZG9tYWluQ29udGV4dDogJ2dlbmVyYWwnLFxuICAgICAgY29tcGxleGl0eTogMVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHRvIGV4cGFuZCBhIHF1ZXJ5IHVzaW5nIG11bHRpcGxlIHRlY2huaXF1ZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGFuZFF1ZXJ5KFxuICBxdWVyeTogc3RyaW5nLFxuICBvcHRpb25zOiBQYXJ0aWFsPFF1ZXJ5RXhwYW5zaW9uT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTxFeHBhbmRlZFF1ZXJ5PiB7XG4gIGNvbnN0IGNvbmZpZyA9IHsgLi4uREVGQVVMVF9FWFBBTlNJT05fT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICBsZXQgZXhwYW5zaW9uVHlwZTogJ3NlbWFudGljJyB8ICdrZXl3b3JkJyB8ICdoeWJyaWQnIHwgJ25vbmUnID0gJ25vbmUnO1xuICBsZXQgYWRkZWRUZXJtczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIHRyeSB7XG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYEV4cGFuZGluZyBxdWVyeTogXCIke3F1ZXJ5fVwiYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBnZXQgY2FjaGVkIGZ1bGwgZXhwYW5zaW9uIHJlc3VsdFxuICAgIGlmIChjb25maWcuZW5hYmxlQ2FjaGluZykge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBgZnVsbF9leHBhbnNpb246JHtxdWVyeX06JHtjb25maWcudXNlU2VtYW50aWNFeHBhbnNpb259OiR7Y29uZmlnLnVzZUtleXdvcmRFeHBhbnNpb259OiR7Y29uZmlnLm1heEV4cGFuZGVkVGVybXN9YDtcbiAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGF3YWl0IGdldENhY2hlZFJlc3VsdChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FjaGUgaGl0IGZvciBmdWxsIGV4cGFuc2lvbiBvZiBxdWVyeTogXCIke3F1ZXJ5fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jYWNoZWRSZXN1bHQsXG4gICAgICAgICAgcHJvY2Vzc2luZ1RpbWVNczogMCAvLyBDYWNoZWQgcmVzdWx0IGhhcyBubyBwcm9jZXNzaW5nIHRpbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHF1ZXJ5IGFuYWx5c2lzIHRvIGRldGVybWluZSBleHBhbnNpb24gc3RyYXRlZ3lcbiAgICBsZXQgYW5hbHlzaXMgPSB7IHRlY2huaWNhbExldmVsOiAxLCBkb21haW5Db250ZXh0OiAnZ2VuZXJhbCcsIGNvbXBsZXhpdHk6IDEgfTtcbiAgICBpZiAoY29uZmlnLmluY2x1ZGVNZXRhZGF0YSB8fCBjb25maWcuZGVidWcpIHtcbiAgICAgIGFuYWx5c2lzID0gYXdhaXQgYW5hbHl6ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRqdXN0IHNlbWFudGljL2tleXdvcmQgd2VpZ2h0cyBiYXNlZCBvbiBxdWVyeSBjaGFyYWN0ZXJpc3RpY3NcbiAgICBsZXQgZHluYW1pY1NlbWFudGljV2VpZ2h0ID0gY29uZmlnLnNlbWFudGljV2VpZ2h0O1xuICAgIFxuICAgIC8vIE1vcmUgY29tcGxleCBvciB0ZWNobmljYWwgcXVlcmllcyBiZW5lZml0IGZyb20gc2VtYW50aWMgZXhwYW5zaW9uXG4gICAgaWYgKGFuYWx5c2lzLmNvbXBsZXhpdHkgPiAzIHx8IGFuYWx5c2lzLnRlY2huaWNhbExldmVsID4gMykge1xuICAgICAgZHluYW1pY1NlbWFudGljV2VpZ2h0ID0gTWF0aC5taW4oMC45LCBkeW5hbWljU2VtYW50aWNXZWlnaHQgKyAwLjIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTaW1wbGUgcHJpY2luZyBvciBmZWF0dXJlIHF1ZXJpZXMgb2Z0ZW4gZG8gd2VsbCB3aXRoIGtleXdvcmQgZXhwYW5zaW9uXG4gICAgaWYgKGFuYWx5c2lzLmNvbXBsZXhpdHkgPCAyICYmIFxuICAgICAgICAoYW5hbHlzaXMuZG9tYWluQ29udGV4dCA9PT0gJ3ByaWNpbmcnIHx8IGFuYWx5c2lzLmRvbWFpbkNvbnRleHQgPT09ICdmZWF0dXJlJykpIHtcbiAgICAgIGR5bmFtaWNTZW1hbnRpY1dlaWdodCA9IE1hdGgubWF4KDAuMywgZHluYW1pY1NlbWFudGljV2VpZ2h0IC0gMC4yKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYFF1ZXJ5IGFuYWx5c2lzOiBsZXZlbD0ke2FuYWx5c2lzLnRlY2huaWNhbExldmVsfSwgZG9tYWluPSR7YW5hbHlzaXMuZG9tYWluQ29udGV4dH0sIGNvbXBsZXhpdHk9JHthbmFseXNpcy5jb21wbGV4aXR5fWApO1xuICAgICAgY29uc29sZS5sb2coYFVzaW5nIHNlbWFudGljIHdlaWdodDogJHtkeW5hbWljU2VtYW50aWNXZWlnaHR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2V0IG9mIGFkZGVkIHRlcm1zXG4gICAgYWRkZWRUZXJtcyA9IFtdO1xuICAgIFxuICAgIC8vIFRyeSBzZW1hbnRpYyBleHBhbnNpb24gaWYgZW5hYmxlZFxuICAgIGNvbnN0IHNlbWFudGljVGVybXM6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGNvbmZpZy51c2VTZW1hbnRpY0V4cGFuc2lvbikge1xuICAgICAgY29uc3Qgc2VtUmVzdWx0cyA9IGF3YWl0IHNlbWFudGljUXVlcnlFeHBhbnNpb24ocXVlcnksIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBtYXhFeHBhbmRlZFRlcm1zOiBNYXRoLmNlaWwoY29uZmlnLm1heEV4cGFuZGVkVGVybXMgKiBkeW5hbWljU2VtYW50aWNXZWlnaHQpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHNlbVJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZW1hbnRpY1Rlcm1zLnB1c2goLi4uc2VtUmVzdWx0cyk7XG4gICAgICAgIGV4cGFuc2lvblR5cGUgPSAnc2VtYW50aWMnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQga2V5d29yZC1iYXNlZCBleHBhbnNpb24gaWYgZW5hYmxlZFxuICAgIGNvbnN0IGtleXdvcmRUZXJtczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoY29uZmlnLnVzZUtleXdvcmRFeHBhbnNpb24pIHtcbiAgICAgIGNvbnN0IGt3UmVzdWx0cyA9IGtleXdvcmRRdWVyeUV4cGFuc2lvbihxdWVyeSwge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIG1heEV4cGFuZGVkVGVybXM6IE1hdGguY2VpbChjb25maWcubWF4RXhwYW5kZWRUZXJtcyAqICgxIC0gZHluYW1pY1NlbWFudGljV2VpZ2h0KSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoa3dSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5d29yZFRlcm1zLnB1c2goLi4ua3dSZXN1bHRzKTtcbiAgICAgICAgZXhwYW5zaW9uVHlwZSA9IHNlbWFudGljVGVybXMubGVuZ3RoID4gMCA/ICdoeWJyaWQnIDogJ2tleXdvcmQnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDb21iaW5lIHJlc3VsdHMgYmFzZWQgb24gd2VpZ2h0c1xuICAgIGlmIChzZW1hbnRpY1Rlcm1zLmxlbmd0aCA+IDAgJiYga2V5d29yZFRlcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSB0ZXJtcyB0byB0YWtlIGZyb20gZWFjaCBzb3VyY2VcbiAgICAgIGNvbnN0IHNlbWFudGljQ291bnQgPSBNYXRoLm1pbihcbiAgICAgICAgc2VtYW50aWNUZXJtcy5sZW5ndGgsXG4gICAgICAgIE1hdGgubWF4KDEsIE1hdGgucm91bmQoY29uZmlnLm1heEV4cGFuZGVkVGVybXMgKiBkeW5hbWljU2VtYW50aWNXZWlnaHQpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3Qga2V5d29yZENvdW50ID0gTWF0aC5taW4oXG4gICAgICAgIGtleXdvcmRUZXJtcy5sZW5ndGgsXG4gICAgICAgIGNvbmZpZy5tYXhFeHBhbmRlZFRlcm1zIC0gc2VtYW50aWNDb3VudFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgYWRkZWRUZXJtcyA9IFtcbiAgICAgICAgLi4uc2VtYW50aWNUZXJtcy5zbGljZSgwLCBzZW1hbnRpY0NvdW50KSxcbiAgICAgICAgLi4ua2V5d29yZFRlcm1zLnNsaWNlKDAsIGtleXdvcmRDb3VudClcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGV4cGFuc2lvblR5cGUgPSAnaHlicmlkJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSnVzdCBhZGQgd2hhdGV2ZXIgd2UgaGF2ZVxuICAgICAgYWRkZWRUZXJtcyA9IFsuLi5zZW1hbnRpY1Rlcm1zLCAuLi5rZXl3b3JkVGVybXNdO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlcyBhbmQgZmlsdGVyIG91dCB0ZXJtcyBhbHJlYWR5IGluIHRoZSBxdWVyeVxuICAgIGFkZGVkVGVybXMgPSBbLi4ubmV3IFNldChhZGRlZFRlcm1zKV1cbiAgICAgIC5maWx0ZXIodGVybSA9PiAhcXVlcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgLnNsaWNlKDAsIGNvbmZpZy5tYXhFeHBhbmRlZFRlcm1zKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgZXhwYW5kZWQgcXVlcnkgYnkgY29tYmluaW5nIG9yaWdpbmFsIHdpdGggYWRkZWQgdGVybXNcbiAgICBjb25zdCBleHBhbmRlZFF1ZXJ5ID0gYWRkZWRUZXJtcy5sZW5ndGggPiAwXG4gICAgICA/IGAke3F1ZXJ5fSAke2FkZGVkVGVybXMuam9pbignICcpfWBcbiAgICAgIDogcXVlcnk7XG4gICAgXG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYE9yaWdpbmFsIHF1ZXJ5OiBcIiR7cXVlcnl9XCJgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBFeHBhbmRlZCBxdWVyeTogXCIke2V4cGFuZGVkUXVlcnl9XCJgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBBZGRlZCB0ZXJtczogJHthZGRlZFRlcm1zLmpvaW4oJywgJyl9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgRXhwYW5zaW9uIHR5cGU6ICR7ZXhwYW5zaW9uVHlwZX1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgb3JpZ2luYWxRdWVyeTogcXVlcnksXG4gICAgICBleHBhbmRlZFF1ZXJ5LFxuICAgICAgYWRkZWRUZXJtcyxcbiAgICAgIGV4cGFuc2lvblR5cGUsXG4gICAgICB0ZWNobmljYWxMZXZlbDogYW5hbHlzaXMudGVjaG5pY2FsTGV2ZWwsXG4gICAgICBkb21haW5Db250ZXh0OiBhbmFseXNpcy5kb21haW5Db250ZXh0LFxuICAgICAgcHJvY2Vzc2luZ1RpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgIH07XG4gICAgXG4gICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgIGlmIChjb25maWcuZW5hYmxlQ2FjaGluZyAmJiBhZGRlZFRlcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYGZ1bGxfZXhwYW5zaW9uOiR7cXVlcnl9OiR7Y29uZmlnLnVzZVNlbWFudGljRXhwYW5zaW9ufToke2NvbmZpZy51c2VLZXl3b3JkRXhwYW5zaW9ufToke2NvbmZpZy5tYXhFeHBhbmRlZFRlcm1zfWA7XG4gICAgICBhd2FpdCBjYWNoZVJlc3VsdChjYWNoZUtleSwgcmVzdWx0LCBjb25maWcuY2FjaGVUdGxTZWNvbmRzKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dFcnJvcihlcnJvciwgJ2V4cGFuZFF1ZXJ5Jyk7XG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIFxuICAgIC8vIFJldHVybiBvcmlnaW5hbCBxdWVyeSBvbiBlcnJvclxuICAgIHJldHVybiB7XG4gICAgICBvcmlnaW5hbFF1ZXJ5OiBxdWVyeSxcbiAgICAgIGV4cGFuZGVkUXVlcnk6IHF1ZXJ5LFxuICAgICAgYWRkZWRUZXJtczogW10sXG4gICAgICBleHBhbnNpb25UeXBlOiAnbm9uZScsXG4gICAgICBwcm9jZXNzaW5nVGltZU1zOiBwcm9jZXNzaW5nVGltZVxuICAgIH07XG4gIH1cbn0gIl0sIm5hbWVzIjpbImdlbmVyYXRlQ2hhdENvbXBsZXRpb24iLCJnZW5lcmF0ZVN0cnVjdHVyZWRSZXNwb25zZSIsInRva2VuaXplIiwibG9nRXJyb3IiLCJnZXRDYWNoZWRSZXN1bHQiLCJjYWNoZVJlc3VsdCIsIkRFRkFVTFRfRVhQQU5TSU9OX09QVElPTlMiLCJtYXhFeHBhbmRlZFRlcm1zIiwibW9kZWwiLCJ1c2VTZW1hbnRpY0V4cGFuc2lvbiIsInVzZUtleXdvcmRFeHBhbnNpb24iLCJzZW1hbnRpY1dlaWdodCIsImluY2x1ZGVNZXRhZGF0YSIsInRpbWVvdXRNcyIsImVuYWJsZUNhY2hpbmciLCJjYWNoZVR0bFNlY29uZHMiLCJkZWJ1ZyIsInNlbWFudGljUXVlcnlFeHBhbnNpb24iLCJxdWVyeSIsIm9wdGlvbnMiLCJjb25maWciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY2FjaGVLZXkiLCJjYWNoZWRSZXN1bHQiLCJjb25zb2xlIiwibG9nIiwic3lzdGVtUHJvbXB0IiwidXNlclByb21wdCIsImV4cGFuc2lvblByb21pc2UiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzdWx0IiwiY2xlYXJUaW1lb3V0IiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRUZXJtcyIsImZpbHRlciIsInRlcm0iLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic2xpY2UiLCJzdHJ1Y3R1cmVkRXJyb3IiLCJmYWxsYmFja1Jlc3BvbnNlIiwidGVybXMiLCJzcGxpdCIsIm1hcCIsImxpbmUiLCJ0cmltIiwicmVwbGFjZSIsInN0YXJ0c1dpdGgiLCJmYWxsYmFja0Vycm9yIiwiZXJyb3IiLCJkdXJhdGlvbiIsImtleXdvcmRRdWVyeUV4cGFuc2lvbiIsInRva2VucyIsImV4cGFuZGVkVGVybXMiLCJxdWVyeUxvd2VyIiwic3lub255bU1hcCIsInB1c2giLCJ0b2tlbiIsImxvd2VyVG9rZW4iLCJ1bmlxdWVUZXJtcyIsIlNldCIsImFuYWx5emVRdWVyeSIsInRlY2huaWNhbExldmVsIiwiZG9tYWluQ29udGV4dCIsImNvbXBsZXhpdHkiLCJhbmFseXNpcyIsImV4cGFuZFF1ZXJ5IiwiZXhwYW5zaW9uVHlwZSIsImFkZGVkVGVybXMiLCJwcm9jZXNzaW5nVGltZU1zIiwiZHluYW1pY1NlbWFudGljV2VpZ2h0IiwiTWF0aCIsIm1pbiIsIm1heCIsInNlbWFudGljVGVybXMiLCJzZW1SZXN1bHRzIiwiY2VpbCIsImtleXdvcmRUZXJtcyIsImt3UmVzdWx0cyIsInNlbWFudGljQ291bnQiLCJyb3VuZCIsImtleXdvcmRDb3VudCIsImV4cGFuZGVkUXVlcnkiLCJqb2luIiwib3JpZ2luYWxRdWVyeSIsInByb2Nlc3NpbmdUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/queryExpansion.ts\n");

/***/ }),

/***/ "(api)/./utils/reranking.ts":
/*!****************************!*\
  !*** ./utils/reranking.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RERANKING_OPTIONS: () => (/* binding */ DEFAULT_RERANKING_OPTIONS),\n/* harmony export */   rerankResults: () => (/* binding */ rerankResults),\n/* harmony export */   rerankResultsWithExplanations: () => (/* binding */ rerankResultsWithExplanations)\n/* harmony export */ });\n/* harmony import */ var _openaiClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./openaiClient */ \"(api)/./utils/openaiClient.ts\");\n/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errorHandling */ \"(api)/./utils/errorHandling.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_openaiClient__WEBPACK_IMPORTED_MODULE_0__, _errorHandling__WEBPACK_IMPORTED_MODULE_1__]);\n([_openaiClient__WEBPACK_IMPORTED_MODULE_0__, _errorHandling__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Re-ranking Module\n * \n * This module provides LLM-based re-ranking functionality for search results,\n * improving result relevance by using AI to judge the quality of each result\n * in relation to the user's query.\n */ \n\n/**\n * Default re-ranking options\n */ const DEFAULT_RERANKING_OPTIONS = {\n    returnTopN: 5,\n    model: \"gpt-3.5-turbo\",\n    parallelBatching: true,\n    timeoutMs: 10000,\n    batchSize: 5,\n    debug: false\n};\n/**\n * Re-rank search results using LLM relevance judgments\n * \n * This function takes the results from hybrid search and uses an LLM to\n * evaluate how relevant each document is to the original query.\n */ async function rerankResults(query, results, options = {}) {\n    // Apply default options\n    const config = {\n        ...DEFAULT_RERANKING_OPTIONS,\n        ...options\n    };\n    if (config.debug) {\n        console.log(`Re-ranking ${results.length} results for query: \"${query}\"`);\n    }\n    // Early return if no results\n    if (!results || results.length === 0) {\n        return [];\n    }\n    try {\n        // Split results into batches to avoid context limits\n        const batches = [];\n        for(let i = 0; i < results.length; i += config.batchSize){\n            batches.push(results.slice(i, i + config.batchSize));\n        }\n        if (config.debug) {\n            console.log(`Created ${batches.length} batches for re-ranking`);\n        }\n        // Process each batch either in parallel or sequentially\n        let rerankedResults = [];\n        if (config.parallelBatching) {\n            // Process batches in parallel with timeout protection\n            const batchPromises = batches.map((batch, idx)=>processReRankingBatch(query, batch, idx, config));\n            // Wait for all batches with timeout\n            const batchesWithTimeout = await Promise.all(batchPromises.map((promise)=>Promise.race([\n                    promise,\n                    new Promise((resolve)=>setTimeout(()=>resolve([]), config.timeoutMs))\n                ])));\n            // Flatten batch results\n            rerankedResults = batchesWithTimeout.flat();\n        } else {\n            // Process batches sequentially\n            for(let i = 0; i < batches.length; i++){\n                const batchResults = await processReRankingBatch(query, batches[i], i, config);\n                rerankedResults = [\n                    ...rerankedResults,\n                    ...batchResults\n                ];\n            }\n        }\n        // Sort by final score (descending) and limit to top N\n        const sortedResults = rerankedResults.sort((a, b)=>b.finalScore - a.finalScore).slice(0, config.returnTopN);\n        if (config.debug) {\n            console.log(`Re-ranking complete. Returning top ${sortedResults.length} results`);\n            sortedResults.forEach((result, i)=>{\n                console.log(`[${i + 1}] Final score: ${result.finalScore.toFixed(3)} (BM25: ${result.originalResult.bm25Score.toFixed(3)}, Vector: ${result.originalResult.vectorScore.toFixed(3)}, Rerank: ${result.rerankScore.toFixed(3)})`);\n            });\n        }\n        return sortedResults;\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.logError)(error, \"rerankResults\");\n        // Fall back to original results on error\n        const fallbackResults = results.map((result)=>({\n                originalResult: result,\n                rerankScore: result.combinedScore * 10,\n                finalScore: result.combinedScore\n            }));\n        return fallbackResults.sort((a, b)=>b.finalScore - a.finalScore).slice(0, config.returnTopN);\n    }\n}\n/**\n * Process a batch of results for re-ranking\n */ async function processReRankingBatch(query, batch, batchIndex, config) {\n    try {\n        // Create a system prompt that explains how to judge relevance\n        const systemPrompt = `You are a document relevance judge. Your task is to evaluate how relevant each document is to the given query on a scale of 0-10, where:\n- 10: Perfect match that directly and completely answers the query with specific details\n- 7-9: Highly relevant with most key information related to the query\n- 4-6: Somewhat relevant but lacks specific details or only partially addresses the query\n- 1-3: Only tangentially related to the query\n- 0: Not relevant at all\n\nFocus on how well the document answers the specific information need in the query.\nReturn a JSON object with your numerical scores in this format:\n{\"scores\": [number, number, ...]}`;\n        // Create a user prompt with the query and documents to score\n        const userPrompt = `Query: ${query}\n\n${batch.map((result, i)=>`DOCUMENT ${batchIndex * config.batchSize + i + 1}:\n${result.item.text.substring(0, 600)}${result.item.text.length > 600 ? \"...\" : \"\"}`).join(\"\\n\\n\")}\n\nProvide a relevance score from 0-10 for each document based on how well it answers the query.`;\n        // Generate scores using the LLM\n        const response = await (0,_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateStructuredResponse)(systemPrompt, userPrompt, {\n            scores: []\n        }, config.model);\n        // Extract scores from the response\n        const scores = response?.scores || [];\n        if (config.debug) {\n            console.log(`Batch ${batchIndex + 1} re-ranking scores:`, scores);\n        }\n        // Map scores to results\n        return batch.map((result, idx)=>{\n            const rerankScore = scores[idx] !== undefined ? scores[idx] : 5; // Default to middle score if missing\n            // Calculate final score - weighted combination of original score and rerank score\n            // Original score is typically 0-1, rerank score is 0-10, so normalize\n            const vectorWeight = 0.3;\n            const bm25Weight = 0.2;\n            const rerankWeight = 0.5; // Higher weight for LLM judgment\n            const finalScore = vectorWeight * result.vectorScore + bm25Weight * result.bm25Score + rerankWeight * (rerankScore / 10);\n            return {\n                originalResult: result,\n                rerankScore,\n                finalScore\n            };\n        });\n    } catch (error) {\n        (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.logError)(error, `processReRankingBatch_${batchIndex}`);\n        // Fallback - use original scores\n        return batch.map((result)=>({\n                originalResult: result,\n                rerankScore: result.combinedScore * 10,\n                finalScore: result.combinedScore\n            }));\n    }\n}\n/**\n * Enhanced version of reranking that provides explanation for each score\n * Useful for debugging and understanding why results were ranked as they were\n */ async function rerankResultsWithExplanations(query, results, options = {}) {\n    const config = {\n        ...DEFAULT_RERANKING_OPTIONS,\n        ...options\n    };\n    // Process just the top result for detailed analysis\n    const topResult = results.length > 0 ? results[0] : null;\n    if (!topResult) {\n        return [];\n    }\n    try {\n        // Get the text of the top result for the LLM to evaluate\n        const documentText = topResult.item.text.substring(0, 800);\n        // Create a system prompt for explaining relevance (without requiring JSON)\n        const systemPrompt = `You are a document relevance judge. \nYour task is to evaluate how relevant a document is to a user query on a scale of 0-10.\nProvide your evaluation in the following format:\nScore: [NUMBER]/10\nExplanation: [YOUR EXPLANATION]\n\nBe specific about why the document is or isn't relevant to the query.`;\n        // Create a detailed user prompt\n        const userPrompt = `Query: \"${query}\"\n\nDocument:\n${documentText}\n\nEvaluate the relevance of this document to the query. Score it from 0-10 and explain your reasoning in 1-2 sentences.`;\n        // Generate response without requiring JSON format\n        const response = await (0,_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateChatCompletion)(systemPrompt, userPrompt, config.model, false // Don't use JSON mode\n        );\n        // Parse the response to extract score and explanation\n        const scoreRegex = /Score:\\s*(\\d+(?:\\.\\d+)?)\\s*\\/\\s*10/i;\n        const explanationRegex = /Explanation:\\s*(.*?)(?:\\n|$)/is;\n        const scoreMatch = response.match(scoreRegex);\n        const explanationMatch = response.match(explanationRegex);\n        const score = scoreMatch ? parseFloat(scoreMatch[1]) : 5;\n        const explanation = explanationMatch ? explanationMatch[1].trim() : response;\n        // Return the result with explanation\n        return [\n            {\n                originalResult: topResult,\n                rerankScore: score,\n                finalScore: 0.5 * (score / 10) + 0.5 * topResult.combinedScore,\n                explanation: explanation || \"No explanation provided\"\n            }\n        ];\n    } catch (error) {\n        console.error(\"Error in rerankResultsWithExplanations:\", error);\n        // Try with fallback model if main model fails\n        try {\n            const fallbackModel = config.model === \"gpt-4\" ? \"gpt-3.5-turbo\" : \"gpt-3.5-turbo\";\n            const fallbackSystemPrompt = `You are evaluating document relevance. Rate the document's relevance to the query from 0-10 and explain why.`;\n            const fallbackUserPrompt = `Query: ${query}\\n\\nDocument: ${topResult.item.text.substring(0, 400)}`;\n            const fallbackResponse = await (0,_openaiClient__WEBPACK_IMPORTED_MODULE_0__.generateChatCompletion)(fallbackSystemPrompt, fallbackUserPrompt, fallbackModel, false);\n            // Extract a score if possible\n            const scoreMatch = fallbackResponse.match(/(\\d+(?:\\.\\d+)?)\\s*\\/\\s*10/);\n            const score = scoreMatch ? parseFloat(scoreMatch[1]) : 5;\n            return [\n                {\n                    originalResult: topResult,\n                    rerankScore: score,\n                    finalScore: topResult.combinedScore,\n                    explanation: fallbackResponse\n                }\n            ];\n        } catch (fallbackError) {\n            // Final fallback with default values\n            return [\n                {\n                    originalResult: topResult,\n                    rerankScore: 5,\n                    finalScore: topResult.combinedScore,\n                    explanation: \"Unable to generate explanation due to an error.\"\n                }\n            ];\n        }\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U0FBRTtJQUNKLEVBQUUsT0FBTzFCLE9BQU87UUFDZGxDLFFBQVFrQyxLQUFLLENBQUMsMkNBQTJDQTtRQUV6RCw4Q0FBOEM7UUFDOUMsSUFBSTtZQUNGLE1BQU00QixnQkFBZ0IvRCxPQUFPVCxLQUFLLEtBQUssVUFBVSxrQkFBa0I7WUFDbkUsTUFBTXlFLHVCQUF1QixDQUFDLDRHQUE0RyxDQUFDO1lBQzNJLE1BQU1DLHFCQUFxQixDQUFDLE9BQU8sRUFBRXBFLE1BQU0sY0FBYyxFQUFFdUQsVUFBVVgsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFNBQVMsQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUVsRyxNQUFNdUIsbUJBQW1CLE1BQU1oRixxRUFBc0JBLENBQ25EOEUsc0JBQ0FDLG9CQUNBRixlQUNBO1lBR0YsOEJBQThCO1lBQzlCLE1BQU1QLGFBQWFVLGlCQUFpQlQsS0FBSyxDQUFDO1lBQzFDLE1BQU1FLFFBQVFILGFBQWFJLFdBQVdKLFVBQVUsQ0FBQyxFQUFFLElBQUk7WUFFdkQsT0FBTztnQkFBQztvQkFDTnpCLGdCQUFnQnFCO29CQUNoQmxCLGFBQWF5QjtvQkFDYmhDLFlBQVl5QixVQUFVZixhQUFhO29CQUNuQ3dCLGFBQWFLO2dCQUNmO2FBQUU7UUFDSixFQUFFLE9BQU9DLGVBQWU7WUFDdEIscUNBQXFDO1lBQ3JDLE9BQU87Z0JBQUM7b0JBQ05wQyxnQkFBZ0JxQjtvQkFDaEJsQixhQUFhO29CQUNiUCxZQUFZeUIsVUFBVWYsYUFBYTtvQkFDbkN3QixhQUFhO2dCQUNmO2FBQUU7UUFDSjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWxlcy1jaGF0LW9wZW5haS1yYWcvLi91dGlscy9yZXJhbmtpbmcudHM/MGY1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlLXJhbmtpbmcgTW9kdWxlXG4gKiBcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIExMTS1iYXNlZCByZS1yYW5raW5nIGZ1bmN0aW9uYWxpdHkgZm9yIHNlYXJjaCByZXN1bHRzLFxuICogaW1wcm92aW5nIHJlc3VsdCByZWxldmFuY2UgYnkgdXNpbmcgQUkgdG8ganVkZ2UgdGhlIHF1YWxpdHkgb2YgZWFjaCByZXN1bHRcbiAqIGluIHJlbGF0aW9uIHRvIHRoZSB1c2VyJ3MgcXVlcnkuXG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yU3RvcmVJdGVtIH0gZnJvbSAnLi92ZWN0b3JTdG9yZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNoYXRDb21wbGV0aW9uLCBnZW5lcmF0ZVN0cnVjdHVyZWRSZXNwb25zZSB9IGZyb20gJy4vb3BlbmFpQ2xpZW50JztcbmltcG9ydCB7IEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0IH0gZnJvbSAnLi9lbmhhbmNlZFJldHJpZXZhbCc7XG5pbXBvcnQgeyBsb2dFcnJvciB9IGZyb20gJy4vZXJyb3JIYW5kbGluZyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciByZS1yYW5raW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVyYW5raW5nT3B0aW9ucyB7XG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuIGFmdGVyIHJlLXJhbmtpbmdcbiAgcmV0dXJuVG9wTjogbnVtYmVyO1xuICBcbiAgLy8gV2hpY2ggbW9kZWwgdG8gdXNlIGZvciByZS1yYW5raW5nXG4gIC8vIEZhc3RlciBtb2RlbHMgbGlrZSBncHQtMy41LXR1cmJvIGFyZSB1c3VhbGx5IHN1ZmZpY2llbnRcbiAgbW9kZWw6IHN0cmluZztcbiAgXG4gIC8vIFdoZXRoZXIgdG8gcHJvY2VzcyBiYXRjaGVzIGluIHBhcmFsbGVsXG4gIHBhcmFsbGVsQmF0Y2hpbmc6IGJvb2xlYW47XG4gIFxuICAvLyBNYXhpbXVtIHRpbWUgKGluIG1zKSB0byB3YWl0IGZvciByZS1yYW5raW5nXG4gIHRpbWVvdXRNczogbnVtYmVyO1xuICBcbiAgLy8gTnVtYmVyIG9mIGl0ZW1zIHRvIHByb2Nlc3MgaW4gZWFjaCBiYXRjaFxuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgXG4gIC8vIFdoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIGxvZ2dpbmdcbiAgZGVidWc6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCByZS1yYW5raW5nIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVSQU5LSU5HX09QVElPTlM6IFJlcmFua2luZ09wdGlvbnMgPSB7XG4gIHJldHVyblRvcE46IDUsXG4gIG1vZGVsOiAnZ3B0LTMuNS10dXJibycsXG4gIHBhcmFsbGVsQmF0Y2hpbmc6IHRydWUsXG4gIHRpbWVvdXRNczogMTAwMDAsXG4gIGJhdGNoU2l6ZTogNSxcbiAgZGVidWc6IGZhbHNlXG59O1xuXG4vKipcbiAqIFJlc3VsdCBmcm9tIHJlLXJhbmtpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXJhbmtpbmdSZXN1bHQge1xuICBvcmlnaW5hbFJlc3VsdDogRW5oYW5jZWRSZXRyaWV2YWxSZXN1bHQ7XG4gIHJlcmFua1Njb3JlOiBudW1iZXI7XG4gIGZpbmFsU2NvcmU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBSZS1yYW5rIHNlYXJjaCByZXN1bHRzIHVzaW5nIExMTSByZWxldmFuY2UganVkZ21lbnRzXG4gKiBcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgdGhlIHJlc3VsdHMgZnJvbSBoeWJyaWQgc2VhcmNoIGFuZCB1c2VzIGFuIExMTSB0b1xuICogZXZhbHVhdGUgaG93IHJlbGV2YW50IGVhY2ggZG9jdW1lbnQgaXMgdG8gdGhlIG9yaWdpbmFsIHF1ZXJ5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVyYW5rUmVzdWx0cyhcbiAgcXVlcnk6IHN0cmluZyxcbiAgcmVzdWx0czogRW5oYW5jZWRSZXRyaWV2YWxSZXN1bHRbXSxcbiAgb3B0aW9uczogUGFydGlhbDxSZXJhbmtpbmdPcHRpb25zPiA9IHt9XG4pOiBQcm9taXNlPFJlcmFua2luZ1Jlc3VsdFtdPiB7XG4gIC8vIEFwcGx5IGRlZmF1bHQgb3B0aW9uc1xuICBjb25zdCBjb25maWcgPSB7IC4uLkRFRkFVTFRfUkVSQU5LSU5HX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgXG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhgUmUtcmFua2luZyAke3Jlc3VsdHMubGVuZ3RofSByZXN1bHRzIGZvciBxdWVyeTogXCIke3F1ZXJ5fVwiYCk7XG4gIH1cbiAgXG4gIC8vIEVhcmx5IHJldHVybiBpZiBubyByZXN1bHRzXG4gIGlmICghcmVzdWx0cyB8fCByZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICAvLyBTcGxpdCByZXN1bHRzIGludG8gYmF0Y2hlcyB0byBhdm9pZCBjb250ZXh0IGxpbWl0c1xuICAgIGNvbnN0IGJhdGNoZXM6IEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0W11bXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkgKz0gY29uZmlnLmJhdGNoU2l6ZSkge1xuICAgICAgYmF0Y2hlcy5wdXNoKHJlc3VsdHMuc2xpY2UoaSwgaSArIGNvbmZpZy5iYXRjaFNpemUpKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgJHtiYXRjaGVzLmxlbmd0aH0gYmF0Y2hlcyBmb3IgcmUtcmFua2luZ2ApO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIGVhY2ggYmF0Y2ggZWl0aGVyIGluIHBhcmFsbGVsIG9yIHNlcXVlbnRpYWxseVxuICAgIGxldCByZXJhbmtlZFJlc3VsdHM6IFJlcmFua2luZ1Jlc3VsdFtdID0gW107XG4gICAgXG4gICAgaWYgKGNvbmZpZy5wYXJhbGxlbEJhdGNoaW5nKSB7XG4gICAgICAvLyBQcm9jZXNzIGJhdGNoZXMgaW4gcGFyYWxsZWwgd2l0aCB0aW1lb3V0IHByb3RlY3Rpb25cbiAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBiYXRjaGVzLm1hcCgoYmF0Y2gsIGlkeCkgPT4gXG4gICAgICAgIHByb2Nlc3NSZVJhbmtpbmdCYXRjaChxdWVyeSwgYmF0Y2gsIGlkeCwgY29uZmlnKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgYWxsIGJhdGNoZXMgd2l0aCB0aW1lb3V0XG4gICAgICBjb25zdCBiYXRjaGVzV2l0aFRpbWVvdXQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgYmF0Y2hQcm9taXNlcy5tYXAocHJvbWlzZSA9PiBcbiAgICAgICAgICBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgIG5ldyBQcm9taXNlPFJlcmFua2luZ1Jlc3VsdFtdPigocmVzb2x2ZSkgPT4gXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShbXSksIGNvbmZpZy50aW1lb3V0TXMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gRmxhdHRlbiBiYXRjaCByZXN1bHRzXG4gICAgICByZXJhbmtlZFJlc3VsdHMgPSBiYXRjaGVzV2l0aFRpbWVvdXQuZmxhdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9jZXNzIGJhdGNoZXMgc2VxdWVudGlhbGx5XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gYXdhaXQgcHJvY2Vzc1JlUmFua2luZ0JhdGNoKFxuICAgICAgICAgIHF1ZXJ5LCBiYXRjaGVzW2ldLCBpLCBjb25maWdcbiAgICAgICAgKTtcbiAgICAgICAgcmVyYW5rZWRSZXN1bHRzID0gWy4uLnJlcmFua2VkUmVzdWx0cywgLi4uYmF0Y2hSZXN1bHRzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBieSBmaW5hbCBzY29yZSAoZGVzY2VuZGluZykgYW5kIGxpbWl0IHRvIHRvcCBOXG4gICAgY29uc3Qgc29ydGVkUmVzdWx0cyA9IHJlcmFua2VkUmVzdWx0c1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuZmluYWxTY29yZSAtIGEuZmluYWxTY29yZSlcbiAgICAgIC5zbGljZSgwLCBjb25maWcucmV0dXJuVG9wTik7XG4gICAgXG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYFJlLXJhbmtpbmcgY29tcGxldGUuIFJldHVybmluZyB0b3AgJHtzb3J0ZWRSZXN1bHRzLmxlbmd0aH0gcmVzdWx0c2ApO1xuICAgICAgc29ydGVkUmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFske2krMX1dIEZpbmFsIHNjb3JlOiAke3Jlc3VsdC5maW5hbFNjb3JlLnRvRml4ZWQoMyl9IChCTTI1OiAke3Jlc3VsdC5vcmlnaW5hbFJlc3VsdC5ibTI1U2NvcmUudG9GaXhlZCgzKX0sIFZlY3RvcjogJHtyZXN1bHQub3JpZ2luYWxSZXN1bHQudmVjdG9yU2NvcmUudG9GaXhlZCgzKX0sIFJlcmFuazogJHtyZXN1bHQucmVyYW5rU2NvcmUudG9GaXhlZCgzKX0pYCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNvcnRlZFJlc3VsdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nRXJyb3IoZXJyb3IsICdyZXJhbmtSZXN1bHRzJyk7XG4gICAgXG4gICAgLy8gRmFsbCBiYWNrIHRvIG9yaWdpbmFsIHJlc3VsdHMgb24gZXJyb3JcbiAgICBjb25zdCBmYWxsYmFja1Jlc3VsdHM6IFJlcmFua2luZ1Jlc3VsdFtdID0gcmVzdWx0cy5tYXAocmVzdWx0ID0+ICh7XG4gICAgICBvcmlnaW5hbFJlc3VsdDogcmVzdWx0LFxuICAgICAgcmVyYW5rU2NvcmU6IHJlc3VsdC5jb21iaW5lZFNjb3JlICogMTAsIC8vIFNjYWxlIHVwIHRvIDAtMTAgcmFuZ2VcbiAgICAgIGZpbmFsU2NvcmU6IHJlc3VsdC5jb21iaW5lZFNjb3JlXG4gICAgfSkpO1xuICAgIFxuICAgIHJldHVybiBmYWxsYmFja1Jlc3VsdHNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmZpbmFsU2NvcmUgLSBhLmZpbmFsU2NvcmUpXG4gICAgICAuc2xpY2UoMCwgY29uZmlnLnJldHVyblRvcE4pO1xuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGJhdGNoIG9mIHJlc3VsdHMgZm9yIHJlLXJhbmtpbmdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1JlUmFua2luZ0JhdGNoKFxuICBxdWVyeTogc3RyaW5nLFxuICBiYXRjaDogRW5oYW5jZWRSZXRyaWV2YWxSZXN1bHRbXSxcbiAgYmF0Y2hJbmRleDogbnVtYmVyLFxuICBjb25maWc6IFJlcmFua2luZ09wdGlvbnNcbik6IFByb21pc2U8UmVyYW5raW5nUmVzdWx0W10+IHtcbiAgdHJ5IHtcbiAgICAvLyBDcmVhdGUgYSBzeXN0ZW0gcHJvbXB0IHRoYXQgZXhwbGFpbnMgaG93IHRvIGp1ZGdlIHJlbGV2YW5jZVxuICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IGBZb3UgYXJlIGEgZG9jdW1lbnQgcmVsZXZhbmNlIGp1ZGdlLiBZb3VyIHRhc2sgaXMgdG8gZXZhbHVhdGUgaG93IHJlbGV2YW50IGVhY2ggZG9jdW1lbnQgaXMgdG8gdGhlIGdpdmVuIHF1ZXJ5IG9uIGEgc2NhbGUgb2YgMC0xMCwgd2hlcmU6XG4tIDEwOiBQZXJmZWN0IG1hdGNoIHRoYXQgZGlyZWN0bHkgYW5kIGNvbXBsZXRlbHkgYW5zd2VycyB0aGUgcXVlcnkgd2l0aCBzcGVjaWZpYyBkZXRhaWxzXG4tIDctOTogSGlnaGx5IHJlbGV2YW50IHdpdGggbW9zdCBrZXkgaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgcXVlcnlcbi0gNC02OiBTb21ld2hhdCByZWxldmFudCBidXQgbGFja3Mgc3BlY2lmaWMgZGV0YWlscyBvciBvbmx5IHBhcnRpYWxseSBhZGRyZXNzZXMgdGhlIHF1ZXJ5XG4tIDEtMzogT25seSB0YW5nZW50aWFsbHkgcmVsYXRlZCB0byB0aGUgcXVlcnlcbi0gMDogTm90IHJlbGV2YW50IGF0IGFsbFxuXG5Gb2N1cyBvbiBob3cgd2VsbCB0aGUgZG9jdW1lbnQgYW5zd2VycyB0aGUgc3BlY2lmaWMgaW5mb3JtYXRpb24gbmVlZCBpbiB0aGUgcXVlcnkuXG5SZXR1cm4gYSBKU09OIG9iamVjdCB3aXRoIHlvdXIgbnVtZXJpY2FsIHNjb3JlcyBpbiB0aGlzIGZvcm1hdDpcbntcInNjb3Jlc1wiOiBbbnVtYmVyLCBudW1iZXIsIC4uLl19YDtcblxuICAgIC8vIENyZWF0ZSBhIHVzZXIgcHJvbXB0IHdpdGggdGhlIHF1ZXJ5IGFuZCBkb2N1bWVudHMgdG8gc2NvcmVcbiAgICBjb25zdCB1c2VyUHJvbXB0ID0gYFF1ZXJ5OiAke3F1ZXJ5fVxuXG4ke2JhdGNoLm1hcCgocmVzdWx0LCBpKSA9PiBgRE9DVU1FTlQgJHtiYXRjaEluZGV4ICogY29uZmlnLmJhdGNoU2l6ZSArIGkgKyAxfTpcbiR7cmVzdWx0Lml0ZW0udGV4dC5zdWJzdHJpbmcoMCwgNjAwKX0ke3Jlc3VsdC5pdGVtLnRleHQubGVuZ3RoID4gNjAwID8gJy4uLicgOiAnJ31gKS5qb2luKCdcXG5cXG4nKX1cblxuUHJvdmlkZSBhIHJlbGV2YW5jZSBzY29yZSBmcm9tIDAtMTAgZm9yIGVhY2ggZG9jdW1lbnQgYmFzZWQgb24gaG93IHdlbGwgaXQgYW5zd2VycyB0aGUgcXVlcnkuYDtcblxuICAgIC8vIEdlbmVyYXRlIHNjb3JlcyB1c2luZyB0aGUgTExNXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZW5lcmF0ZVN0cnVjdHVyZWRSZXNwb25zZShcbiAgICAgIHN5c3RlbVByb21wdCxcbiAgICAgIHVzZXJQcm9tcHQsXG4gICAgICB7IHNjb3JlczogW10gfSxcbiAgICAgIGNvbmZpZy5tb2RlbFxuICAgICk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBzY29yZXMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICBjb25zdCBzY29yZXMgPSByZXNwb25zZT8uc2NvcmVzIHx8IFtdO1xuICAgIFxuICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBCYXRjaCAke2JhdGNoSW5kZXggKyAxfSByZS1yYW5raW5nIHNjb3JlczpgLCBzY29yZXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYXAgc2NvcmVzIHRvIHJlc3VsdHNcbiAgICByZXR1cm4gYmF0Y2gubWFwKChyZXN1bHQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcmVyYW5rU2NvcmUgPSBzY29yZXNbaWR4XSAhPT0gdW5kZWZpbmVkID8gc2NvcmVzW2lkeF0gOiA1OyAvLyBEZWZhdWx0IHRvIG1pZGRsZSBzY29yZSBpZiBtaXNzaW5nXG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBmaW5hbCBzY29yZSAtIHdlaWdodGVkIGNvbWJpbmF0aW9uIG9mIG9yaWdpbmFsIHNjb3JlIGFuZCByZXJhbmsgc2NvcmVcbiAgICAgIC8vIE9yaWdpbmFsIHNjb3JlIGlzIHR5cGljYWxseSAwLTEsIHJlcmFuayBzY29yZSBpcyAwLTEwLCBzbyBub3JtYWxpemVcbiAgICAgIGNvbnN0IHZlY3RvcldlaWdodCA9IDAuMztcbiAgICAgIGNvbnN0IGJtMjVXZWlnaHQgPSAwLjI7XG4gICAgICBjb25zdCByZXJhbmtXZWlnaHQgPSAwLjU7IC8vIEhpZ2hlciB3ZWlnaHQgZm9yIExMTSBqdWRnbWVudFxuICAgICAgXG4gICAgICBjb25zdCBmaW5hbFNjb3JlID0gXG4gICAgICAgICh2ZWN0b3JXZWlnaHQgKiByZXN1bHQudmVjdG9yU2NvcmUpICsgXG4gICAgICAgIChibTI1V2VpZ2h0ICogcmVzdWx0LmJtMjVTY29yZSkgKyBcbiAgICAgICAgKHJlcmFua1dlaWdodCAqIChyZXJhbmtTY29yZSAvIDEwKSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsUmVzdWx0OiByZXN1bHQsXG4gICAgICAgIHJlcmFua1Njb3JlLFxuICAgICAgICBmaW5hbFNjb3JlXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ0Vycm9yKGVycm9yLCBgcHJvY2Vzc1JlUmFua2luZ0JhdGNoXyR7YmF0Y2hJbmRleH1gKTtcbiAgICBcbiAgICAvLyBGYWxsYmFjayAtIHVzZSBvcmlnaW5hbCBzY29yZXNcbiAgICByZXR1cm4gYmF0Y2gubWFwKHJlc3VsdCA9PiAoe1xuICAgICAgb3JpZ2luYWxSZXN1bHQ6IHJlc3VsdCxcbiAgICAgIHJlcmFua1Njb3JlOiByZXN1bHQuY29tYmluZWRTY29yZSAqIDEwLCAvLyBTY2FsZSB1cCB0byAwLTEwIHJhbmdlXG4gICAgICBmaW5hbFNjb3JlOiByZXN1bHQuY29tYmluZWRTY29yZVxuICAgIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VkIHZlcnNpb24gb2YgcmVyYW5raW5nIHRoYXQgcHJvdmlkZXMgZXhwbGFuYXRpb24gZm9yIGVhY2ggc2NvcmVcbiAqIFVzZWZ1bCBmb3IgZGVidWdnaW5nIGFuZCB1bmRlcnN0YW5kaW5nIHdoeSByZXN1bHRzIHdlcmUgcmFua2VkIGFzIHRoZXkgd2VyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVyYW5rUmVzdWx0c1dpdGhFeHBsYW5hdGlvbnMoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIHJlc3VsdHM6IEVuaGFuY2VkUmV0cmlldmFsUmVzdWx0W10sXG4gIG9wdGlvbnM6IFBhcnRpYWw8UmVyYW5raW5nT3B0aW9ucz4gPSB7fVxuKTogUHJvbWlzZTwoUmVyYW5raW5nUmVzdWx0ICYgeyBleHBsYW5hdGlvbjogc3RyaW5nIH0pW10+IHtcbiAgY29uc3QgY29uZmlnID0geyAuLi5ERUZBVUxUX1JFUkFOS0lOR19PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gIFxuICAvLyBQcm9jZXNzIGp1c3QgdGhlIHRvcCByZXN1bHQgZm9yIGRldGFpbGVkIGFuYWx5c2lzXG4gIGNvbnN0IHRvcFJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID4gMCA/IHJlc3VsdHNbMF0gOiBudWxsO1xuICBcbiAgaWYgKCF0b3BSZXN1bHQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSB0ZXh0IG9mIHRoZSB0b3AgcmVzdWx0IGZvciB0aGUgTExNIHRvIGV2YWx1YXRlXG4gICAgY29uc3QgZG9jdW1lbnRUZXh0ID0gdG9wUmVzdWx0Lml0ZW0udGV4dC5zdWJzdHJpbmcoMCwgODAwKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzeXN0ZW0gcHJvbXB0IGZvciBleHBsYWluaW5nIHJlbGV2YW5jZSAod2l0aG91dCByZXF1aXJpbmcgSlNPTilcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhIGRvY3VtZW50IHJlbGV2YW5jZSBqdWRnZS4gXG5Zb3VyIHRhc2sgaXMgdG8gZXZhbHVhdGUgaG93IHJlbGV2YW50IGEgZG9jdW1lbnQgaXMgdG8gYSB1c2VyIHF1ZXJ5IG9uIGEgc2NhbGUgb2YgMC0xMC5cblByb3ZpZGUgeW91ciBldmFsdWF0aW9uIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuU2NvcmU6IFtOVU1CRVJdLzEwXG5FeHBsYW5hdGlvbjogW1lPVVIgRVhQTEFOQVRJT05dXG5cbkJlIHNwZWNpZmljIGFib3V0IHdoeSB0aGUgZG9jdW1lbnQgaXMgb3IgaXNuJ3QgcmVsZXZhbnQgdG8gdGhlIHF1ZXJ5LmA7XG5cbiAgICAvLyBDcmVhdGUgYSBkZXRhaWxlZCB1c2VyIHByb21wdFxuICAgIGNvbnN0IHVzZXJQcm9tcHQgPSBgUXVlcnk6IFwiJHtxdWVyeX1cIlxuXG5Eb2N1bWVudDpcbiR7ZG9jdW1lbnRUZXh0fVxuXG5FdmFsdWF0ZSB0aGUgcmVsZXZhbmNlIG9mIHRoaXMgZG9jdW1lbnQgdG8gdGhlIHF1ZXJ5LiBTY29yZSBpdCBmcm9tIDAtMTAgYW5kIGV4cGxhaW4geW91ciByZWFzb25pbmcgaW4gMS0yIHNlbnRlbmNlcy5gO1xuXG4gICAgLy8gR2VuZXJhdGUgcmVzcG9uc2Ugd2l0aG91dCByZXF1aXJpbmcgSlNPTiBmb3JtYXRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdlbmVyYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICBzeXN0ZW1Qcm9tcHQsXG4gICAgICB1c2VyUHJvbXB0LFxuICAgICAgY29uZmlnLm1vZGVsLFxuICAgICAgZmFsc2UgLy8gRG9uJ3QgdXNlIEpTT04gbW9kZVxuICAgICk7XG4gICAgXG4gICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlIHRvIGV4dHJhY3Qgc2NvcmUgYW5kIGV4cGxhbmF0aW9uXG4gICAgY29uc3Qgc2NvcmVSZWdleCA9IC9TY29yZTpcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKlxcL1xccyoxMC9pO1xuICAgIGNvbnN0IGV4cGxhbmF0aW9uUmVnZXggPSAvRXhwbGFuYXRpb246XFxzKiguKj8pKD86XFxufCQpL2lzO1xuICAgIFxuICAgIGNvbnN0IHNjb3JlTWF0Y2ggPSByZXNwb25zZS5tYXRjaChzY29yZVJlZ2V4KTtcbiAgICBjb25zdCBleHBsYW5hdGlvbk1hdGNoID0gcmVzcG9uc2UubWF0Y2goZXhwbGFuYXRpb25SZWdleCk7XG4gICAgXG4gICAgY29uc3Qgc2NvcmUgPSBzY29yZU1hdGNoID8gcGFyc2VGbG9hdChzY29yZU1hdGNoWzFdKSA6IDU7XG4gICAgY29uc3QgZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbk1hdGNoID8gZXhwbGFuYXRpb25NYXRjaFsxXS50cmltKCkgOiByZXNwb25zZTtcbiAgICBcbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCB3aXRoIGV4cGxhbmF0aW9uXG4gICAgcmV0dXJuIFt7XG4gICAgICBvcmlnaW5hbFJlc3VsdDogdG9wUmVzdWx0LFxuICAgICAgcmVyYW5rU2NvcmU6IHNjb3JlLFxuICAgICAgZmluYWxTY29yZTogKDAuNSAqIChzY29yZSAvIDEwKSkgKyAoMC41ICogdG9wUmVzdWx0LmNvbWJpbmVkU2NvcmUpLCAvLyBXZWlnaHRlZCBjb21iaW5hdGlvblxuICAgICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uIHx8IFwiTm8gZXhwbGFuYXRpb24gcHJvdmlkZWRcIlxuICAgIH1dO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJlcmFua1Jlc3VsdHNXaXRoRXhwbGFuYXRpb25zOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBUcnkgd2l0aCBmYWxsYmFjayBtb2RlbCBpZiBtYWluIG1vZGVsIGZhaWxzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrTW9kZWwgPSBjb25maWcubW9kZWwgPT09ICdncHQtNCcgPyAnZ3B0LTMuNS10dXJibycgOiAnZ3B0LTMuNS10dXJibyc7XG4gICAgICBjb25zdCBmYWxsYmFja1N5c3RlbVByb21wdCA9IGBZb3UgYXJlIGV2YWx1YXRpbmcgZG9jdW1lbnQgcmVsZXZhbmNlLiBSYXRlIHRoZSBkb2N1bWVudCdzIHJlbGV2YW5jZSB0byB0aGUgcXVlcnkgZnJvbSAwLTEwIGFuZCBleHBsYWluIHdoeS5gO1xuICAgICAgY29uc3QgZmFsbGJhY2tVc2VyUHJvbXB0ID0gYFF1ZXJ5OiAke3F1ZXJ5fVxcblxcbkRvY3VtZW50OiAke3RvcFJlc3VsdC5pdGVtLnRleHQuc3Vic3RyaW5nKDAsIDQwMCl9YDtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXNwb25zZSA9IGF3YWl0IGdlbmVyYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICAgIGZhbGxiYWNrU3lzdGVtUHJvbXB0LFxuICAgICAgICBmYWxsYmFja1VzZXJQcm9tcHQsXG4gICAgICAgIGZhbGxiYWNrTW9kZWwsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IGEgc2NvcmUgaWYgcG9zc2libGVcbiAgICAgIGNvbnN0IHNjb3JlTWF0Y2ggPSBmYWxsYmFja1Jlc3BvbnNlLm1hdGNoKC8oXFxkKyg/OlxcLlxcZCspPylcXHMqXFwvXFxzKjEwLyk7XG4gICAgICBjb25zdCBzY29yZSA9IHNjb3JlTWF0Y2ggPyBwYXJzZUZsb2F0KHNjb3JlTWF0Y2hbMV0pIDogNTtcbiAgICAgIFxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIG9yaWdpbmFsUmVzdWx0OiB0b3BSZXN1bHQsXG4gICAgICAgIHJlcmFua1Njb3JlOiBzY29yZSxcbiAgICAgICAgZmluYWxTY29yZTogdG9wUmVzdWx0LmNvbWJpbmVkU2NvcmUsXG4gICAgICAgIGV4cGxhbmF0aW9uOiBmYWxsYmFja1Jlc3BvbnNlXG4gICAgICB9XTtcbiAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICAvLyBGaW5hbCBmYWxsYmFjayB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgb3JpZ2luYWxSZXN1bHQ6IHRvcFJlc3VsdCxcbiAgICAgICAgcmVyYW5rU2NvcmU6IDUsXG4gICAgICAgIGZpbmFsU2NvcmU6IHRvcFJlc3VsdC5jb21iaW5lZFNjb3JlLFxuICAgICAgICBleHBsYW5hdGlvbjogXCJVbmFibGUgdG8gZ2VuZXJhdGUgZXhwbGFuYXRpb24gZHVlIHRvIGFuIGVycm9yLlwiXG4gICAgICB9XTtcbiAgICB9XG4gIH1cbn0gIl0sIm5hbWVzIjpbImdlbmVyYXRlQ2hhdENvbXBsZXRpb24iLCJnZW5lcmF0ZVN0cnVjdHVyZWRSZXNwb25zZSIsImxvZ0Vycm9yIiwiREVGQVVMVF9SRVJBTktJTkdfT1BUSU9OUyIsInJldHVyblRvcE4iLCJtb2RlbCIsInBhcmFsbGVsQmF0Y2hpbmciLCJ0aW1lb3V0TXMiLCJiYXRjaFNpemUiLCJkZWJ1ZyIsInJlcmFua1Jlc3VsdHMiLCJxdWVyeSIsInJlc3VsdHMiLCJvcHRpb25zIiwiY29uZmlnIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImJhdGNoZXMiLCJpIiwicHVzaCIsInNsaWNlIiwicmVyYW5rZWRSZXN1bHRzIiwiYmF0Y2hQcm9taXNlcyIsIm1hcCIsImJhdGNoIiwiaWR4IiwicHJvY2Vzc1JlUmFua2luZ0JhdGNoIiwiYmF0Y2hlc1dpdGhUaW1lb3V0IiwiUHJvbWlzZSIsImFsbCIsInByb21pc2UiLCJyYWNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmbGF0IiwiYmF0Y2hSZXN1bHRzIiwic29ydGVkUmVzdWx0cyIsInNvcnQiLCJhIiwiYiIsImZpbmFsU2NvcmUiLCJmb3JFYWNoIiwicmVzdWx0IiwidG9GaXhlZCIsIm9yaWdpbmFsUmVzdWx0IiwiYm0yNVNjb3JlIiwidmVjdG9yU2NvcmUiLCJyZXJhbmtTY29yZSIsImVycm9yIiwiZmFsbGJhY2tSZXN1bHRzIiwiY29tYmluZWRTY29yZSIsImJhdGNoSW5kZXgiLCJzeXN0ZW1Qcm9tcHQiLCJ1c2VyUHJvbXB0IiwiaXRlbSIsInRleHQiLCJzdWJzdHJpbmciLCJqb2luIiwicmVzcG9uc2UiLCJzY29yZXMiLCJ1bmRlZmluZWQiLCJ2ZWN0b3JXZWlnaHQiLCJibTI1V2VpZ2h0IiwicmVyYW5rV2VpZ2h0IiwicmVyYW5rUmVzdWx0c1dpdGhFeHBsYW5hdGlvbnMiLCJ0b3BSZXN1bHQiLCJkb2N1bWVudFRleHQiLCJzY29yZVJlZ2V4IiwiZXhwbGFuYXRpb25SZWdleCIsInNjb3JlTWF0Y2giLCJtYXRjaCIsImV4cGxhbmF0aW9uTWF0Y2giLCJzY29yZSIsInBhcnNlRmxvYXQiLCJleHBsYW5hdGlvbiIsInRyaW0iLCJmYWxsYmFja01vZGVsIiwiZmFsbGJhY2tTeXN0ZW1Qcm9tcHQiLCJmYWxsYmFja1VzZXJQcm9tcHQiLCJmYWxsYmFja1Jlc3BvbnNlIiwiZmFsbGJhY2tFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/reranking.ts\n");

/***/ }),

/***/ "(api)/./utils/tokenization.ts":
/*!*******************************!*\
  !*** ./utils/tokenization.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   countTermFrequency: () => (/* binding */ countTermFrequency),\n/* harmony export */   getDocumentLength: () => (/* binding */ getDocumentLength),\n/* harmony export */   getTermFrequencies: () => (/* binding */ getTermFrequencies),\n/* harmony export */   getUniqueTerms: () => (/* binding */ getUniqueTerms),\n/* harmony export */   getWordCount: () => (/* binding */ getWordCount),\n/* harmony export */   normalizedTermFrequency: () => (/* binding */ normalizedTermFrequency),\n/* harmony export */   porterStem: () => (/* binding */ porterStem),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n/**\n * Text tokenization utilities for BM25 implementation\n * Handles text normalization, stopword removal, and stemming\n */ // Common English stopwords to filter out\nconst STOP_WORDS = new Set([\n    \"a\",\n    \"an\",\n    \"and\",\n    \"are\",\n    \"as\",\n    \"at\",\n    \"be\",\n    \"but\",\n    \"by\",\n    \"for\",\n    \"if\",\n    \"in\",\n    \"into\",\n    \"is\",\n    \"it\",\n    \"no\",\n    \"not\",\n    \"of\",\n    \"on\",\n    \"or\",\n    \"such\",\n    \"that\",\n    \"the\",\n    \"their\",\n    \"then\",\n    \"there\",\n    \"these\",\n    \"they\",\n    \"this\",\n    \"to\",\n    \"was\",\n    \"will\",\n    \"with\"\n]);\n/**\n * Simple Porter stemming algorithm implementation\n * Reduces words to their root form (e.g., \"running\" -> \"run\")\n */ function porterStem(word) {\n    // This is a simplified stemmer - in production, use the 'natural' NPM package\n    // Convert to lowercase\n    word = word.toLowerCase();\n    // Handle basic plurals and past tense\n    if (word.endsWith(\"ies\") && word.length > 3) {\n        return word.slice(0, -3) + \"y\";\n    }\n    if (word.endsWith(\"es\") && word.length > 3) {\n        return word.slice(0, -2);\n    }\n    if (word.endsWith(\"s\") && !word.endsWith(\"ss\") && word.length > 2) {\n        return word.slice(0, -1);\n    }\n    if (word.endsWith(\"ed\") && word.length > 3) {\n        return word.slice(0, -2);\n    }\n    if (word.endsWith(\"ing\") && word.length > 4) {\n        return word.slice(0, -3);\n    }\n    return word;\n}\n/**\n * Tokenizes a text string into an array of terms\n * Performs basic text normalization:\n * - Convert to lowercase\n * - Remove punctuation\n * - Split on whitespace\n * - Remove stopwords\n * - Remove very short tokens\n * \n * @param text The text to tokenize\n * @returns Array of tokenized terms\n */ function tokenize(text) {\n    if (!text || typeof text !== \"string\") {\n        return [];\n    }\n    // Convert to lowercase\n    const lowercased = text.toLowerCase();\n    // Replace punctuation with spaces\n    const noPunctuation = lowercased.replace(/[^\\w\\s]|_/g, \" \");\n    // Split on whitespace\n    const tokens = noPunctuation.split(/\\s+/).filter((token)=>token.length > 0);\n    // Filter out stopwords and very short tokens\n    return tokens.filter((token)=>token.length > 1 && !STOP_WORDS.has(token));\n}\n/**\n * Count term frequency in a text\n * \n * @param text The text to analyze\n * @returns Object mapping each term to its frequency\n */ function countTermFrequency(text) {\n    const tokens = tokenize(text);\n    const termFrequency = {};\n    for (const token of tokens){\n        termFrequency[token] = (termFrequency[token] || 0) + 1;\n    }\n    return termFrequency;\n}\n/**\n * Get the total number of terms in a document (excluding stopwords)\n * \n * @param text The text to analyze\n * @returns The number of terms in the document\n */ function getDocumentLength(text) {\n    return tokenize(text).length;\n}\n/**\n * Count term frequencies in a text\n * Returns a map of terms to their frequency\n */ function getTermFrequencies(text) {\n    const terms = tokenize(text);\n    const frequencies = {};\n    terms.forEach((term)=>{\n        frequencies[term] = (frequencies[term] || 0) + 1;\n    });\n    return frequencies;\n}\n/**\n * Get unique terms from a text\n * Returns a Set of unique terms\n */ function getUniqueTerms(text) {\n    return new Set(tokenize(text));\n}\n/**\n * Calculate the term frequency normalized by document length\n */ function normalizedTermFrequency(term, text) {\n    const terms = tokenize(text);\n    const termCount = terms.filter((t)=>t === term).length;\n    return termCount / terms.length;\n}\n/**\n * Get word count for a given text\n * Used for document length calculations\n */ function getWordCount(text) {\n    return text.split(/\\s+/).filter((word)=>word.length > 0).length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0NBR0MsR0FDTSxTQUFTRyxlQUFlakIsSUFBWTtJQUN6QyxPQUFPLElBQUlSLElBQUlPLFNBQVNDO0FBQzFCO0FBRUE7O0NBRUMsR0FDTSxTQUFTa0Isd0JBQXdCRixJQUFZLEVBQUVoQixJQUFZO0lBQ2hFLE1BQU1hLFFBQVFkLFNBQVNDO0lBQ3ZCLE1BQU1tQixZQUFZTixNQUFNUCxNQUFNLENBQUNjLENBQUFBLElBQUtBLE1BQU1KLE1BQU1uQixNQUFNO0lBQ3RELE9BQU9zQixZQUFZTixNQUFNaEIsTUFBTTtBQUNqQztBQUVBOzs7Q0FHQyxHQUNNLFNBQVN3QixhQUFhckIsSUFBWTtJQUN2QyxPQUFPQSxLQUFLSyxLQUFLLENBQUMsT0FBT0MsTUFBTSxDQUFDWixDQUFBQSxPQUFRQSxLQUFLRyxNQUFNLEdBQUcsR0FBR0EsTUFBTTtBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWNoYXQtb3BlbmFpLXJhZy8uL3V0aWxzL3Rva2VuaXphdGlvbi50cz9iMWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGV4dCB0b2tlbml6YXRpb24gdXRpbGl0aWVzIGZvciBCTTI1IGltcGxlbWVudGF0aW9uXG4gKiBIYW5kbGVzIHRleHQgbm9ybWFsaXphdGlvbiwgc3RvcHdvcmQgcmVtb3ZhbCwgYW5kIHN0ZW1taW5nXG4gKi9cblxuLy8gQ29tbW9uIEVuZ2xpc2ggc3RvcHdvcmRzIHRvIGZpbHRlciBvdXRcbmNvbnN0IFNUT1BfV09SRFMgPSBuZXcgU2V0KFtcbiAgJ2EnLCAnYW4nLCAnYW5kJywgJ2FyZScsICdhcycsICdhdCcsICdiZScsICdidXQnLCAnYnknLCAnZm9yJywgJ2lmJywgJ2luJywgXG4gICdpbnRvJywgJ2lzJywgJ2l0JywgJ25vJywgJ25vdCcsICdvZicsICdvbicsICdvcicsICdzdWNoJywgJ3RoYXQnLCAndGhlJywgXG4gICd0aGVpcicsICd0aGVuJywgJ3RoZXJlJywgJ3RoZXNlJywgJ3RoZXknLCAndGhpcycsICd0bycsICd3YXMnLCAnd2lsbCcsICd3aXRoJ1xuXSk7XG5cbi8qKlxuICogU2ltcGxlIFBvcnRlciBzdGVtbWluZyBhbGdvcml0aG0gaW1wbGVtZW50YXRpb25cbiAqIFJlZHVjZXMgd29yZHMgdG8gdGhlaXIgcm9vdCBmb3JtIChlLmcuLCBcInJ1bm5pbmdcIiAtPiBcInJ1blwiKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9ydGVyU3RlbSh3b3JkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBzdGVtbWVyIC0gaW4gcHJvZHVjdGlvbiwgdXNlIHRoZSAnbmF0dXJhbCcgTlBNIHBhY2thZ2VcbiAgXG4gIC8vIENvbnZlcnQgdG8gbG93ZXJjYXNlXG4gIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gIFxuICAvLyBIYW5kbGUgYmFzaWMgcGx1cmFscyBhbmQgcGFzdCB0ZW5zZVxuICBpZiAod29yZC5lbmRzV2l0aCgnaWVzJykgJiYgd29yZC5sZW5ndGggPiAzKSB7XG4gICAgcmV0dXJuIHdvcmQuc2xpY2UoMCwgLTMpICsgJ3knO1xuICB9XG4gIGlmICh3b3JkLmVuZHNXaXRoKCdlcycpICYmIHdvcmQubGVuZ3RoID4gMykge1xuICAgIHJldHVybiB3b3JkLnNsaWNlKDAsIC0yKTtcbiAgfVxuICBpZiAod29yZC5lbmRzV2l0aCgncycpICYmICF3b3JkLmVuZHNXaXRoKCdzcycpICYmIHdvcmQubGVuZ3RoID4gMikge1xuICAgIHJldHVybiB3b3JkLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBpZiAod29yZC5lbmRzV2l0aCgnZWQnKSAmJiB3b3JkLmxlbmd0aCA+IDMpIHtcbiAgICByZXR1cm4gd29yZC5zbGljZSgwLCAtMik7XG4gIH1cbiAgaWYgKHdvcmQuZW5kc1dpdGgoJ2luZycpICYmIHdvcmQubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiB3b3JkLnNsaWNlKDAsIC0zKTtcbiAgfVxuICBcbiAgcmV0dXJuIHdvcmQ7XG59XG5cbi8qKlxuICogVG9rZW5pemVzIGEgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0ZXJtc1xuICogUGVyZm9ybXMgYmFzaWMgdGV4dCBub3JtYWxpemF0aW9uOlxuICogLSBDb252ZXJ0IHRvIGxvd2VyY2FzZVxuICogLSBSZW1vdmUgcHVuY3R1YXRpb25cbiAqIC0gU3BsaXQgb24gd2hpdGVzcGFjZVxuICogLSBSZW1vdmUgc3RvcHdvcmRzXG4gKiAtIFJlbW92ZSB2ZXJ5IHNob3J0IHRva2Vuc1xuICogXG4gKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZVxuICogQHJldHVybnMgQXJyYXkgb2YgdG9rZW5pemVkIHRlcm1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZSh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGlmICghdGV4dCB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIC8vIENvbnZlcnQgdG8gbG93ZXJjYXNlXG4gIGNvbnN0IGxvd2VyY2FzZWQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIFxuICAvLyBSZXBsYWNlIHB1bmN0dWF0aW9uIHdpdGggc3BhY2VzXG4gIGNvbnN0IG5vUHVuY3R1YXRpb24gPSBsb3dlcmNhc2VkLnJlcGxhY2UoL1teXFx3XFxzXXxfL2csICcgJyk7XG4gIFxuICAvLyBTcGxpdCBvbiB3aGl0ZXNwYWNlXG4gIGNvbnN0IHRva2VucyA9IG5vUHVuY3R1YXRpb24uc3BsaXQoL1xccysvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubGVuZ3RoID4gMCk7XG4gIFxuICAvLyBGaWx0ZXIgb3V0IHN0b3B3b3JkcyBhbmQgdmVyeSBzaG9ydCB0b2tlbnNcbiAgcmV0dXJuIHRva2Vucy5maWx0ZXIodG9rZW4gPT4gXG4gICAgdG9rZW4ubGVuZ3RoID4gMSAmJiAhU1RPUF9XT1JEUy5oYXModG9rZW4pXG4gICk7XG59XG5cbi8qKlxuICogQ291bnQgdGVybSBmcmVxdWVuY3kgaW4gYSB0ZXh0XG4gKiBcbiAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGFuYWx5emVcbiAqIEByZXR1cm5zIE9iamVjdCBtYXBwaW5nIGVhY2ggdGVybSB0byBpdHMgZnJlcXVlbmN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3VudFRlcm1GcmVxdWVuY3kodGV4dDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHRleHQpO1xuICBjb25zdCB0ZXJtRnJlcXVlbmN5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIFxuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgIHRlcm1GcmVxdWVuY3lbdG9rZW5dID0gKHRlcm1GcmVxdWVuY3lbdG9rZW5dIHx8IDApICsgMTtcbiAgfVxuICBcbiAgcmV0dXJuIHRlcm1GcmVxdWVuY3k7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgdGVybXMgaW4gYSBkb2N1bWVudCAoZXhjbHVkaW5nIHN0b3B3b3JkcylcbiAqIFxuICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gYW5hbHl6ZVxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiB0ZXJtcyBpbiB0aGUgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50TGVuZ3RoKHRleHQ6IHN0cmluZyk6IG51bWJlciB7XG4gIHJldHVybiB0b2tlbml6ZSh0ZXh0KS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ291bnQgdGVybSBmcmVxdWVuY2llcyBpbiBhIHRleHRcbiAqIFJldHVybnMgYSBtYXAgb2YgdGVybXMgdG8gdGhlaXIgZnJlcXVlbmN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXJtRnJlcXVlbmNpZXModGV4dDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG4gIGNvbnN0IHRlcm1zID0gdG9rZW5pemUodGV4dCk7XG4gIGNvbnN0IGZyZXF1ZW5jaWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIFxuICB0ZXJtcy5mb3JFYWNoKHRlcm0gPT4ge1xuICAgIGZyZXF1ZW5jaWVzW3Rlcm1dID0gKGZyZXF1ZW5jaWVzW3Rlcm1dIHx8IDApICsgMTtcbiAgfSk7XG4gIFxuICByZXR1cm4gZnJlcXVlbmNpZXM7XG59XG5cbi8qKlxuICogR2V0IHVuaXF1ZSB0ZXJtcyBmcm9tIGEgdGV4dFxuICogUmV0dXJucyBhIFNldCBvZiB1bmlxdWUgdGVybXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZVRlcm1zKHRleHQ6IHN0cmluZyk6IFNldDxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBTZXQodG9rZW5pemUodGV4dCkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgdGVybSBmcmVxdWVuY3kgbm9ybWFsaXplZCBieSBkb2N1bWVudCBsZW5ndGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZWRUZXJtRnJlcXVlbmN5KHRlcm06IHN0cmluZywgdGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgdGVybXMgPSB0b2tlbml6ZSh0ZXh0KTtcbiAgY29uc3QgdGVybUNvdW50ID0gdGVybXMuZmlsdGVyKHQgPT4gdCA9PT0gdGVybSkubGVuZ3RoO1xuICByZXR1cm4gdGVybUNvdW50IC8gdGVybXMubGVuZ3RoO1xufVxuXG4vKipcbiAqIEdldCB3b3JkIGNvdW50IGZvciBhIGdpdmVuIHRleHRcbiAqIFVzZWQgZm9yIGRvY3VtZW50IGxlbmd0aCBjYWxjdWxhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRDb3VudCh0ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gdGV4dC5zcGxpdCgvXFxzKy8pLmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gMCkubGVuZ3RoO1xufSAiXSwibmFtZXMiOlsiU1RPUF9XT1JEUyIsIlNldCIsInBvcnRlclN0ZW0iLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwidG9rZW5pemUiLCJ0ZXh0IiwibG93ZXJjYXNlZCIsIm5vUHVuY3R1YXRpb24iLCJyZXBsYWNlIiwidG9rZW5zIiwic3BsaXQiLCJmaWx0ZXIiLCJ0b2tlbiIsImhhcyIsImNvdW50VGVybUZyZXF1ZW5jeSIsInRlcm1GcmVxdWVuY3kiLCJnZXREb2N1bWVudExlbmd0aCIsImdldFRlcm1GcmVxdWVuY2llcyIsInRlcm1zIiwiZnJlcXVlbmNpZXMiLCJmb3JFYWNoIiwidGVybSIsImdldFVuaXF1ZVRlcm1zIiwibm9ybWFsaXplZFRlcm1GcmVxdWVuY3kiLCJ0ZXJtQ291bnQiLCJ0IiwiZ2V0V29yZENvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/tokenization.ts\n");

/***/ }),

/***/ "(api)/./utils/vectorStore.ts":
/*!******************************!*\
  !*** ./utils/vectorStore.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToVectorStore: () => (/* binding */ addToVectorStore),\n/* harmony export */   clearVectorStore: () => (/* binding */ clearVectorStore),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   getAllVectorStoreItems: () => (/* binding */ getAllVectorStoreItems),\n/* harmony export */   getSimilarItems: () => (/* binding */ getSimilarItems),\n/* harmony export */   getVectorStoreSize: () => (/* binding */ getVectorStoreSize),\n/* harmony export */   vectorStore: () => (/* binding */ vectorStore)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// Constants for batch processing\nconst VECTOR_STORE_DIR = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\", \"vector_batches\");\nconst BATCH_INDEX_FILE = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\", \"batch_index.json\");\nconst MAX_BATCH_SIZE = 1000; // Maximum items per batch file\n// In-memory vector store (now loads from multiple files)\nlet vectorStore = [];\nlet activeBatches = [];\n// Initialize vector store directory\nfunction initVectorStore() {\n    // Ensure data directory exists\n    const dataDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\");\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(dataDir)) {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(dataDir, {\n            recursive: true\n        });\n    }\n    // Ensure vector_batches directory exists\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(VECTOR_STORE_DIR)) {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(VECTOR_STORE_DIR, {\n            recursive: true\n        });\n    }\n    // Create batch index if it doesn't exist\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(BATCH_INDEX_FILE)) {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(BATCH_INDEX_FILE, JSON.stringify({\n            activeBatches: [],\n            lastUpdated: Date.now()\n        }));\n    }\n}\n// Load vector store index and all active batches\nfunction loadVectorStore() {\n    try {\n        initVectorStore();\n        console.log(\"Loading vector store batches...\");\n        // Read the batch index\n        const indexData = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(BATCH_INDEX_FILE, \"utf-8\"));\n        activeBatches = indexData.activeBatches || [];\n        // Load each active batch\n        vectorStore = [];\n        let totalLoaded = 0;\n        for (const batchId of activeBatches){\n            const batchFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(VECTOR_STORE_DIR, `batch_${batchId}.json`);\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(batchFile)) {\n                try {\n                    const batchData = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(batchFile, \"utf-8\"));\n                    vectorStore = [\n                        ...vectorStore,\n                        ...batchData\n                    ];\n                    totalLoaded += batchData.length;\n                    console.log(`Loaded batch ${batchId} with ${batchData.length} items`);\n                } catch (error) {\n                    console.error(`Error loading batch ${batchId}:`, error);\n                }\n            }\n        }\n        // If no batches were loaded, try loading from single vectorStore.json file as fallback\n        if (totalLoaded === 0) {\n            const singleStoreFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\", \"vectorStore.json\");\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(singleStoreFile)) {\n                try {\n                    const fileData = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(singleStoreFile, \"utf8\");\n                    const parsedData = JSON.parse(fileData);\n                    // Handle both formats: array of items or {items: [...]} structure\n                    if (Array.isArray(parsedData)) {\n                        vectorStore = parsedData;\n                        totalLoaded = parsedData.length;\n                    } else if (parsedData.items && Array.isArray(parsedData.items)) {\n                        vectorStore = parsedData.items;\n                        totalLoaded = parsedData.items.length;\n                    }\n                    console.log(`Loaded ${totalLoaded} items from single vectorStore.json file`);\n                } catch (error) {\n                    console.error(\"Error loading from single vectorStore.json file:\", error);\n                }\n            }\n        }\n        console.log(`Loaded ${totalLoaded} total items from ${activeBatches.length} batches and fallback sources`);\n    } catch (error) {\n        console.error(\"Error loading vector store:\", error);\n        vectorStore = [];\n        activeBatches = [];\n    }\n}\n// Create a new batch and add it to the index\nfunction createNewBatch() {\n    const batchId = Date.now().toString();\n    activeBatches.push(batchId);\n    // Update the batch index\n    fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(BATCH_INDEX_FILE, JSON.stringify({\n        activeBatches,\n        lastUpdated: Date.now()\n    }, null, 2));\n    console.log(`Created new batch: ${batchId}`);\n    return batchId;\n}\n// Save a specific batch to disk\nfunction saveBatch(batchId, items) {\n    const batchFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(VECTOR_STORE_DIR, `batch_${batchId}.json`);\n    fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(batchFile, JSON.stringify(items, null, 2));\n    console.log(`Saved batch ${batchId} with ${items.length} items`);\n}\n// Save the current state of all batches\nfunction saveVectorStore() {\n    try {\n        if (activeBatches.length === 0 && vectorStore.length > 0) {\n            // First-time save - create initial batch\n            const initialBatchId = createNewBatch();\n            // Add batch metadata to all items\n            vectorStore = vectorStore.map((item)=>({\n                    ...item,\n                    metadata: {\n                        ...item.metadata,\n                        batch: initialBatchId\n                    }\n                }));\n            // Save as first batch\n            saveBatch(initialBatchId, vectorStore);\n        } else {\n            // Group items by batch\n            const batchMap = {};\n            // Find items without batch ID (newly added)\n            const unbatchedItems = vectorStore.filter((item)=>!item.metadata?.batch);\n            if (unbatchedItems.length > 0) {\n                // Get current batch or create new one\n                let currentBatchId = activeBatches[activeBatches.length - 1];\n                if (currentBatchId) {\n                    // Count items in the current batch\n                    const currentBatchCount = vectorStore.filter((item)=>item.metadata?.batch === currentBatchId).length;\n                    // Create a new batch if current one is too full\n                    if (currentBatchCount + unbatchedItems.length > MAX_BATCH_SIZE) {\n                        currentBatchId = createNewBatch();\n                    }\n                } else {\n                    // No batches exist yet, create the first one\n                    currentBatchId = createNewBatch();\n                }\n                // Assign batch ID to unbatched items\n                unbatchedItems.forEach((item)=>{\n                    if (!item.metadata) item.metadata = {};\n                    item.metadata.batch = currentBatchId;\n                });\n            }\n            // Group all items by batch\n            vectorStore.forEach((item)=>{\n                const batchId = item.metadata?.batch;\n                if (batchId) {\n                    if (!batchMap[batchId]) batchMap[batchId] = [];\n                    batchMap[batchId].push(item);\n                }\n            });\n            // Save each batch\n            Object.entries(batchMap).forEach(([batchId, items])=>{\n                if (items.length > 0) {\n                    saveBatch(batchId, items);\n                }\n            });\n        }\n        // Update index file\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(BATCH_INDEX_FILE, JSON.stringify({\n            activeBatches,\n            lastUpdated: Date.now()\n        }, null, 2));\n        // Also save to the single vectorStore.json file as a backup\n        const singleStoreFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"data\", \"vectorStore.json\");\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(singleStoreFile, JSON.stringify({\n            items: vectorStore,\n            lastUpdated: Date.now()\n        }, null, 2));\n        console.log(`Saved vector store with ${activeBatches.length} batches and ${vectorStore.length} total items`);\n    } catch (error) {\n        console.error(\"Error saving vector store:\", error);\n    }\n}\n/**\n * Calculate cosine similarity between two vectors\n * @param vecA First vector\n * @param vecB Second vector\n * @returns Cosine similarity score (0-1)\n */ function cosineSimilarity(vecA, vecB) {\n    const dot = vecA.reduce((sum, a, i)=>sum + a * vecB[i], 0);\n    const magA = Math.sqrt(vecA.reduce((sum, a)=>sum + a * a, 0));\n    const magB = Math.sqrt(vecB.reduce((sum, b)=>sum + b * b, 0));\n    return dot / (magA * magB);\n}\n/**\n * Add an item or multiple items to the vector store\n * @param items Single item or array of items to add\n */ function addToVectorStore(items) {\n    // Convert single item to array\n    const itemsArray = Array.isArray(items) ? items : [\n        items\n    ];\n    if (itemsArray.length === 0) return;\n    // Add to in-memory store\n    vectorStore = [\n        ...vectorStore,\n        ...itemsArray\n    ];\n    // Save changes to disk\n    saveVectorStore();\n}\n// Enhanced version of getSimilarItems with stronger emphasis on structured data\nfunction getSimilarItems(queryEmbedding, limit = 5, queryText, priorityInfoType) {\n    // Check if the vector store is initialized\n    if (!vectorStore || vectorStore.length === 0) {\n        loadVectorStore();\n    }\n    if (!vectorStore || vectorStore.length === 0) {\n        console.warn(\"Vector store is empty. No results to return.\");\n        return [];\n    }\n    console.log(\"Searching for similar items...\");\n    // Look for certain types of inquiries to boost specific content\n    let shouldBoostStructuredInfo = false;\n    let shouldBoostCompanyValues = false;\n    let shouldBoostInvestors = false;\n    let shouldBoostLeadership = false;\n    let shouldBoostPricing = false;\n    let shouldBoostProductFeatures = false;\n    let shouldBoostSalesInfo = false;\n    if (queryText) {\n        const queryLower = queryText.toLowerCase();\n        // Check for company values inquiries\n        shouldBoostCompanyValues = queryLower.includes(\"value\") || queryLower.includes(\"culture\") || queryLower.includes(\"principle\") || queryLower.includes(\"mission\") || queryLower.includes(\"vision\");\n        // Check for investor inquiries\n        shouldBoostInvestors = queryLower.includes(\"investor\") || queryLower.includes(\"funding\") || queryLower.includes(\"backed by\") || queryLower.includes(\"invested\");\n        // Check for leadership inquiries\n        shouldBoostLeadership = queryLower.includes(\"founder\") || queryLower.includes(\"ceo\") || queryLower.includes(\"leader\") || queryLower.includes(\"executive\");\n        // Check for pricing inquiries\n        shouldBoostPricing = queryLower.includes(\"pricing\") || queryLower.includes(\"price\") || queryLower.includes(\"cost\") || queryLower.includes(\"subscription\") || queryLower.includes(\"plan\") || queryLower.includes(\"tier\");\n        // Check for product feature inquiries  \n        shouldBoostProductFeatures = queryLower.includes(\"feature\") || queryLower.includes(\"function\") || queryLower.includes(\"capability\") || queryLower.includes(\"how does it work\") || queryLower.includes(\"what does it do\");\n        // Check for sales information inquiries\n        shouldBoostSalesInfo = queryLower.includes(\"sell\") || queryLower.includes(\"pitch\") || queryLower.includes(\"competitor\") || queryLower.includes(\"comparison\");\n        // Set the overall structured info flag if any specific type should be boosted\n        shouldBoostStructuredInfo = shouldBoostCompanyValues || shouldBoostInvestors || shouldBoostLeadership || shouldBoostPricing || shouldBoostProductFeatures || shouldBoostSalesInfo;\n    }\n    // Calculate similarity scores\n    const itemsWithScores = vectorStore.map((item)=>{\n        // Compute base score using cosine similarity\n        let score = cosineSimilarity(queryEmbedding, item.embedding);\n        // Apply boosting for structured information when relevant\n        if (shouldBoostStructuredInfo && item.metadata?.isStructured) {\n            // Specific boosts for different types of structured information\n            const infoType = item.metadata?.infoType;\n            // Handle the case when a specific info type is prioritized\n            if (priorityInfoType && infoType === priorityInfoType) {\n                score *= 1.5; // Strong boost for exact info type match\n            } else if (shouldBoostCompanyValues && infoType === \"company_values\") {\n                score *= 1.3;\n            } else if (shouldBoostInvestors && infoType === \"investors\") {\n                score *= 1.3;\n            } else if (shouldBoostLeadership && infoType === \"leadership\") {\n                score *= 1.3;\n            } else if (shouldBoostPricing && infoType === \"pricing\") {\n                score *= 1.3;\n            } else if (shouldBoostProductFeatures && infoType === \"product_features\") {\n                score *= 1.3;\n            } else if (shouldBoostSalesInfo && infoType === \"sales_info\") {\n                score *= 1.3;\n            } else if (item.metadata?.isStructured) {\n                // General boost for any structured info\n                score *= 1.1;\n            }\n        }\n        return {\n            ...item,\n            score\n        };\n    });\n    // Sort by similarity score\n    const sortedResults = itemsWithScores.sort((a, b)=>b.score - a.score);\n    // Get the top results, but ensure priority structured info is included if relevant\n    let result = sortedResults.slice(0, limit);\n    // Check if we need to guarantee inclusion of specific structured info\n    if (shouldBoostStructuredInfo) {\n        // Check if we already have a relevant piece of structured information\n        let hasRelevantStructuredInfo = false;\n        // Use the priorityInfoType if available, otherwise check all relevant types\n        if (priorityInfoType) {\n            hasRelevantStructuredInfo = result.some((item)=>item.metadata?.infoType === priorityInfoType);\n        } else {\n            hasRelevantStructuredInfo = result.some((item)=>{\n                const infoType = item.metadata?.infoType;\n                return shouldBoostCompanyValues && infoType === \"company_values\" || shouldBoostInvestors && infoType === \"investors\" || shouldBoostLeadership && infoType === \"leadership\" || shouldBoostPricing && infoType === \"pricing\" || shouldBoostProductFeatures && infoType === \"product_features\" || shouldBoostSalesInfo && infoType === \"sales_info\";\n            });\n        }\n        // If we don't have the relevant info in our top results, find and include it\n        if (!hasRelevantStructuredInfo) {\n            let structuredInfoToInclude;\n            if (priorityInfoType) {\n                // Look for the specific priority info type\n                structuredInfoToInclude = sortedResults.find((item)=>item.metadata?.infoType === priorityInfoType && !result.includes(item));\n            } else {\n                // Look for any relevant structured info type\n                structuredInfoToInclude = sortedResults.find((item)=>{\n                    const infoType = item.metadata?.infoType;\n                    return (shouldBoostCompanyValues && infoType === \"company_values\" || shouldBoostInvestors && infoType === \"investors\" || shouldBoostLeadership && infoType === \"leadership\" || shouldBoostPricing && infoType === \"pricing\" || shouldBoostProductFeatures && infoType === \"product_features\" || shouldBoostSalesInfo && infoType === \"sales_info\") && !result.includes(item);\n                });\n            }\n            // If we found a relevant item, add it and remove the lowest scored item\n            if (structuredInfoToInclude) {\n                result.pop(); // Remove the lowest scored item\n                result.push(structuredInfoToInclude);\n                // Re-sort to maintain score order\n                result = result.sort((a, b)=>b.score - a.score);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Clear the vector store\n */ function clearVectorStore() {\n    // Clear in-memory data\n    vectorStore = [];\n    // Delete all batch files\n    try {\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(VECTOR_STORE_DIR)) {\n            const files = fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(VECTOR_STORE_DIR);\n            files.forEach((file)=>{\n                if (file.startsWith(\"batch_\")) {\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(VECTOR_STORE_DIR, file));\n                }\n            });\n        }\n        // Reset batch index\n        activeBatches = [];\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(BATCH_INDEX_FILE, JSON.stringify({\n            activeBatches: [],\n            lastUpdated: Date.now()\n        }, null, 2));\n        console.log(\"Vector store cleared successfully\");\n    } catch (error) {\n        console.error(\"Error clearing vector store:\", error);\n    }\n}\n/**\n * Get the current size of the vector store\n * @returns Number of items in the vector store\n */ function getVectorStoreSize() {\n    return vectorStore.length;\n}\n// Initialize vector store on module load\ntry {\n    loadVectorStore();\n} catch (error) {\n    console.error(\"Failed to initialize vector store:\", error);\n    vectorStore = [];\n    activeBatches = [];\n}\n/**\n * Get all items from the vector store\n * @returns Array of all vector store items\n */ function getAllVectorStoreItems() {\n    return [\n        ...vectorStore\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxDQUFDL0IsR0FBR00sSUFBTUEsRUFBRW9CLEtBQUssR0FBRzFCLEVBQUUwQixLQUFLO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBLE9BQU9NO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNPO0lBQ2QsdUJBQXVCO0lBQ3ZCOUYsY0FBYyxFQUFFO0lBRWhCLHlCQUF5QjtJQUN6QixJQUFJO1FBQ0YsSUFBSVIsb0RBQWEsQ0FBQ0UsbUJBQW1CO1lBQ25DLE1BQU1xRyxRQUFRdkcscURBQWMsQ0FBQ0U7WUFDN0JxRyxNQUFNakQsT0FBTyxDQUFDbUQsQ0FBQUE7Z0JBQ1osSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFdBQVc7b0JBQzdCMUcsb0RBQWEsQ0FBQ0MsZ0RBQVMsQ0FBQ0Msa0JBQWtCdUc7Z0JBQzVDO1lBQ0Y7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQmhHLGdCQUFnQixFQUFFO1FBQ2xCVCx1REFBZ0IsQ0FBQ00sa0JBQWtCVSxLQUFLQyxTQUFTLENBQUM7WUFDaERSLGVBQWUsRUFBRTtZQUNqQlMsYUFBYUMsS0FBS0MsR0FBRztRQUN2QixHQUFHLE1BQU07UUFFVEUsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPUyxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyxnQ0FBZ0NBO0lBQ2hEO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTNEU7SUFDZCxPQUFPcEcsWUFBWXVCLE1BQU07QUFDM0I7QUFFQSx5Q0FBeUM7QUFDekMsSUFBSTtJQUNGVjtBQUNGLEVBQUUsT0FBT1csT0FBTztJQUNkVixRQUFRVSxLQUFLLENBQUMsc0NBQXNDQTtJQUNwRHhCLGNBQWMsRUFBRTtJQUNoQkMsZ0JBQWdCLEVBQUU7QUFDcEI7QUFFQTs7O0NBR0MsR0FDTSxTQUFTb0c7SUFDZCxPQUFPO1dBQUlyRztLQUFZO0FBQ3pCO0FBRXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtY2hhdC1vcGVuYWktcmFnLy4vdXRpbHMvdmVjdG9yU3RvcmUudHM/NTU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlSXRlbSB7XG4gIGVtYmVkZGluZzogbnVtYmVyW107XG4gIHRleHQ6IHN0cmluZztcbiAgbWV0YWRhdGE/OiB7XG4gICAgc291cmNlPzogc3RyaW5nO1xuICAgIHBhZ2U/OiBudW1iZXI7XG4gICAgYmF0Y2g/OiBzdHJpbmc7XG4gICAgaXNTdHJ1Y3R1cmVkPzogYm9vbGVhbjtcbiAgICBpbmZvVHlwZT86IHN0cmluZztcbiAgICBwcmlvcml0eT86IHN0cmluZztcbiAgfTtcbn1cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vLyBDb25zdGFudHMgZm9yIGJhdGNoIHByb2Nlc3NpbmdcbmNvbnN0IFZFQ1RPUl9TVE9SRV9ESVIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2RhdGEnLCAndmVjdG9yX2JhdGNoZXMnKTtcbmNvbnN0IEJBVENIX0lOREVYX0ZJTEUgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2RhdGEnLCAnYmF0Y2hfaW5kZXguanNvbicpO1xuY29uc3QgTUFYX0JBVENIX1NJWkUgPSAxMDAwOyAvLyBNYXhpbXVtIGl0ZW1zIHBlciBiYXRjaCBmaWxlXG5cbi8vIEluLW1lbW9yeSB2ZWN0b3Igc3RvcmUgKG5vdyBsb2FkcyBmcm9tIG11bHRpcGxlIGZpbGVzKVxubGV0IHZlY3RvclN0b3JlOiBWZWN0b3JTdG9yZUl0ZW1bXSA9IFtdO1xubGV0IGFjdGl2ZUJhdGNoZXM6IHN0cmluZ1tdID0gW107XG5cbi8vIEluaXRpYWxpemUgdmVjdG9yIHN0b3JlIGRpcmVjdG9yeVxuZnVuY3Rpb24gaW5pdFZlY3RvclN0b3JlKCkge1xuICAvLyBFbnN1cmUgZGF0YSBkaXJlY3RvcnkgZXhpc3RzXG4gIGNvbnN0IGRhdGFEaXIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2RhdGEnKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRhdGFEaXIpKSB7XG4gICAgZnMubWtkaXJTeW5jKGRhdGFEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICB9XG4gIFxuICAvLyBFbnN1cmUgdmVjdG9yX2JhdGNoZXMgZGlyZWN0b3J5IGV4aXN0c1xuICBpZiAoIWZzLmV4aXN0c1N5bmMoVkVDVE9SX1NUT1JFX0RJUikpIHtcbiAgICBmcy5ta2RpclN5bmMoVkVDVE9SX1NUT1JFX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIH1cbiAgXG4gIC8vIENyZWF0ZSBiYXRjaCBpbmRleCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gIGlmICghZnMuZXhpc3RzU3luYyhCQVRDSF9JTkRFWF9GSUxFKSkge1xuICAgIGZzLndyaXRlRmlsZVN5bmMoQkFUQ0hfSU5ERVhfRklMRSwgSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgIGFjdGl2ZUJhdGNoZXM6IFtdLFxuICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCkgXG4gICAgfSkpO1xuICB9XG59XG5cbi8vIExvYWQgdmVjdG9yIHN0b3JlIGluZGV4IGFuZCBhbGwgYWN0aXZlIGJhdGNoZXNcbmZ1bmN0aW9uIGxvYWRWZWN0b3JTdG9yZSgpIHtcbiAgdHJ5IHtcbiAgICBpbml0VmVjdG9yU3RvcmUoKTtcbiAgICBjb25zb2xlLmxvZygnTG9hZGluZyB2ZWN0b3Igc3RvcmUgYmF0Y2hlcy4uLicpO1xuICAgIFxuICAgIC8vIFJlYWQgdGhlIGJhdGNoIGluZGV4XG4gICAgY29uc3QgaW5kZXhEYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoQkFUQ0hfSU5ERVhfRklMRSwgJ3V0Zi04JykpO1xuICAgIGFjdGl2ZUJhdGNoZXMgPSBpbmRleERhdGEuYWN0aXZlQmF0Y2hlcyB8fCBbXTtcbiAgICBcbiAgICAvLyBMb2FkIGVhY2ggYWN0aXZlIGJhdGNoXG4gICAgdmVjdG9yU3RvcmUgPSBbXTtcbiAgICBsZXQgdG90YWxMb2FkZWQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgYmF0Y2hJZCBvZiBhY3RpdmVCYXRjaGVzKSB7XG4gICAgICBjb25zdCBiYXRjaEZpbGUgPSBwYXRoLmpvaW4oVkVDVE9SX1NUT1JFX0RJUiwgYGJhdGNoXyR7YmF0Y2hJZH0uanNvbmApO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoYmF0Y2hGaWxlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGJhdGNoRGF0YSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGJhdGNoRmlsZSwgJ3V0Zi04JykpO1xuICAgICAgICAgIHZlY3RvclN0b3JlID0gWy4uLnZlY3RvclN0b3JlLCAuLi5iYXRjaERhdGFdO1xuICAgICAgICAgIHRvdGFsTG9hZGVkICs9IGJhdGNoRGF0YS5sZW5ndGg7XG4gICAgICAgICAgY29uc29sZS5sb2coYExvYWRlZCBiYXRjaCAke2JhdGNoSWR9IHdpdGggJHtiYXRjaERhdGEubGVuZ3RofSBpdGVtc2ApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgYmF0Y2ggJHtiYXRjaElkfTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gYmF0Y2hlcyB3ZXJlIGxvYWRlZCwgdHJ5IGxvYWRpbmcgZnJvbSBzaW5nbGUgdmVjdG9yU3RvcmUuanNvbiBmaWxlIGFzIGZhbGxiYWNrXG4gICAgaWYgKHRvdGFsTG9hZGVkID09PSAwKSB7XG4gICAgICBjb25zdCBzaW5nbGVTdG9yZUZpbGUgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2RhdGEnLCAndmVjdG9yU3RvcmUuanNvbicpO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoc2luZ2xlU3RvcmVGaWxlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGZpbGVEYXRhID0gZnMucmVhZEZpbGVTeW5jKHNpbmdsZVN0b3JlRmlsZSwgJ3V0ZjgnKTtcbiAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShmaWxlRGF0YSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIGJvdGggZm9ybWF0czogYXJyYXkgb2YgaXRlbXMgb3Ige2l0ZW1zOiBbLi4uXX0gc3RydWN0dXJlXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YSkpIHtcbiAgICAgICAgICAgIHZlY3RvclN0b3JlID0gcGFyc2VkRGF0YTtcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkID0gcGFyc2VkRGF0YS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWREYXRhLml0ZW1zICYmIEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YS5pdGVtcykpIHtcbiAgICAgICAgICAgIHZlY3RvclN0b3JlID0gcGFyc2VkRGF0YS5pdGVtcztcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkID0gcGFyc2VkRGF0YS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHt0b3RhbExvYWRlZH0gaXRlbXMgZnJvbSBzaW5nbGUgdmVjdG9yU3RvcmUuanNvbiBmaWxlYCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBmcm9tIHNpbmdsZSB2ZWN0b3JTdG9yZS5qc29uIGZpbGU6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHt0b3RhbExvYWRlZH0gdG90YWwgaXRlbXMgZnJvbSAke2FjdGl2ZUJhdGNoZXMubGVuZ3RofSBiYXRjaGVzIGFuZCBmYWxsYmFjayBzb3VyY2VzYCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB2ZWN0b3Igc3RvcmU6JywgZXJyb3IpO1xuICAgIHZlY3RvclN0b3JlID0gW107XG4gICAgYWN0aXZlQmF0Y2hlcyA9IFtdO1xuICB9XG59XG5cbi8vIENyZWF0ZSBhIG5ldyBiYXRjaCBhbmQgYWRkIGl0IHRvIHRoZSBpbmRleFxuZnVuY3Rpb24gY3JlYXRlTmV3QmF0Y2goKTogc3RyaW5nIHtcbiAgY29uc3QgYmF0Y2hJZCA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcbiAgYWN0aXZlQmF0Y2hlcy5wdXNoKGJhdGNoSWQpO1xuICBcbiAgLy8gVXBkYXRlIHRoZSBiYXRjaCBpbmRleFxuICBmcy53cml0ZUZpbGVTeW5jKEJBVENIX0lOREVYX0ZJTEUsIEpTT04uc3RyaW5naWZ5KHtcbiAgICBhY3RpdmVCYXRjaGVzLFxuICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gIH0sIG51bGwsIDIpKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBDcmVhdGVkIG5ldyBiYXRjaDogJHtiYXRjaElkfWApO1xuICByZXR1cm4gYmF0Y2hJZDtcbn1cblxuLy8gU2F2ZSBhIHNwZWNpZmljIGJhdGNoIHRvIGRpc2tcbmZ1bmN0aW9uIHNhdmVCYXRjaChiYXRjaElkOiBzdHJpbmcsIGl0ZW1zOiBWZWN0b3JTdG9yZUl0ZW1bXSkge1xuICBjb25zdCBiYXRjaEZpbGUgPSBwYXRoLmpvaW4oVkVDVE9SX1NUT1JFX0RJUiwgYGJhdGNoXyR7YmF0Y2hJZH0uanNvbmApO1xuICBmcy53cml0ZUZpbGVTeW5jKGJhdGNoRmlsZSwgSlNPTi5zdHJpbmdpZnkoaXRlbXMsIG51bGwsIDIpKTtcbiAgY29uc29sZS5sb2coYFNhdmVkIGJhdGNoICR7YmF0Y2hJZH0gd2l0aCAke2l0ZW1zLmxlbmd0aH0gaXRlbXNgKTtcbn1cblxuLy8gU2F2ZSB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbGwgYmF0Y2hlc1xuZnVuY3Rpb24gc2F2ZVZlY3RvclN0b3JlKCkge1xuICB0cnkge1xuICAgIGlmIChhY3RpdmVCYXRjaGVzLmxlbmd0aCA9PT0gMCAmJiB2ZWN0b3JTdG9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBGaXJzdC10aW1lIHNhdmUgLSBjcmVhdGUgaW5pdGlhbCBiYXRjaFxuICAgICAgY29uc3QgaW5pdGlhbEJhdGNoSWQgPSBjcmVhdGVOZXdCYXRjaCgpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYmF0Y2ggbWV0YWRhdGEgdG8gYWxsIGl0ZW1zXG4gICAgICB2ZWN0b3JTdG9yZSA9IHZlY3RvclN0b3JlLm1hcChpdGVtID0+ICh7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgLi4uaXRlbS5tZXRhZGF0YSxcbiAgICAgICAgICBiYXRjaDogaW5pdGlhbEJhdGNoSWRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBTYXZlIGFzIGZpcnN0IGJhdGNoXG4gICAgICBzYXZlQmF0Y2goaW5pdGlhbEJhdGNoSWQsIHZlY3RvclN0b3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR3JvdXAgaXRlbXMgYnkgYmF0Y2hcbiAgICAgIGNvbnN0IGJhdGNoTWFwOiBSZWNvcmQ8c3RyaW5nLCBWZWN0b3JTdG9yZUl0ZW1bXT4gPSB7fTtcbiAgICAgIFxuICAgICAgLy8gRmluZCBpdGVtcyB3aXRob3V0IGJhdGNoIElEIChuZXdseSBhZGRlZClcbiAgICAgIGNvbnN0IHVuYmF0Y2hlZEl0ZW1zID0gdmVjdG9yU3RvcmUuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0ubWV0YWRhdGE/LmJhdGNoKTtcbiAgICAgIFxuICAgICAgaWYgKHVuYmF0Y2hlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgYmF0Y2ggb3IgY3JlYXRlIG5ldyBvbmVcbiAgICAgICAgbGV0IGN1cnJlbnRCYXRjaElkID0gYWN0aXZlQmF0Y2hlc1thY3RpdmVCYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaElkKSB7XG4gICAgICAgICAgLy8gQ291bnQgaXRlbXMgaW4gdGhlIGN1cnJlbnQgYmF0Y2hcbiAgICAgICAgICBjb25zdCBjdXJyZW50QmF0Y2hDb3VudCA9IHZlY3RvclN0b3JlLmZpbHRlcihcbiAgICAgICAgICAgIGl0ZW0gPT4gaXRlbS5tZXRhZGF0YT8uYmF0Y2ggPT09IGN1cnJlbnRCYXRjaElkXG4gICAgICAgICAgKS5sZW5ndGg7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGJhdGNoIGlmIGN1cnJlbnQgb25lIGlzIHRvbyBmdWxsXG4gICAgICAgICAgaWYgKGN1cnJlbnRCYXRjaENvdW50ICsgdW5iYXRjaGVkSXRlbXMubGVuZ3RoID4gTUFYX0JBVENIX1NJWkUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRCYXRjaElkID0gY3JlYXRlTmV3QmF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYmF0Y2hlcyBleGlzdCB5ZXQsIGNyZWF0ZSB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgY3VycmVudEJhdGNoSWQgPSBjcmVhdGVOZXdCYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBc3NpZ24gYmF0Y2ggSUQgdG8gdW5iYXRjaGVkIGl0ZW1zXG4gICAgICAgIHVuYmF0Y2hlZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKCFpdGVtLm1ldGFkYXRhKSBpdGVtLm1ldGFkYXRhID0ge307XG4gICAgICAgICAgaXRlbS5tZXRhZGF0YS5iYXRjaCA9IGN1cnJlbnRCYXRjaElkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR3JvdXAgYWxsIGl0ZW1zIGJ5IGJhdGNoXG4gICAgICB2ZWN0b3JTdG9yZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBiYXRjaElkID0gaXRlbS5tZXRhZGF0YT8uYmF0Y2g7XG4gICAgICAgIGlmIChiYXRjaElkKSB7XG4gICAgICAgICAgaWYgKCFiYXRjaE1hcFtiYXRjaElkXSkgYmF0Y2hNYXBbYmF0Y2hJZF0gPSBbXTtcbiAgICAgICAgICBiYXRjaE1hcFtiYXRjaElkXS5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSBlYWNoIGJhdGNoXG4gICAgICBPYmplY3QuZW50cmllcyhiYXRjaE1hcCkuZm9yRWFjaCgoW2JhdGNoSWQsIGl0ZW1zXSkgPT4ge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNhdmVCYXRjaChiYXRjaElkLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgaW5kZXggZmlsZVxuICAgIGZzLndyaXRlRmlsZVN5bmMoQkFUQ0hfSU5ERVhfRklMRSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYWN0aXZlQmF0Y2hlcyxcbiAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgfSwgbnVsbCwgMikpO1xuICAgIFxuICAgIC8vIEFsc28gc2F2ZSB0byB0aGUgc2luZ2xlIHZlY3RvclN0b3JlLmpzb24gZmlsZSBhcyBhIGJhY2t1cFxuICAgIGNvbnN0IHNpbmdsZVN0b3JlRmlsZSA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGF0YScsICd2ZWN0b3JTdG9yZS5qc29uJyk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhzaW5nbGVTdG9yZUZpbGUsIEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICBpdGVtczogdmVjdG9yU3RvcmUsXG4gICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICAgIH0sIG51bGwsIDIpKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgU2F2ZWQgdmVjdG9yIHN0b3JlIHdpdGggJHthY3RpdmVCYXRjaGVzLmxlbmd0aH0gYmF0Y2hlcyBhbmQgJHt2ZWN0b3JTdG9yZS5sZW5ndGh9IHRvdGFsIGl0ZW1zYCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHZlY3RvciBzdG9yZTonLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY29zaW5lIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gdmVjdG9yc1xuICogQHBhcmFtIHZlY0EgRmlyc3QgdmVjdG9yXG4gKiBAcGFyYW0gdmVjQiBTZWNvbmQgdmVjdG9yXG4gKiBAcmV0dXJucyBDb3NpbmUgc2ltaWxhcml0eSBzY29yZSAoMC0xKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWNBOiBudW1iZXJbXSwgdmVjQjogbnVtYmVyW10pOiBudW1iZXIge1xuICBjb25zdCBkb3QgPSB2ZWNBLnJlZHVjZSgoc3VtLCBhLCBpKSA9PiBzdW0gKyBhICogdmVjQltpXSwgMCk7XG4gIGNvbnN0IG1hZ0EgPSBNYXRoLnNxcnQodmVjQS5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYSAqIGEsIDApKTtcbiAgY29uc3QgbWFnQiA9IE1hdGguc3FydCh2ZWNCLnJlZHVjZSgoc3VtLCBiKSA9PiBzdW0gKyBiICogYiwgMCkpO1xuICByZXR1cm4gZG90IC8gKG1hZ0EgKiBtYWdCKTtcbn1cblxuLyoqXG4gKiBBZGQgYW4gaXRlbSBvciBtdWx0aXBsZSBpdGVtcyB0byB0aGUgdmVjdG9yIHN0b3JlXG4gKiBAcGFyYW0gaXRlbXMgU2luZ2xlIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUb1ZlY3RvclN0b3JlKGl0ZW1zOiBWZWN0b3JTdG9yZUl0ZW0gfCBWZWN0b3JTdG9yZUl0ZW1bXSk6IHZvaWQge1xuICAvLyBDb252ZXJ0IHNpbmdsZSBpdGVtIHRvIGFycmF5XG4gIGNvbnN0IGl0ZW1zQXJyYXkgPSBBcnJheS5pc0FycmF5KGl0ZW1zKSA/IGl0ZW1zIDogW2l0ZW1zXTtcbiAgaWYgKGl0ZW1zQXJyYXkubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIFxuICAvLyBBZGQgdG8gaW4tbWVtb3J5IHN0b3JlXG4gIHZlY3RvclN0b3JlID0gWy4uLnZlY3RvclN0b3JlLCAuLi5pdGVtc0FycmF5XTtcbiAgXG4gIC8vIFNhdmUgY2hhbmdlcyB0byBkaXNrXG4gIHNhdmVWZWN0b3JTdG9yZSgpO1xufVxuXG4vLyBFbmhhbmNlZCB2ZXJzaW9uIG9mIGdldFNpbWlsYXJJdGVtcyB3aXRoIHN0cm9uZ2VyIGVtcGhhc2lzIG9uIHN0cnVjdHVyZWQgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpbWlsYXJJdGVtcyhcbiAgcXVlcnlFbWJlZGRpbmc6IG51bWJlcltdLFxuICBsaW1pdDogbnVtYmVyID0gNSxcbiAgcXVlcnlUZXh0Pzogc3RyaW5nLFxuICBwcmlvcml0eUluZm9UeXBlPzogc3RyaW5nXG4pOiAoVmVjdG9yU3RvcmVJdGVtICYgeyBzY29yZTogbnVtYmVyIH0pW10ge1xuICAvLyBDaGVjayBpZiB0aGUgdmVjdG9yIHN0b3JlIGlzIGluaXRpYWxpemVkXG4gIGlmICghdmVjdG9yU3RvcmUgfHwgdmVjdG9yU3RvcmUubGVuZ3RoID09PSAwKSB7XG4gICAgbG9hZFZlY3RvclN0b3JlKCk7XG4gIH1cbiAgXG4gIGlmICghdmVjdG9yU3RvcmUgfHwgdmVjdG9yU3RvcmUubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS53YXJuKCdWZWN0b3Igc3RvcmUgaXMgZW1wdHkuIE5vIHJlc3VsdHMgdG8gcmV0dXJuLicpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ1NlYXJjaGluZyBmb3Igc2ltaWxhciBpdGVtcy4uLicpO1xuICBcbiAgLy8gTG9vayBmb3IgY2VydGFpbiB0eXBlcyBvZiBpbnF1aXJpZXMgdG8gYm9vc3Qgc3BlY2lmaWMgY29udGVudFxuICBsZXQgc2hvdWxkQm9vc3RTdHJ1Y3R1cmVkSW5mbyA9IGZhbHNlO1xuICBsZXQgc2hvdWxkQm9vc3RDb21wYW55VmFsdWVzID0gZmFsc2U7XG4gIGxldCBzaG91bGRCb29zdEludmVzdG9ycyA9IGZhbHNlO1xuICBsZXQgc2hvdWxkQm9vc3RMZWFkZXJzaGlwID0gZmFsc2U7XG4gIGxldCBzaG91bGRCb29zdFByaWNpbmcgPSBmYWxzZTtcbiAgbGV0IHNob3VsZEJvb3N0UHJvZHVjdEZlYXR1cmVzID0gZmFsc2U7XG4gIGxldCBzaG91bGRCb29zdFNhbGVzSW5mbyA9IGZhbHNlO1xuICBcbiAgaWYgKHF1ZXJ5VGV4dCkge1xuICAgIGNvbnN0IHF1ZXJ5TG93ZXIgPSBxdWVyeVRleHQudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgY29tcGFueSB2YWx1ZXMgaW5xdWlyaWVzXG4gICAgc2hvdWxkQm9vc3RDb21wYW55VmFsdWVzID0gcXVlcnlMb3dlci5pbmNsdWRlcygndmFsdWUnKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCdjdWx0dXJlJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygncHJpbmNpcGxlJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCdtaXNzaW9uJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCd2aXNpb24nKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgaW52ZXN0b3IgaW5xdWlyaWVzXG4gICAgc2hvdWxkQm9vc3RJbnZlc3RvcnMgPSBxdWVyeUxvd2VyLmluY2x1ZGVzKCdpbnZlc3RvcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygnZnVuZGluZycpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygnYmFja2VkIGJ5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2ludmVzdGVkJyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGxlYWRlcnNoaXAgaW5xdWlyaWVzXG4gICAgc2hvdWxkQm9vc3RMZWFkZXJzaGlwID0gcXVlcnlMb3dlci5pbmNsdWRlcygnZm91bmRlcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2NlbycpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2xlYWRlcicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygnZXhlY3V0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ2hlY2sgZm9yIHByaWNpbmcgaW5xdWlyaWVzXG4gICAgc2hvdWxkQm9vc3RQcmljaW5nID0gcXVlcnlMb3dlci5pbmNsdWRlcygncHJpY2luZycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygncHJpY2UnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2Nvc3QnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3N1YnNjcmlwdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygncGxhbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygndGllcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIC8vIENoZWNrIGZvciBwcm9kdWN0IGZlYXR1cmUgaW5xdWlyaWVzICBcbiAgICBzaG91bGRCb29zdFByb2R1Y3RGZWF0dXJlcyA9IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2ZlYXR1cmUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2NhcGFiaWxpdHknKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCdob3cgZG9lcyBpdCB3b3JrJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlMb3dlci5pbmNsdWRlcygnd2hhdCBkb2VzIGl0IGRvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIC8vIENoZWNrIGZvciBzYWxlcyBpbmZvcm1hdGlvbiBpbnF1aXJpZXNcbiAgICBzaG91bGRCb29zdFNhbGVzSW5mbyA9IHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ3NlbGwnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCdwaXRjaCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TG93ZXIuaW5jbHVkZXMoJ2NvbXBldGl0b3InKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUxvd2VyLmluY2x1ZGVzKCdjb21wYXJpc29uJyk7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBvdmVyYWxsIHN0cnVjdHVyZWQgaW5mbyBmbGFnIGlmIGFueSBzcGVjaWZpYyB0eXBlIHNob3VsZCBiZSBib29zdGVkXG4gICAgc2hvdWxkQm9vc3RTdHJ1Y3R1cmVkSW5mbyA9IHNob3VsZEJvb3N0Q29tcGFueVZhbHVlcyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQm9vc3RJbnZlc3RvcnMgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEJvb3N0TGVhZGVyc2hpcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCb29zdFByaWNpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQm9vc3RQcm9kdWN0RmVhdHVyZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQm9vc3RTYWxlc0luZm87XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBzaW1pbGFyaXR5IHNjb3Jlc1xuICBjb25zdCBpdGVtc1dpdGhTY29yZXMgPSB2ZWN0b3JTdG9yZS5tYXAoaXRlbSA9PiB7XG4gICAgLy8gQ29tcHV0ZSBiYXNlIHNjb3JlIHVzaW5nIGNvc2luZSBzaW1pbGFyaXR5XG4gICAgbGV0IHNjb3JlID0gY29zaW5lU2ltaWxhcml0eShxdWVyeUVtYmVkZGluZywgaXRlbS5lbWJlZGRpbmcpO1xuICAgIFxuICAgIC8vIEFwcGx5IGJvb3N0aW5nIGZvciBzdHJ1Y3R1cmVkIGluZm9ybWF0aW9uIHdoZW4gcmVsZXZhbnRcbiAgICBpZiAoc2hvdWxkQm9vc3RTdHJ1Y3R1cmVkSW5mbyAmJiBpdGVtLm1ldGFkYXRhPy5pc1N0cnVjdHVyZWQpIHtcbiAgICAgIC8vIFNwZWNpZmljIGJvb3N0cyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHN0cnVjdHVyZWQgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IGluZm9UeXBlID0gaXRlbS5tZXRhZGF0YT8uaW5mb1R5cGU7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIGEgc3BlY2lmaWMgaW5mbyB0eXBlIGlzIHByaW9yaXRpemVkXG4gICAgICBpZiAocHJpb3JpdHlJbmZvVHlwZSAmJiBpbmZvVHlwZSA9PT0gcHJpb3JpdHlJbmZvVHlwZSkge1xuICAgICAgICBzY29yZSAqPSAxLjU7IC8vIFN0cm9uZyBib29zdCBmb3IgZXhhY3QgaW5mbyB0eXBlIG1hdGNoXG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIGFwcGx5IHN0YW5kYXJkIGJvb3N0c1xuICAgICAgZWxzZSBpZiAoc2hvdWxkQm9vc3RDb21wYW55VmFsdWVzICYmIGluZm9UeXBlID09PSAnY29tcGFueV92YWx1ZXMnKSB7XG4gICAgICAgIHNjb3JlICo9IDEuMztcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkQm9vc3RJbnZlc3RvcnMgJiYgaW5mb1R5cGUgPT09ICdpbnZlc3RvcnMnKSB7XG4gICAgICAgIHNjb3JlICo9IDEuMztcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkQm9vc3RMZWFkZXJzaGlwICYmIGluZm9UeXBlID09PSAnbGVhZGVyc2hpcCcpIHtcbiAgICAgICAgc2NvcmUgKj0gMS4zO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRCb29zdFByaWNpbmcgJiYgaW5mb1R5cGUgPT09ICdwcmljaW5nJykge1xuICAgICAgICBzY29yZSAqPSAxLjM7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEJvb3N0UHJvZHVjdEZlYXR1cmVzICYmIGluZm9UeXBlID09PSAncHJvZHVjdF9mZWF0dXJlcycpIHtcbiAgICAgICAgc2NvcmUgKj0gMS4zO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRCb29zdFNhbGVzSW5mbyAmJiBpbmZvVHlwZSA9PT0gJ3NhbGVzX2luZm8nKSB7XG4gICAgICAgIHNjb3JlICo9IDEuMztcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5tZXRhZGF0YT8uaXNTdHJ1Y3R1cmVkKSB7XG4gICAgICAgIC8vIEdlbmVyYWwgYm9vc3QgZm9yIGFueSBzdHJ1Y3R1cmVkIGluZm9cbiAgICAgICAgc2NvcmUgKj0gMS4xO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyAuLi5pdGVtLCBzY29yZSB9O1xuICB9KTtcbiAgXG4gIC8vIFNvcnQgYnkgc2ltaWxhcml0eSBzY29yZVxuICBjb25zdCBzb3J0ZWRSZXN1bHRzID0gaXRlbXNXaXRoU2NvcmVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgXG4gIC8vIEdldCB0aGUgdG9wIHJlc3VsdHMsIGJ1dCBlbnN1cmUgcHJpb3JpdHkgc3RydWN0dXJlZCBpbmZvIGlzIGluY2x1ZGVkIGlmIHJlbGV2YW50XG4gIGxldCByZXN1bHQgPSBzb3J0ZWRSZXN1bHRzLnNsaWNlKDAsIGxpbWl0KTtcbiAgXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gZ3VhcmFudGVlIGluY2x1c2lvbiBvZiBzcGVjaWZpYyBzdHJ1Y3R1cmVkIGluZm9cbiAgaWYgKHNob3VsZEJvb3N0U3RydWN0dXJlZEluZm8pIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSByZWxldmFudCBwaWVjZSBvZiBzdHJ1Y3R1cmVkIGluZm9ybWF0aW9uXG4gICAgbGV0IGhhc1JlbGV2YW50U3RydWN0dXJlZEluZm8gPSBmYWxzZTtcbiAgICBcbiAgICAvLyBVc2UgdGhlIHByaW9yaXR5SW5mb1R5cGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgY2hlY2sgYWxsIHJlbGV2YW50IHR5cGVzXG4gICAgaWYgKHByaW9yaXR5SW5mb1R5cGUpIHtcbiAgICAgIGhhc1JlbGV2YW50U3RydWN0dXJlZEluZm8gPSByZXN1bHQuc29tZShcbiAgICAgICAgaXRlbSA9PiBpdGVtLm1ldGFkYXRhPy5pbmZvVHlwZSA9PT0gcHJpb3JpdHlJbmZvVHlwZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzUmVsZXZhbnRTdHJ1Y3R1cmVkSW5mbyA9IHJlc3VsdC5zb21lKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBpbmZvVHlwZSA9IGl0ZW0ubWV0YWRhdGE/LmluZm9UeXBlO1xuICAgICAgICByZXR1cm4gKHNob3VsZEJvb3N0Q29tcGFueVZhbHVlcyAmJiBpbmZvVHlwZSA9PT0gJ2NvbXBhbnlfdmFsdWVzJykgfHxcbiAgICAgICAgICAgICAgIChzaG91bGRCb29zdEludmVzdG9ycyAmJiBpbmZvVHlwZSA9PT0gJ2ludmVzdG9ycycpIHx8XG4gICAgICAgICAgICAgICAoc2hvdWxkQm9vc3RMZWFkZXJzaGlwICYmIGluZm9UeXBlID09PSAnbGVhZGVyc2hpcCcpIHx8XG4gICAgICAgICAgICAgICAoc2hvdWxkQm9vc3RQcmljaW5nICYmIGluZm9UeXBlID09PSAncHJpY2luZycpIHx8XG4gICAgICAgICAgICAgICAoc2hvdWxkQm9vc3RQcm9kdWN0RmVhdHVyZXMgJiYgaW5mb1R5cGUgPT09ICdwcm9kdWN0X2ZlYXR1cmVzJykgfHxcbiAgICAgICAgICAgICAgIChzaG91bGRCb29zdFNhbGVzSW5mbyAmJiBpbmZvVHlwZSA9PT0gJ3NhbGVzX2luZm8nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIHRoZSByZWxldmFudCBpbmZvIGluIG91ciB0b3AgcmVzdWx0cywgZmluZCBhbmQgaW5jbHVkZSBpdFxuICAgIGlmICghaGFzUmVsZXZhbnRTdHJ1Y3R1cmVkSW5mbykge1xuICAgICAgbGV0IHN0cnVjdHVyZWRJbmZvVG9JbmNsdWRlO1xuICAgICAgXG4gICAgICBpZiAocHJpb3JpdHlJbmZvVHlwZSkge1xuICAgICAgICAvLyBMb29rIGZvciB0aGUgc3BlY2lmaWMgcHJpb3JpdHkgaW5mbyB0eXBlXG4gICAgICAgIHN0cnVjdHVyZWRJbmZvVG9JbmNsdWRlID0gc29ydGVkUmVzdWx0cy5maW5kKFxuICAgICAgICAgIGl0ZW0gPT4gaXRlbS5tZXRhZGF0YT8uaW5mb1R5cGUgPT09IHByaW9yaXR5SW5mb1R5cGUgJiYgIXJlc3VsdC5pbmNsdWRlcyhpdGVtKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9vayBmb3IgYW55IHJlbGV2YW50IHN0cnVjdHVyZWQgaW5mbyB0eXBlXG4gICAgICAgIHN0cnVjdHVyZWRJbmZvVG9JbmNsdWRlID0gc29ydGVkUmVzdWx0cy5maW5kKGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGluZm9UeXBlID0gaXRlbS5tZXRhZGF0YT8uaW5mb1R5cGU7XG4gICAgICAgICAgcmV0dXJuICgoc2hvdWxkQm9vc3RDb21wYW55VmFsdWVzICYmIGluZm9UeXBlID09PSAnY29tcGFueV92YWx1ZXMnKSB8fFxuICAgICAgICAgICAgICAgICAoc2hvdWxkQm9vc3RJbnZlc3RvcnMgJiYgaW5mb1R5cGUgPT09ICdpbnZlc3RvcnMnKSB8fFxuICAgICAgICAgICAgICAgICAoc2hvdWxkQm9vc3RMZWFkZXJzaGlwICYmIGluZm9UeXBlID09PSAnbGVhZGVyc2hpcCcpIHx8XG4gICAgICAgICAgICAgICAgIChzaG91bGRCb29zdFByaWNpbmcgJiYgaW5mb1R5cGUgPT09ICdwcmljaW5nJykgfHxcbiAgICAgICAgICAgICAgICAgKHNob3VsZEJvb3N0UHJvZHVjdEZlYXR1cmVzICYmIGluZm9UeXBlID09PSAncHJvZHVjdF9mZWF0dXJlcycpIHx8XG4gICAgICAgICAgICAgICAgIChzaG91bGRCb29zdFNhbGVzSW5mbyAmJiBpbmZvVHlwZSA9PT0gJ3NhbGVzX2luZm8nKSkgJiZcbiAgICAgICAgICAgICAgICAgIXJlc3VsdC5pbmNsdWRlcyhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGZvdW5kIGEgcmVsZXZhbnQgaXRlbSwgYWRkIGl0IGFuZCByZW1vdmUgdGhlIGxvd2VzdCBzY29yZWQgaXRlbVxuICAgICAgaWYgKHN0cnVjdHVyZWRJbmZvVG9JbmNsdWRlKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBsb3dlc3Qgc2NvcmVkIGl0ZW1cbiAgICAgICAgcmVzdWx0LnB1c2goc3RydWN0dXJlZEluZm9Ub0luY2x1ZGUpO1xuICAgICAgICAvLyBSZS1zb3J0IHRvIG1haW50YWluIHNjb3JlIG9yZGVyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSB2ZWN0b3Igc3RvcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVmVjdG9yU3RvcmUoKTogdm9pZCB7XG4gIC8vIENsZWFyIGluLW1lbW9yeSBkYXRhXG4gIHZlY3RvclN0b3JlID0gW107XG4gIFxuICAvLyBEZWxldGUgYWxsIGJhdGNoIGZpbGVzXG4gIHRyeSB7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoVkVDVE9SX1NUT1JFX0RJUikpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoVkVDVE9SX1NUT1JFX0RJUik7XG4gICAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICBpZiAoZmlsZS5zdGFydHNXaXRoKCdiYXRjaF8nKSkge1xuICAgICAgICAgIGZzLnVubGlua1N5bmMocGF0aC5qb2luKFZFQ1RPUl9TVE9SRV9ESVIsIGZpbGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IGJhdGNoIGluZGV4XG4gICAgYWN0aXZlQmF0Y2hlcyA9IFtdO1xuICAgIGZzLndyaXRlRmlsZVN5bmMoQkFUQ0hfSU5ERVhfRklMRSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYWN0aXZlQmF0Y2hlczogW10sXG4gICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICAgIH0sIG51bGwsIDIpKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnVmVjdG9yIHN0b3JlIGNsZWFyZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgdmVjdG9yIHN0b3JlOicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSB2ZWN0b3Igc3RvcmVcbiAqIEByZXR1cm5zIE51bWJlciBvZiBpdGVtcyBpbiB0aGUgdmVjdG9yIHN0b3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWN0b3JTdG9yZVNpemUoKTogbnVtYmVyIHtcbiAgcmV0dXJuIHZlY3RvclN0b3JlLmxlbmd0aDtcbn1cblxuLy8gSW5pdGlhbGl6ZSB2ZWN0b3Igc3RvcmUgb24gbW9kdWxlIGxvYWRcbnRyeSB7XG4gIGxvYWRWZWN0b3JTdG9yZSgpO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgdmVjdG9yIHN0b3JlOicsIGVycm9yKTtcbiAgdmVjdG9yU3RvcmUgPSBbXTtcbiAgYWN0aXZlQmF0Y2hlcyA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhbGwgaXRlbXMgZnJvbSB0aGUgdmVjdG9yIHN0b3JlXG4gKiBAcmV0dXJucyBBcnJheSBvZiBhbGwgdmVjdG9yIHN0b3JlIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxWZWN0b3JTdG9yZUl0ZW1zKCk6IFZlY3RvclN0b3JlSXRlbVtdIHtcbiAgcmV0dXJuIFsuLi52ZWN0b3JTdG9yZV07XG59XG5cbmV4cG9ydCB7IHZlY3RvclN0b3JlIH07ICJdLCJuYW1lcyI6WyJmcyIsInBhdGgiLCJWRUNUT1JfU1RPUkVfRElSIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJCQVRDSF9JTkRFWF9GSUxFIiwiTUFYX0JBVENIX1NJWkUiLCJ2ZWN0b3JTdG9yZSIsImFjdGl2ZUJhdGNoZXMiLCJpbml0VmVjdG9yU3RvcmUiLCJkYXRhRGlyIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsIndyaXRlRmlsZVN5bmMiLCJKU09OIiwic3RyaW5naWZ5IiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwibm93IiwibG9hZFZlY3RvclN0b3JlIiwiY29uc29sZSIsImxvZyIsImluZGV4RGF0YSIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwidG90YWxMb2FkZWQiLCJiYXRjaElkIiwiYmF0Y2hGaWxlIiwiYmF0Y2hEYXRhIiwibGVuZ3RoIiwiZXJyb3IiLCJzaW5nbGVTdG9yZUZpbGUiLCJmaWxlRGF0YSIsInBhcnNlZERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtcyIsImNyZWF0ZU5ld0JhdGNoIiwidG9TdHJpbmciLCJwdXNoIiwic2F2ZUJhdGNoIiwic2F2ZVZlY3RvclN0b3JlIiwiaW5pdGlhbEJhdGNoSWQiLCJtYXAiLCJpdGVtIiwibWV0YWRhdGEiLCJiYXRjaCIsImJhdGNoTWFwIiwidW5iYXRjaGVkSXRlbXMiLCJmaWx0ZXIiLCJjdXJyZW50QmF0Y2hJZCIsImN1cnJlbnRCYXRjaENvdW50IiwiZm9yRWFjaCIsIk9iamVjdCIsImVudHJpZXMiLCJjb3NpbmVTaW1pbGFyaXR5IiwidmVjQSIsInZlY0IiLCJkb3QiLCJyZWR1Y2UiLCJzdW0iLCJhIiwiaSIsIm1hZ0EiLCJNYXRoIiwic3FydCIsIm1hZ0IiLCJiIiwiYWRkVG9WZWN0b3JTdG9yZSIsIml0ZW1zQXJyYXkiLCJnZXRTaW1pbGFySXRlbXMiLCJxdWVyeUVtYmVkZGluZyIsImxpbWl0IiwicXVlcnlUZXh0IiwicHJpb3JpdHlJbmZvVHlwZSIsIndhcm4iLCJzaG91bGRCb29zdFN0cnVjdHVyZWRJbmZvIiwic2hvdWxkQm9vc3RDb21wYW55VmFsdWVzIiwic2hvdWxkQm9vc3RJbnZlc3RvcnMiLCJzaG91bGRCb29zdExlYWRlcnNoaXAiLCJzaG91bGRCb29zdFByaWNpbmciLCJzaG91bGRCb29zdFByb2R1Y3RGZWF0dXJlcyIsInNob3VsZEJvb3N0U2FsZXNJbmZvIiwicXVlcnlMb3dlciIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJpdGVtc1dpdGhTY29yZXMiLCJzY29yZSIsImVtYmVkZGluZyIsImlzU3RydWN0dXJlZCIsImluZm9UeXBlIiwic29ydGVkUmVzdWx0cyIsInNvcnQiLCJyZXN1bHQiLCJzbGljZSIsImhhc1JlbGV2YW50U3RydWN0dXJlZEluZm8iLCJzb21lIiwic3RydWN0dXJlZEluZm9Ub0luY2x1ZGUiLCJmaW5kIiwicG9wIiwiY2xlYXJWZWN0b3JTdG9yZSIsImZpbGVzIiwicmVhZGRpclN5bmMiLCJmaWxlIiwic3RhcnRzV2l0aCIsInVubGlua1N5bmMiLCJnZXRWZWN0b3JTdG9yZVNpemUiLCJnZXRBbGxWZWN0b3JTdG9yZUl0ZW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/vectorStore.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fquery&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fquery.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();
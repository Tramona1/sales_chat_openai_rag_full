import { NextApiRequest, NextApiResponse } from 'next';
import { 
  processDocumentWithGemini, 
  convertAnalysisToMetadata,
  processDocumentWithEnhancedLabels,
  convertEnhancedAnalysisToMetadata
} from '@/utils/geminiProcessor';
import { embedText } from '@/utils/openaiClient';
import { logError, logInfo } from '@/utils/errorHandling';
import { addToPendingDocuments, checkForContentConflicts } from '@/utils/adminWorkflow';

/**
 * API endpoint for ingesting documents with Gemini processing
 * This endpoint processes documents, analyzes them with Gemini, and adds them to the pending queue
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    // Extract document text and metadata from request
    const { 
      text, 
      source, 
      existingMetadata, 
      useEnhancedLabeling = true, // Default to enhanced labeling 
      retryCount = 0              // For handling Gemini processing retries
    } = req.body;

    if (!text || typeof text !== 'string') {
      return res.status(400).json({ message: 'Missing or invalid document text' });
    }

    if (!source || typeof source !== 'string') {
      return res.status(400).json({ message: 'Missing document source identifier' });
    }

    // Log ingestion request
    logInfo('Processing document for ingestion', { 
      source,
      textLength: text.length,
      hasExistingMetadata: !!existingMetadata,
      useEnhancedLabeling
    });

    // Check for potential content conflicts early
    const { hasConflicts, conflictingDocIds } = await checkForContentConflicts(
      { source, ...(existingMetadata || {}) },
      text
    );

    // Process document with Gemini - always try enhanced processing first
    let metadata;
    let analysisSummary;
    let processingSuccess = true;
    
    try {
      // Use enhanced processing with more detailed categories and labels
      const enhancedAnalysis = await processDocumentWithEnhancedLabels(text);
      
      // Validate minimum required fields exist in the analysis
      if (!enhancedAnalysis.primaryCategory || 
          !enhancedAnalysis.summary || 
          enhancedAnalysis.technicalLevel === undefined) {
        throw new Error('Insufficient metadata generated by Gemini');
      }
      
      metadata = {
        ...convertEnhancedAnalysisToMetadata(enhancedAnalysis),
        // Add source ID and other provided metadata
        source,
        ...(existingMetadata || {})
      };
      
      // Return enhanced analysis summary
      analysisSummary = {
        summary: enhancedAnalysis.summary,
        contentType: enhancedAnalysis.contentType,
        primaryCategory: enhancedAnalysis.primaryCategory,
        technicalLevel: enhancedAnalysis.technicalLevel,
        complexityScore: enhancedAnalysis.complexityScore,
        keyEntities: {
          people: enhancedAnalysis.entities.people.map(p => p.name),
          companies: enhancedAnalysis.entities.companies.map(c => c.name)
        },
        keywords: enhancedAnalysis.keywords,
        semanticKeywords: enhancedAnalysis.semanticKeywords,
        topics: enhancedAnalysis.topics,
        subtopics: enhancedAnalysis.subtopics,
        confidenceScore: enhancedAnalysis.confidenceScore,
        authorityScore: enhancedAnalysis.authorityScore,
        industries: enhancedAnalysis.industryCategories,
        useCases: enhancedAnalysis.useCases
      };
    } catch (enhancedError) {
      // Log the enhanced processing error
      logError('Enhanced Gemini processing failed', enhancedError);
      
      // Fall back to standard processing if enhanced fails
      try {
        const standardAnalysis = await processDocumentWithGemini(text);
        metadata = {
          ...convertAnalysisToMetadata(standardAnalysis),
          source,
          ...(existingMetadata || {})
        };
        
        // Return standard analysis summary
        analysisSummary = {
          summary: standardAnalysis.summary,
          contentType: standardAnalysis.contentType,
          primaryCategory: standardAnalysis.primaryCategory,
          technicalLevel: standardAnalysis.technicalLevel,
          keyEntities: {
            people: standardAnalysis.entities.people.map(p => p.name),
            companies: standardAnalysis.entities.companies.map(c => c.name)
          },
          keywords: standardAnalysis.keywords,
          confidenceScore: standardAnalysis.confidenceScore
        };
        
        // Mark that we had to fall back
        processingSuccess = false;
      } catch (standardError) {
        // If both enhanced and standard processing fail, retry once more
        if (retryCount < 1) {
          // Retry the request once with backoff
          logInfo('Retrying Gemini processing after failure', { source, retryCount });
          
          // Make a new request with incremented retry count
          const retryResponse = await fetch('/api/admin/ingest-document', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              text,
              source,
              existingMetadata,
              useEnhancedLabeling: true,
              retryCount: retryCount + 1
            })
          });
          
          return res.status(retryResponse.status).json(await retryResponse.json());
        }
        
        // If retries exhausted, use minimal metadata
        logError('Both enhanced and standard Gemini processing failed', standardError);
        metadata = {
          source,
          ...(existingMetadata || {}),
          summary: text.substring(0, 200) + '...',
          primaryCategory: 'general',
          technicalLevel: 2,
          processingFailed: true
        };
        
        analysisSummary = {
          summary: text.substring(0, 200) + '...',
          contentType: 'unknown',
          primaryCategory: 'general',
          technicalLevel: 2,
          keyEntities: { people: [], companies: [] },
          keywords: [],
          confidenceScore: 0
        };
        
        processingSuccess = false;
      }
    }

    // Generate embedding for vector storage
    const embedding = await embedText(text);

    // Add to pending documents queue instead of vector store
    const documentId = await addToPendingDocuments(text, metadata, embedding);

    // Return success with analysis summary and conflict information
    return res.status(200).json({
      success: true,
      message: 'Document processed and added to pending queue',
      documentId,
      requiresApproval: true,
      useEnhancedLabeling,
      processingSuccess,
      hasConflicts,
      conflictingDocIds: hasConflicts ? conflictingDocIds : [],
      analysis: analysisSummary
    });
  } catch (error) {
    // Log error
    logError('Error processing document for ingestion', error);

    // Return error response
    return res.status(500).json({
      success: false,
      message: 'Failed to process document',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
} 